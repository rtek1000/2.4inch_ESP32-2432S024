/*! @name @videojs/http-streaming @version 2.15.0 @license Apache-2.0 */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports, require("video.js")) : "function" == typeof define && define.amd ? define(["exports", "video.js"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).httpStreaming = {}, e.videojs) }(this, (function (e, t) {
	"use strict"; function i(e) { return e && "object" == typeof e && "default" in e ? e : { default: e } } var n = i(t); function r(e, t, i) { return e(i = { path: t, exports: {}, require: function (e, t) { return function () { throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs") }(null == t && i.path) } }, i.exports), i.exports } var a = r((function (e) { e.exports = function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }, e.exports.default = e.exports, e.exports.__esModule = !0 })), s = r((function (e) { function t(i, n) { return e.exports = t = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e }, e.exports.default = e.exports, e.exports.__esModule = !0, t(i, n) } e.exports = t, e.exports.default = e.exports, e.exports.__esModule = !0 })), o = r((function (e) { e.exports = function (e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, s(e, t) }, e.exports.default = e.exports, e.exports.__esModule = !0 })), u = r((function (e, t) { var i, n, r, a, s; i = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/?#]*\/)*[^;?#]*)?(;[^?#]*)?(\?[^#]*)?(#[^]*)?$/, n = /^([^\/?#]*)([^]*)$/, r = /(?:\/|^)\.(?=\/)/g, a = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, s = { buildAbsoluteURL: function (e, t, i) { if (i = i || {}, e = e.trim(), !(t = t.trim())) { if (!i.alwaysNormalize) return e; var r = s.parseURL(e); if (!r) throw new Error("Error trying to parse base URL."); return r.path = s.normalizePath(r.path), s.buildURLFromParts(r) } var a = s.parseURL(t); if (!a) throw new Error("Error trying to parse relative URL."); if (a.scheme) return i.alwaysNormalize ? (a.path = s.normalizePath(a.path), s.buildURLFromParts(a)) : t; var o = s.parseURL(e); if (!o) throw new Error("Error trying to parse base URL."); if (!o.netLoc && o.path && "/" !== o.path[0]) { var u = n.exec(o.path); o.netLoc = u[1], o.path = u[2] } o.netLoc && !o.path && (o.path = "/"); var d = { scheme: o.scheme, netLoc: a.netLoc, path: null, params: a.params, query: a.query, fragment: a.fragment }; if (!a.netLoc && (d.netLoc = o.netLoc, "/" !== a.path[0])) if (a.path) { var l = o.path, h = l.substring(0, l.lastIndexOf("/") + 1) + a.path; d.path = s.normalizePath(h) } else d.path = o.path, a.params || (d.params = o.params, a.query || (d.query = o.query)); return null === d.path && (d.path = i.alwaysNormalize ? s.normalizePath(a.path) : a.path), s.buildURLFromParts(d) }, parseURL: function (e) { var t = i.exec(e); return t ? { scheme: t[1] || "", netLoc: t[2] || "", path: t[3] || "", params: t[4] || "", query: t[5] || "", fragment: t[6] || "" } : null }, normalizePath: function (e) { for (e = e.split("").reverse().join("").replace(r, ""); e.length !== (e = e.replace(a, "")).length;); return e.split("").reverse().join("") }, buildURLFromParts: function (e) { return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment } }, e.exports = s })), d = "http://example.com", l = function (e, t) { if (/^[a-z]+:/i.test(t)) return t; /^data:/.test(e) && (e = window.location && window.location.href || ""); var i = "function" == typeof window.URL, n = /^\/\//.test(e), r = !window.location && !/\/\//i.test(e); if (i ? e = new window.URL(e, window.location || d) : /\/\//i.test(e) || (e = u.buildAbsoluteURL(window.location && window.location.href || "", e)), i) { var a = new URL(t, e); return r ? a.href.slice(d.length) : n ? a.href.slice(a.protocol.length) : a.href } return u.buildAbsoluteURL(e, t) }, h = function (e, t, i) { return e && i && i.responseURL && t !== i.responseURL ? i.responseURL : t }, c = function (e) { return n.default.log.debug ? n.default.log.debug.bind(n.default, "VHS:", e + " >") : function () { } }, f = r((function (e) { function t() { return e.exports = t = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var i = arguments[t]; for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n]) } return e }, e.exports.default = e.exports, e.exports.__esModule = !0, t.apply(this, arguments) } e.exports = t, e.exports.default = e.exports, e.exports.__esModule = !0 })), p = function () { function e() { this.listeners = {} } var t = e.prototype; return t.on = function (e, t) { this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t) }, t.off = function (e, t) { if (!this.listeners[e]) return !1; var i = this.listeners[e].indexOf(t); return this.listeners[e] = this.listeners[e].slice(0), this.listeners[e].splice(i, 1), i > -1 }, t.trigger = function (e) { var t = this.listeners[e]; if (t) if (2 === arguments.length) for (var i = t.length, n = 0; n < i; ++n)t[n].call(this, arguments[1]); else for (var r = Array.prototype.slice.call(arguments, 1), a = t.length, s = 0; s < a; ++s)t[s].apply(this, r) }, t.dispose = function () { this.listeners = {} }, t.pipe = function (e) { this.on("data", (function (t) { e.push(t) })) }, e }(); function m(e) { for (var t, i = (t = e, window.atob ? window.atob(t) : Buffer.from(t, "base64").toString("binary")), n = new Uint8Array(i.length), r = 0; r < i.length; r++)n[r] = i.charCodeAt(r); return n }
/*! @name m3u8-parser @version 4.8.0 @license Apache-2.0 */var g, y, _ = function (e) { function t() { var t; return (t = e.call(this) || this).buffer = "", t } return o(t, e), t.prototype.push = function (e) { var t; for (this.buffer += e, t = this.buffer.indexOf("\n"); t > -1; t = this.buffer.indexOf("\n"))this.trigger("data", this.buffer.substring(0, t)), this.buffer = this.buffer.substring(t + 1) }, t }(p), v = String.fromCharCode(9), b = function (e) { var t = /([0-9.]*)?@?([0-9.]*)?/.exec(e || ""), i = {}; return t[1] && (i.length = parseInt(t[1], 10)), t[2] && (i.offset = parseInt(t[2], 10)), i }, T = function (e) { for (var t, i = e.split(new RegExp('(?:^|,)((?:[^=]*)=(?:"[^"]*"|[^,]*))')), n = {}, r = i.length; r--;)"" !== i[r] && ((t = /([^=]*)=(.*)/.exec(i[r]).slice(1))[0] = t[0].replace(/^\s+|\s+$/g, ""), t[1] = t[1].replace(/^\s+|\s+$/g, ""), t[1] = t[1].replace(/^['"](.*)['"]$/g, "$1"), n[t[0]] = t[1]); return n }, S = function (e) { function t() { var t; return (t = e.call(this) || this).customParsers = [], t.tagMappers = [], t } o(t, e); var i = t.prototype; return i.push = function (e) { var t, i, n = this; 0 !== (e = e.trim()).length && ("#" === e[0] ? this.tagMappers.reduce((function (t, i) { var n = i(e); return n === e ? t : t.concat([n]) }), [e]).forEach((function (e) { for (var r = 0; r < n.customParsers.length; r++)if (n.customParsers[r].call(n, e)) return; if (0 === e.indexOf("#EXT")) if (e = e.replace("\r", ""), t = /^#EXTM3U/.exec(e)) n.trigger("data", { type: "tag", tagType: "m3u" }); else { if (t = /^#EXTINF:?([0-9\.]*)?,?(.*)?$/.exec(e)) return i = { type: "tag", tagType: "inf" }, t[1] && (i.duration = parseFloat(t[1])), t[2] && (i.title = t[2]), void n.trigger("data", i); if (t = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(e)) return i = { type: "tag", tagType: "targetduration" }, t[1] && (i.duration = parseInt(t[1], 10)), void n.trigger("data", i); if (t = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(e)) return i = { type: "tag", tagType: "version" }, t[1] && (i.version = parseInt(t[1], 10)), void n.trigger("data", i); if (t = /^#EXT-X-MEDIA-SEQUENCE:?(\-?[0-9.]*)?/.exec(e)) return i = { type: "tag", tagType: "media-sequence" }, t[1] && (i.number = parseInt(t[1], 10)), void n.trigger("data", i); if (t = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\-?[0-9.]*)?/.exec(e)) return i = { type: "tag", tagType: "discontinuity-sequence" }, t[1] && (i.number = parseInt(t[1], 10)), void n.trigger("data", i); if (t = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(e)) return i = { type: "tag", tagType: "playlist-type" }, t[1] && (i.playlistType = t[1]), void n.trigger("data", i); if (t = /^#EXT-X-BYTERANGE:?(.*)?$/.exec(e)) return i = f(b(t[1]), { type: "tag", tagType: "byterange" }), void n.trigger("data", i); if (t = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(e)) return i = { type: "tag", tagType: "allow-cache" }, t[1] && (i.allowed = !/NO/.test(t[1])), void n.trigger("data", i); if (t = /^#EXT-X-MAP:?(.*)$/.exec(e)) { if (i = { type: "tag", tagType: "map" }, t[1]) { var a = T(t[1]); a.URI && (i.uri = a.URI), a.BYTERANGE && (i.byterange = b(a.BYTERANGE)) } n.trigger("data", i) } else if (t = /^#EXT-X-STREAM-INF:?(.*)$/.exec(e)) { if (i = { type: "tag", tagType: "stream-inf" }, t[1]) { if (i.attributes = T(t[1]), i.attributes.RESOLUTION) { var s = i.attributes.RESOLUTION.split("x"), o = {}; s[0] && (o.width = parseInt(s[0], 10)), s[1] && (o.height = parseInt(s[1], 10)), i.attributes.RESOLUTION = o } i.attributes.BANDWIDTH && (i.attributes.BANDWIDTH = parseInt(i.attributes.BANDWIDTH, 10)), i.attributes["FRAME-RATE"] && (i.attributes["FRAME-RATE"] = parseFloat(i.attributes["FRAME-RATE"])), i.attributes["PROGRAM-ID"] && (i.attributes["PROGRAM-ID"] = parseInt(i.attributes["PROGRAM-ID"], 10)) } n.trigger("data", i) } else { if (t = /^#EXT-X-MEDIA:?(.*)$/.exec(e)) return i = { type: "tag", tagType: "media" }, t[1] && (i.attributes = T(t[1])), void n.trigger("data", i); if (t = /^#EXT-X-ENDLIST/.exec(e)) n.trigger("data", { type: "tag", tagType: "endlist" }); else if (t = /^#EXT-X-DISCONTINUITY/.exec(e)) n.trigger("data", { type: "tag", tagType: "discontinuity" }); else { if (t = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(e)) return i = { type: "tag", tagType: "program-date-time" }, t[1] && (i.dateTimeString = t[1], i.dateTimeObject = new Date(t[1])), void n.trigger("data", i); if (t = /^#EXT-X-KEY:?(.*)$/.exec(e)) return i = { type: "tag", tagType: "key" }, t[1] && (i.attributes = T(t[1]), i.attributes.IV && ("0x" === i.attributes.IV.substring(0, 2).toLowerCase() && (i.attributes.IV = i.attributes.IV.substring(2)), i.attributes.IV = i.attributes.IV.match(/.{8}/g), i.attributes.IV[0] = parseInt(i.attributes.IV[0], 16), i.attributes.IV[1] = parseInt(i.attributes.IV[1], 16), i.attributes.IV[2] = parseInt(i.attributes.IV[2], 16), i.attributes.IV[3] = parseInt(i.attributes.IV[3], 16), i.attributes.IV = new Uint32Array(i.attributes.IV))), void n.trigger("data", i); if (t = /^#EXT-X-START:?(.*)$/.exec(e)) return i = { type: "tag", tagType: "start" }, t[1] && (i.attributes = T(t[1]), i.attributes["TIME-OFFSET"] = parseFloat(i.attributes["TIME-OFFSET"]), i.attributes.PRECISE = /YES/.test(i.attributes.PRECISE)), void n.trigger("data", i); if (t = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(e)) return i = { type: "tag", tagType: "cue-out-cont" }, t[1] ? i.data = t[1] : i.data = "", void n.trigger("data", i); if (t = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(e)) return i = { type: "tag", tagType: "cue-out" }, t[1] ? i.data = t[1] : i.data = "", void n.trigger("data", i); if (t = /^#EXT-X-CUE-IN:?(.*)?$/.exec(e)) return i = { type: "tag", tagType: "cue-in" }, t[1] ? i.data = t[1] : i.data = "", void n.trigger("data", i); if ((t = /^#EXT-X-SKIP:(.*)$/.exec(e)) && t[1]) return (i = { type: "tag", tagType: "skip" }).attributes = T(t[1]), i.attributes.hasOwnProperty("SKIPPED-SEGMENTS") && (i.attributes["SKIPPED-SEGMENTS"] = parseInt(i.attributes["SKIPPED-SEGMENTS"], 10)), i.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES") && (i.attributes["RECENTLY-REMOVED-DATERANGES"] = i.attributes["RECENTLY-REMOVED-DATERANGES"].split(v)), void n.trigger("data", i); if ((t = /^#EXT-X-PART:(.*)$/.exec(e)) && t[1]) return (i = { type: "tag", tagType: "part" }).attributes = T(t[1]), ["DURATION"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = parseFloat(i.attributes[e])) })), ["INDEPENDENT", "GAP"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = /YES/.test(i.attributes[e])) })), i.attributes.hasOwnProperty("BYTERANGE") && (i.attributes.byterange = b(i.attributes.BYTERANGE)), void n.trigger("data", i); if ((t = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(e)) && t[1]) return (i = { type: "tag", tagType: "server-control" }).attributes = T(t[1]), ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = parseFloat(i.attributes[e])) })), ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = /YES/.test(i.attributes[e])) })), void n.trigger("data", i); if ((t = /^#EXT-X-PART-INF:(.*)$/.exec(e)) && t[1]) return (i = { type: "tag", tagType: "part-inf" }).attributes = T(t[1]), ["PART-TARGET"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = parseFloat(i.attributes[e])) })), void n.trigger("data", i); if ((t = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(e)) && t[1]) return (i = { type: "tag", tagType: "preload-hint" }).attributes = T(t[1]), ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach((function (e) { if (i.attributes.hasOwnProperty(e)) { i.attributes[e] = parseInt(i.attributes[e], 10); var t = "BYTERANGE-LENGTH" === e ? "length" : "offset"; i.attributes.byterange = i.attributes.byterange || {}, i.attributes.byterange[t] = i.attributes[e], delete i.attributes[e] } })), void n.trigger("data", i); if ((t = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(e)) && t[1]) return (i = { type: "tag", tagType: "rendition-report" }).attributes = T(t[1]), ["LAST-MSN", "LAST-PART"].forEach((function (e) { i.attributes.hasOwnProperty(e) && (i.attributes[e] = parseInt(i.attributes[e], 10)) })), void n.trigger("data", i); n.trigger("data", { type: "tag", data: e.slice(4) }) } } } else n.trigger("data", { type: "comment", text: e.slice(1) }) })) : this.trigger("data", { type: "uri", uri: e })) }, i.addParser = function (e) { var t = this, i = e.expression, n = e.customType, r = e.dataParser, a = e.segment; "function" != typeof r && (r = function (e) { return e }), this.customParsers.push((function (e) { if (i.exec(e)) return t.trigger("data", { type: "custom", data: r(e), customType: n, segment: a }), !0 })) }, i.addTagMapper = function (e) { var t = e.expression, i = e.map; this.tagMappers.push((function (e) { return t.test(e) ? i(e) : e })) }, t }(p), w = function (e) { var t = {}; return Object.keys(e).forEach((function (i) { var n; t[(n = i, n.toLowerCase().replace(/-(\w)/g, (function (e) { return e[1].toUpperCase() })))] = e[i] })), t }, I = function (e) { var t = e.serverControl, i = e.targetDuration, n = e.partTargetDuration; if (t) { var r = "#EXT-X-SERVER-CONTROL", a = "holdBack", s = "partHoldBack", o = i && 3 * i, u = n && 2 * n; i && !t.hasOwnProperty(a) && (t[a] = o, this.trigger("info", { message: r + " defaulting HOLD-BACK to targetDuration * 3 (" + o + ")." })), o && t[a] < o && (this.trigger("warn", { message: r + " clamping HOLD-BACK (" + t[a] + ") to targetDuration * 3 (" + o + ")" }), t[a] = o), n && !t.hasOwnProperty(s) && (t[s] = 3 * n, this.trigger("info", { message: r + " defaulting PART-HOLD-BACK to partTargetDuration * 3 (" + t[s] + ")." })), n && t[s] < u && (this.trigger("warn", { message: r + " clamping PART-HOLD-BACK (" + t[s] + ") to partTargetDuration * 2 (" + u + ")." }), t[s] = u) } }, E = function (e) { function t() { var t; (t = e.call(this) || this).lineStream = new _, t.parseStream = new S, t.lineStream.pipe(t.parseStream); var i, n, r = a(t), s = [], o = {}, u = !1, d = function () { }, l = { AUDIO: {}, VIDEO: {}, "CLOSED-CAPTIONS": {}, SUBTITLES: {} }, h = 0; t.manifest = { allowCache: !0, discontinuityStarts: [], segments: [] }; var c = 0, p = 0; return t.on("end", (function () { o.uri || !o.parts && !o.preloadHints || (!o.map && i && (o.map = i), !o.key && n && (o.key = n), o.timeline || "number" != typeof h || (o.timeline = h), t.manifest.preloadSegment = o) })), t.parseStream.on("data", (function (e) { var t, a; ({ tag: function () { ({ version: function () { e.version && (this.manifest.version = e.version) }, "allow-cache": function () { this.manifest.allowCache = e.allowed, "allowed" in e || (this.trigger("info", { message: "defaulting allowCache to YES" }), this.manifest.allowCache = !0) }, byterange: function () { var t = {}; "length" in e && (o.byterange = t, t.length = e.length, "offset" in e || (e.offset = c)), "offset" in e && (o.byterange = t, t.offset = e.offset), c = t.offset + t.length }, endlist: function () { this.manifest.endList = !0 }, inf: function () { "mediaSequence" in this.manifest || (this.manifest.mediaSequence = 0, this.trigger("info", { message: "defaulting media sequence to zero" })), "discontinuitySequence" in this.manifest || (this.manifest.discontinuitySequence = 0, this.trigger("info", { message: "defaulting discontinuity sequence to zero" })), e.duration > 0 && (o.duration = e.duration), 0 === e.duration && (o.duration = .01, this.trigger("info", { message: "updating zero segment duration to a small value" })), this.manifest.segments = s }, key: function () { if (e.attributes) if ("NONE" !== e.attributes.METHOD) if (e.attributes.URI) { if ("com.apple.streamingkeydelivery" === e.attributes.KEYFORMAT) return this.manifest.contentProtection = this.manifest.contentProtection || {}, void (this.manifest.contentProtection["com.apple.fps.1_0"] = { attributes: e.attributes }); if ("com.microsoft.playready" === e.attributes.KEYFORMAT) return this.manifest.contentProtection = this.manifest.contentProtection || {}, void (this.manifest.contentProtection["com.microsoft.playready"] = { uri: e.attributes.URI }); if ("urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed" === e.attributes.KEYFORMAT) return -1 === ["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"].indexOf(e.attributes.METHOD) ? void this.trigger("warn", { message: "invalid key method provided for Widevine" }) : ("SAMPLE-AES-CENC" === e.attributes.METHOD && this.trigger("warn", { message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead" }), "data:text/plain;base64," !== e.attributes.URI.substring(0, 23) ? void this.trigger("warn", { message: "invalid key URI provided for Widevine" }) : e.attributes.KEYID && "0x" === e.attributes.KEYID.substring(0, 2) ? (this.manifest.contentProtection = this.manifest.contentProtection || {}, void (this.manifest.contentProtection["com.widevine.alpha"] = { attributes: { schemeIdUri: e.attributes.KEYFORMAT, keyId: e.attributes.KEYID.substring(2) }, pssh: m(e.attributes.URI.split(",")[1]) })) : void this.trigger("warn", { message: "invalid key ID provided for Widevine" })); e.attributes.METHOD || this.trigger("warn", { message: "defaulting key method to AES-128" }), n = { method: e.attributes.METHOD || "AES-128", uri: e.attributes.URI }, void 0 !== e.attributes.IV && (n.iv = e.attributes.IV) } else this.trigger("warn", { message: "ignoring key declaration without URI" }); else n = null; else this.trigger("warn", { message: "ignoring key declaration without attribute list" }) }, "media-sequence": function () { isFinite(e.number) ? this.manifest.mediaSequence = e.number : this.trigger("warn", { message: "ignoring invalid media sequence: " + e.number }) }, "discontinuity-sequence": function () { isFinite(e.number) ? (this.manifest.discontinuitySequence = e.number, h = e.number) : this.trigger("warn", { message: "ignoring invalid discontinuity sequence: " + e.number }) }, "playlist-type": function () { /VOD|EVENT/.test(e.playlistType) ? this.manifest.playlistType = e.playlistType : this.trigger("warn", { message: "ignoring unknown playlist type: " + e.playlist }) }, map: function () { i = {}, e.uri && (i.uri = e.uri), e.byterange && (i.byterange = e.byterange), n && (i.key = n) }, "stream-inf": function () { this.manifest.playlists = s, this.manifest.mediaGroups = this.manifest.mediaGroups || l, e.attributes ? (o.attributes || (o.attributes = {}), f(o.attributes, e.attributes)) : this.trigger("warn", { message: "ignoring empty stream-inf attributes" }) }, media: function () { if (this.manifest.mediaGroups = this.manifest.mediaGroups || l, e.attributes && e.attributes.TYPE && e.attributes["GROUP-ID"] && e.attributes.NAME) { var i = this.manifest.mediaGroups[e.attributes.TYPE]; i[e.attributes["GROUP-ID"]] = i[e.attributes["GROUP-ID"]] || {}, t = i[e.attributes["GROUP-ID"]], (a = { default: /yes/i.test(e.attributes.DEFAULT) }).default ? a.autoselect = !0 : a.autoselect = /yes/i.test(e.attributes.AUTOSELECT), e.attributes.LANGUAGE && (a.language = e.attributes.LANGUAGE), e.attributes.URI && (a.uri = e.attributes.URI), e.attributes["INSTREAM-ID"] && (a.instreamId = e.attributes["INSTREAM-ID"]), e.attributes.CHARACTERISTICS && (a.characteristics = e.attributes.CHARACTERISTICS), e.attributes.FORCED && (a.forced = /yes/i.test(e.attributes.FORCED)), t[e.attributes.NAME] = a } else this.trigger("warn", { message: "ignoring incomplete or missing media group" }) }, discontinuity: function () { h += 1, o.discontinuity = !0, this.manifest.discontinuityStarts.push(s.length) }, "program-date-time": function () { void 0 === this.manifest.dateTimeString && (this.manifest.dateTimeString = e.dateTimeString, this.manifest.dateTimeObject = e.dateTimeObject), o.dateTimeString = e.dateTimeString, o.dateTimeObject = e.dateTimeObject }, targetduration: function () { !isFinite(e.duration) || e.duration < 0 ? this.trigger("warn", { message: "ignoring invalid target duration: " + e.duration }) : (this.manifest.targetDuration = e.duration, I.call(this, this.manifest)) }, start: function () { e.attributes && !isNaN(e.attributes["TIME-OFFSET"]) ? this.manifest.start = { timeOffset: e.attributes["TIME-OFFSET"], precise: e.attributes.PRECISE } : this.trigger("warn", { message: "ignoring start declaration without appropriate attribute list" }) }, "cue-out": function () { o.cueOut = e.data }, "cue-out-cont": function () { o.cueOutCont = e.data }, "cue-in": function () { o.cueIn = e.data }, skip: function () { this.manifest.skip = w(e.attributes), this.warnOnMissingAttributes_("#EXT-X-SKIP", e.attributes, ["SKIPPED-SEGMENTS"]) }, part: function () { var t = this; u = !0; var i = this.manifest.segments.length, n = w(e.attributes); o.parts = o.parts || [], o.parts.push(n), n.byterange && (n.byterange.hasOwnProperty("offset") || (n.byterange.offset = p), p = n.byterange.offset + n.byterange.length); var r = o.parts.length - 1; this.warnOnMissingAttributes_("#EXT-X-PART #" + r + " for segment #" + i, e.attributes, ["URI", "DURATION"]), this.manifest.renditionReports && this.manifest.renditionReports.forEach((function (e, i) { e.hasOwnProperty("lastPart") || t.trigger("warn", { message: "#EXT-X-RENDITION-REPORT #" + i + " lacks required attribute(s): LAST-PART" }) })) }, "server-control": function () { var t = this.manifest.serverControl = w(e.attributes); t.hasOwnProperty("canBlockReload") || (t.canBlockReload = !1, this.trigger("info", { message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false" })), I.call(this, this.manifest), t.canSkipDateranges && !t.hasOwnProperty("canSkipUntil") && this.trigger("warn", { message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set" }) }, "preload-hint": function () { var t = this.manifest.segments.length, i = w(e.attributes), n = i.type && "PART" === i.type; o.preloadHints = o.preloadHints || [], o.preloadHints.push(i), i.byterange && (i.byterange.hasOwnProperty("offset") || (i.byterange.offset = n ? p : 0, n && (p = i.byterange.offset + i.byterange.length))); var r = o.preloadHints.length - 1; if (this.warnOnMissingAttributes_("#EXT-X-PRELOAD-HINT #" + r + " for segment #" + t, e.attributes, ["TYPE", "URI"]), i.type) for (var a = 0; a < o.preloadHints.length - 1; a++) { var s = o.preloadHints[a]; s.type && s.type === i.type && this.trigger("warn", { message: "#EXT-X-PRELOAD-HINT #" + r + " for segment #" + t + " has the same TYPE " + i.type + " as preload hint #" + a }) } }, "rendition-report": function () { var t = w(e.attributes); this.manifest.renditionReports = this.manifest.renditionReports || [], this.manifest.renditionReports.push(t); var i = this.manifest.renditionReports.length - 1, n = ["LAST-MSN", "URI"]; u && n.push("LAST-PART"), this.warnOnMissingAttributes_("#EXT-X-RENDITION-REPORT #" + i, e.attributes, n) }, "part-inf": function () { this.manifest.partInf = w(e.attributes), this.warnOnMissingAttributes_("#EXT-X-PART-INF", e.attributes, ["PART-TARGET"]), this.manifest.partInf.partTarget && (this.manifest.partTargetDuration = this.manifest.partInf.partTarget), I.call(this, this.manifest) } }[e.tagType] || d).call(r) }, uri: function () { o.uri = e.uri, s.push(o), this.manifest.targetDuration && !("duration" in o) && (this.trigger("warn", { message: "defaulting segment duration to the target duration" }), o.duration = this.manifest.targetDuration), n && (o.key = n), o.timeline = h, i && (o.map = i), p = 0, o = {} }, comment: function () { }, custom: function () { e.segment ? (o.custom = o.custom || {}, o.custom[e.customType] = e.data) : (this.manifest.custom = this.manifest.custom || {}, this.manifest.custom[e.customType] = e.data) } })[e.type].call(r) })), t } o(t, e); var i = t.prototype; return i.warnOnMissingAttributes_ = function (e, t, i) { var n = []; i.forEach((function (e) { t.hasOwnProperty(e) || n.push(e) })), n.length && this.trigger("warn", { message: e + " lacks required attribute(s): " + n.join(", ") }) }, i.push = function (e) { this.lineStream.push(e) }, i.end = function () { this.lineStream.push("\n"), this.trigger("end") }, i.addParser = function (e) { this.parseStream.addParser(e) }, i.addTagMapper = function (e) { this.parseStream.addTagMapper(e) }, t }(p), A = { mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/, webm: /^(vp0?[89]|av0?1|opus|vorbis)/, ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/, video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/, audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/, text: /^(stpp.ttml.im1t)/, muxerVideo: /^(avc0?1)/, muxerAudio: /^(mp4a)/, muxerText: /a^/ }, L = ["video", "audio", "text"], k = ["Video", "Audio", "Text"], x = function (e) { return e ? e.replace(/avc1\.(\d+)\.(\d+)/i, (function (e, t, i) { return "avc1." + ("00" + Number(t).toString(16)).slice(-2) + "00" + ("00" + Number(i).toString(16)).slice(-2) })) : e }, P = function (e) { void 0 === e && (e = ""); var t = e.split(","), i = []; return t.forEach((function (e) { var t; e = e.trim(), L.forEach((function (n) { var r = A[n].exec(e.toLowerCase()); if (r && !(r.length <= 1)) { t = n; var a = e.substring(0, r[1].length), s = e.replace(a, ""); i.push({ type: a, details: s, mediaType: n }) } })), t || i.push({ type: e, details: "", mediaType: "unknown" }) })), i }, O = function (e) { return void 0 === e && (e = ""), A.audio.test(e.trim().toLowerCase()) }, D = function (e) { if (e && "string" == typeof e) { var t, i = e.toLowerCase().split(",").map((function (e) { return x(e.trim()) })), n = "video"; 1 === i.length && O(i[0]) ? n = "audio" : 1 === i.length && (void 0 === (t = i[0]) && (t = ""), A.text.test(t.trim().toLowerCase())) && (n = "application"); var r = "mp4"; return i.every((function (e) { return A.mp4.test(e) })) ? r = "mp4" : i.every((function (e) { return A.webm.test(e) })) ? r = "webm" : i.every((function (e) { return A.ogg.test(e) })) && (r = "ogg"), n + "/" + r + ';codecs="' + e + '"' } }, C = function (e) { return void 0 === e && (e = ""), window.MediaSource && window.MediaSource.isTypeSupported && window.MediaSource.isTypeSupported(D(e)) || !1 }, R = function (e) { return void 0 === e && (e = ""), e.toLowerCase().split(",").every((function (e) { e = e.trim(); for (var t = 0; t < k.length; t++)if (A["muxer" + k[t]].test(e)) return !0; return !1 })) }, U = "mp4a.40.2", M = 1 / 30, B = .1, F = function (e, t) { var i, r = []; if (e && e.length) for (i = 0; i < e.length; i++)t(e.start(i), e.end(i)) && r.push([e.start(i), e.end(i)]); return n.default.createTimeRanges(r) }, N = function (e, t) { return F(e, (function (e, i) { return e - B <= t && i + B >= t })) }, q = function (e, t) { return F(e, (function (e) { return e - M >= t })) }, W = function (e) { var t = []; if (!e || !e.length) return ""; for (var i = 0; i < e.length; i++)t.push(e.start(i) + " => " + e.end(i)); return t.join(", ") }, H = function (e) { for (var t = [], i = 0; i < e.length; i++)t.push({ start: e.start(i), end: e.end(i) }); return t }, G = function (e) { if (e && e.length && e.end) return e.end(e.length - 1) }, V = function (e, t) { var i = 0; if (!e || !e.length) return i; for (var n = 0; n < e.length; n++) { var r = e.start(n), a = e.end(n); t > a || (i += t > r && t <= a ? a - t : a - r) } return i }, j = n.default.createTimeRange, X = function (e, t) { if (!t.preload) return t.duration; var i = 0; return (t.parts || []).forEach((function (e) { i += e.duration })), (t.preloadHints || []).forEach((function (t) { "PART" === t.type && (i += e.partTargetDuration) })), i }, Q = function (e) { return (e.segments || []).reduce((function (e, t, i) { return t.parts ? t.parts.forEach((function (n, r) { e.push({ duration: n.duration, segmentIndex: i, partIndex: r, part: n, segment: t }) })) : e.push({ duration: t.duration, segmentIndex: i, partIndex: null, segment: t, part: null }), e }), []) }, z = function (e) { var t = e.segments && e.segments.length && e.segments[e.segments.length - 1]; return t && t.parts || [] }, Y = function (e) { var t = e.preloadSegment; if (t) { var i = t.parts; return (t.preloadHints || []).reduce((function (e, t) { return e + ("PART" === t.type ? 1 : 0) }), 0) + (i && i.length ? i.length : 0) } }, K = function (e, t) { if (t.endList) return 0; if (e && e.suggestedPresentationDelay) return e.suggestedPresentationDelay; var i = z(t).length > 0; return i && t.serverControl && t.serverControl.partHoldBack ? t.serverControl.partHoldBack : i && t.partTargetDuration ? 3 * t.partTargetDuration : t.serverControl && t.serverControl.holdBack ? t.serverControl.holdBack : t.targetDuration ? 3 * t.targetDuration : 0 }, $ = function (e, t, i) { if (void 0 === t && (t = e.mediaSequence + e.segments.length), t < e.mediaSequence) return 0; var n = function (e, t) { var i = 0, n = t - e.mediaSequence, r = e.segments[n]; if (r) { if (void 0 !== r.start) return { result: r.start, precise: !0 }; if (void 0 !== r.end) return { result: r.end - r.duration, precise: !0 } } for (; n--;) { if (void 0 !== (r = e.segments[n]).end) return { result: i + r.end, precise: !0 }; if (i += X(e, r), void 0 !== r.start) return { result: i + r.start, precise: !0 } } return { result: i, precise: !1 } }(e, t); if (n.precise) return n.result; var r = function (e, t) { for (var i, n = 0, r = t - e.mediaSequence; r < e.segments.length; r++) { if (void 0 !== (i = e.segments[r]).start) return { result: i.start - n, precise: !0 }; if (n += X(e, i), void 0 !== i.end) return { result: i.end - n, precise: !0 } } return { result: -1, precise: !1 } }(e, t); return r.precise ? r.result : n.result + i }, J = function (e, t, i) { if (!e) return 0; if ("number" != typeof i && (i = 0), void 0 === t) { if (e.totalDuration) return e.totalDuration; if (!e.endList) return window.Infinity } return $(e, t, i) }, Z = function (e) { var t = e.defaultDuration, i = e.durationList, n = e.startIndex, r = e.endIndex, a = 0; if (n > r) { var s = [r, n]; n = s[0], r = s[1] } if (n < 0) { for (var o = n; o < Math.min(0, r); o++)a += t; n = 0 } for (var u = n; u < r; u++)a += i[u].duration; return a }, ee = function (e, t, i, n) { if (!e || !e.segments) return null; if (e.endList) return J(e); if (null === t) return null; t = t || 0; var r = $(e, e.mediaSequence + e.segments.length, t); return i && (r -= n = "number" == typeof n ? n : K(null, e)), Math.max(0, r) }, te = function (e) { return e.excludeUntil && e.excludeUntil > Date.now() }, ie = function (e) { return e.excludeUntil && e.excludeUntil === 1 / 0 }, ne = function (e) { var t = te(e); return !e.disabled && !t }, re = function (e, t) { return t.attributes && t.attributes[e] }, ae = function (e, t) { if (1 === e.playlists.length) return !0; var i = t.attributes.BANDWIDTH || Number.MAX_VALUE; return 0 === e.playlists.filter((function (e) { return !!ne(e) && (e.attributes.BANDWIDTH || 0) < i })).length }, se = function (e, t) { return !(!e && !t || !e && t || e && !t || e !== t && (!e.id || !t.id || e.id !== t.id) && (!e.resolvedUri || !t.resolvedUri || e.resolvedUri !== t.resolvedUri) && (!e.uri || !t.uri || e.uri !== t.uri)) }, oe = function (e, t) { var i = e && e.mediaGroups && e.mediaGroups.AUDIO || {}, n = !1; for (var r in i) { for (var a in i[r]) if (n = t(i[r][a])) break; if (n) break } return !!n }, ue = function (e) { if (!e || !e.playlists || !e.playlists.length) return oe(e, (function (e) { return e.playlists && e.playlists.length || e.uri })); for (var t = function (t) { var i = e.playlists[t], n = i.attributes && i.attributes.CODECS; return n && n.split(",").every((function (e) { return O(e) })) || oe(e, (function (e) { return se(i, e) })) ? "continue" : { v: !1 } }, i = 0; i < e.playlists.length; i++) { var n = t(i); if ("continue" !== n && "object" == typeof n) return n.v } return !0 }, de = { liveEdgeDelay: K, duration: J, seekable: function (e, t, i) { var n = t || 0, r = ee(e, t, !0, i); return null === r ? j() : j(n, r) }, getMediaInfoForTime: function (e) { for (var t = e.playlist, i = e.currentTime, n = e.startingSegmentIndex, r = e.startingPartIndex, a = e.startTime, s = e.experimentalExactManifestTimings, o = i - a, u = Q(t), d = 0, l = 0; l < u.length; l++) { var h = u[l]; if (n === h.segmentIndex && ("number" != typeof r || "number" != typeof h.partIndex || r === h.partIndex)) { d = l; break } } if (o < 0) { if (d > 0) for (var c = d - 1; c >= 0; c--) { var f = u[c]; if (o += f.duration, s) { if (o < 0) continue } else if (o + M <= 0) continue; return { partIndex: f.partIndex, segmentIndex: f.segmentIndex, startTime: a - Z({ defaultDuration: t.targetDuration, durationList: u, startIndex: d, endIndex: c }) } } return { partIndex: u[0] && u[0].partIndex || null, segmentIndex: u[0] && u[0].segmentIndex || 0, startTime: i } } if (d < 0) { for (var p = d; p < 0; p++)if ((o -= t.targetDuration) < 0) return { partIndex: u[0] && u[0].partIndex || null, segmentIndex: u[0] && u[0].segmentIndex || 0, startTime: i }; d = 0 } for (var m = d; m < u.length; m++) { var g = u[m]; if (o -= g.duration, s) { if (o > 0) continue } else if (o - M >= 0) continue; return { partIndex: g.partIndex, segmentIndex: g.segmentIndex, startTime: a + Z({ defaultDuration: t.targetDuration, durationList: u, startIndex: d, endIndex: m }) } } return { segmentIndex: u[u.length - 1].segmentIndex, partIndex: u[u.length - 1].partIndex, startTime: i } }, isEnabled: ne, isDisabled: function (e) { return e.disabled }, isBlacklisted: te, isIncompatible: ie, playlistEnd: ee, isAes: function (e) { for (var t = 0; t < e.segments.length; t++)if (e.segments[t].key) return !0; return !1 }, hasAttribute: re, estimateSegmentRequestTime: function (e, t, i, n) { return void 0 === n && (n = 0), re("BANDWIDTH", i) ? (e * i.attributes.BANDWIDTH - 8 * n) / t : NaN }, isLowestEnabledRendition: ae, isAudioOnly: ue, playlistMatch: se, segmentDurationWithParts: X }, le = n.default.log, he = function (e, t) { return e + "-" + t }, ce = function (e, t) { e.mediaGroups && ["AUDIO"].forEach((function (i) { if (e.mediaGroups[i]) for (var n in e.mediaGroups[i]) for (var r in e.mediaGroups[i][n]) { var a = e.mediaGroups[i][n][r]; t(a, i, n, r) } })) }, fe = function (e) { var t = e.playlist, i = e.uri, n = e.id; t.id = n, t.playlistErrors_ = 0, i && (t.uri = i), t.attributes = t.attributes || {} }, pe = n.default.mergeOptions, me = n.default.EventTarget, ge = function (e, t) { if (!e) return t; var i = pe(e, t); if (e.preloadHints && !t.preloadHints && delete i.preloadHints, e.parts && !t.parts) delete i.parts; else if (e.parts && t.parts) for (var n = 0; n < t.parts.length; n++)e.parts && e.parts[n] && (i.parts[n] = pe(e.parts[n], t.parts[n])); return !e.skipped && t.skipped && (i.skipped = !1), e.preload && !t.preload && (i.preload = !1), i }, ye = function (e, t) { !e.resolvedUri && e.uri && (e.resolvedUri = l(t, e.uri)), e.key && !e.key.resolvedUri && (e.key.resolvedUri = l(t, e.key.uri)), e.map && !e.map.resolvedUri && (e.map.resolvedUri = l(t, e.map.uri)), e.map && e.map.key && !e.map.key.resolvedUri && (e.map.key.resolvedUri = l(t, e.map.key.uri)), e.parts && e.parts.length && e.parts.forEach((function (e) { e.resolvedUri || (e.resolvedUri = l(t, e.uri)) })), e.preloadHints && e.preloadHints.length && e.preloadHints.forEach((function (e) { e.resolvedUri || (e.resolvedUri = l(t, e.uri)) })) }, _e = function (e) { var t = e.segments || [], i = e.preloadSegment; if (i && i.parts && i.parts.length) { if (i.preloadHints) for (var n = 0; n < i.preloadHints.length; n++)if ("MAP" === i.preloadHints[n].type) return t; i.duration = e.targetDuration, i.preload = !0, t.push(i) } return t }, ve = function (e, t) { return e === t || e.segments && t.segments && e.segments.length === t.segments.length && e.endList === t.endList && e.mediaSequence === t.mediaSequence && e.preloadSegment === t.preloadSegment }, be = function (e, t) { var i = e.segments || [], n = i[i.length - 1], r = n && n.parts && n.parts[n.parts.length - 1], a = r && r.duration || n && n.duration; return t && a ? 1e3 * a : 500 * (e.partTargetDuration || e.targetDuration || 10) }, Te = function (e) { function t(t, i, r) { var s; if (void 0 === r && (r = {}), s = e.call(this) || this, !t) throw new Error("A non-empty playlist URL or object is required"); s.logger_ = c("PlaylistLoader"); var o = r, u = o.withCredentials, d = void 0 !== u && u, l = o.handleManifestRedirects, h = void 0 !== l && l; s.src = t, s.vhs_ = i, s.withCredentials = d, s.handleManifestRedirects = h; var f = i.options_; return s.customTagParsers = f && f.customTagParsers || [], s.customTagMappers = f && f.customTagMappers || [], s.experimentalLLHLS = f && f.experimentalLLHLS || !1, n.default.browser.IE_VERSION && (s.experimentalLLHLS = !1), s.state = "HAVE_NOTHING", s.handleMediaupdatetimeout_ = s.handleMediaupdatetimeout_.bind(a(s)), s.on("mediaupdatetimeout", s.handleMediaupdatetimeout_), s } o(t, e); var i = t.prototype; return i.handleMediaupdatetimeout_ = function () { var e = this; if ("HAVE_METADATA" === this.state) { var t = this.media(), i = l(this.master.uri, t.uri); this.experimentalLLHLS && (i = function (e, t) { if (t.endList || !t.serverControl) return e; var i = {}; if (t.serverControl.canBlockReload) { var n = t.preloadSegment, r = t.mediaSequence + t.segments.length; if (n) { var a = n.parts || [], s = Y(t) - 1; s > -1 && s !== a.length - 1 && (i._HLS_part = s), (s > -1 || a.length) && r-- } i._HLS_msn = r } if (t.serverControl && t.serverControl.canSkipUntil && (i._HLS_skip = t.serverControl.canSkipDateranges ? "v2" : "YES"), Object.keys(i).length) { var o = new window.URL(e);["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach((function (e) { i.hasOwnProperty(e) && o.searchParams.set(e, i[e]) })), e = o.toString() } return e }(i, t)), this.state = "HAVE_CURRENT_METADATA", this.request = this.vhs_.xhr({ uri: i, withCredentials: this.withCredentials }, (function (t, i) { if (e.request) return t ? e.playlistRequestError(e.request, e.media(), "HAVE_METADATA") : void e.haveMetadata({ playlistString: e.request.responseText, url: e.media().uri, id: e.media().id }) })) } }, i.playlistRequestError = function (e, t, i) { var n = t.uri, r = t.id; this.request = null, i && (this.state = i), this.error = { playlist: this.master.playlists[r], status: e.status, message: "HLS playlist request error at URL: " + n + ".", responseText: e.responseText, code: e.status >= 500 ? 4 : 2 }, this.trigger("error") }, i.parseManifest_ = function (e) { var t = this, i = e.url; return function (e) { var t = e.onwarn, i = e.oninfo, n = e.manifestString, r = e.customTagParsers, a = void 0 === r ? [] : r, s = e.customTagMappers, o = void 0 === s ? [] : s, u = e.experimentalLLHLS, d = new E; t && d.on("warn", t), i && d.on("info", i), a.forEach((function (e) { return d.addParser(e) })), o.forEach((function (e) { return d.addTagMapper(e) })), d.push(n), d.end(); var l = d.manifest; if (u || (["preloadSegment", "skip", "serverControl", "renditionReports", "partInf", "partTargetDuration"].forEach((function (e) { l.hasOwnProperty(e) && delete l[e] })), l.segments && l.segments.forEach((function (e) { ["parts", "preloadHints"].forEach((function (t) { e.hasOwnProperty(t) && delete e[t] })) }))), !l.targetDuration) { var h = 10; l.segments && l.segments.length && (h = l.segments.reduce((function (e, t) { return Math.max(e, t.duration) }), 0)), t && t("manifest has no targetDuration defaulting to " + h), l.targetDuration = h } var c = z(l); if (c.length && !l.partTargetDuration) { var f = c.reduce((function (e, t) { return Math.max(e, t.duration) }), 0); t && (t("manifest has no partTargetDuration defaulting to " + f), le.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.")), l.partTargetDuration = f } return l }({ onwarn: function (e) { var n = e.message; return t.logger_("m3u8-parser warn for " + i + ": " + n) }, oninfo: function (e) { var n = e.message; return t.logger_("m3u8-parser info for " + i + ": " + n) }, manifestString: e.manifestString, customTagParsers: this.customTagParsers, customTagMappers: this.customTagMappers, experimentalLLHLS: this.experimentalLLHLS }) }, i.haveMetadata = function (e) { var t = e.playlistString, i = e.playlistObject, n = e.url, r = e.id; this.request = null, this.state = "HAVE_METADATA"; var a = i || this.parseManifest_({ url: n, manifestString: t }); a.lastRequest = Date.now(), fe({ playlist: a, uri: n, id: r }); var s = function (e, t, i) { void 0 === i && (i = ve); var n = pe(e, {}), r = n.playlists[t.id]; if (!r) return null; if (i(r, t)) return null; t.segments = _e(t); var a = pe(r, t); if (a.preloadSegment && !t.preloadSegment && delete a.preloadSegment, r.segments) { if (t.skip) { t.segments = t.segments || []; for (var s = 0; s < t.skip.skippedSegments; s++)t.segments.unshift({ skipped: !0 }) } a.segments = function (e, t, i) { var n = e.slice(), r = t.slice(); i = i || 0; for (var a, s = [], o = 0; o < r.length; o++) { var u = n[o + i], d = r[o]; u ? (a = u.map || a, s.push(ge(u, d))) : (a && !d.map && (d.map = a), s.push(d)) } return s }(r.segments, t.segments, t.mediaSequence - r.mediaSequence) } a.segments.forEach((function (e) { ye(e, a.resolvedUri) })); for (var o = 0; o < n.playlists.length; o++)n.playlists[o].id === t.id && (n.playlists[o] = a); return n.playlists[t.id] = a, n.playlists[t.uri] = a, ce(e, (function (e, i, n, r) { if (e.playlists) for (var s = 0; s < e.playlists.length; s++)t.id === e.playlists[s].id && (e.playlists[s] = a) })), n }(this.master, a); this.targetDuration = a.partTargetDuration || a.targetDuration, this.pendingMedia_ = null, s ? (this.master = s, this.media_ = this.master.playlists[r]) : this.trigger("playlistunchanged"), this.updateMediaUpdateTimeout_(be(this.media(), !!s)), this.trigger("loadedplaylist") }, i.dispose = function () { this.trigger("dispose"), this.stopRequest(), window.clearTimeout(this.mediaUpdateTimeout), window.clearTimeout(this.finalRenditionTimeout), this.off() }, i.stopRequest = function () { if (this.request) { var e = this.request; this.request = null, e.onreadystatechange = null, e.abort() } }, i.media = function (e, t) { var i = this; if (!e) return this.media_; if ("HAVE_NOTHING" === this.state) throw new Error("Cannot switch media playlist from " + this.state); if ("string" == typeof e) { if (!this.master.playlists[e]) throw new Error("Unknown playlist URI: " + e); e = this.master.playlists[e] } if (window.clearTimeout(this.finalRenditionTimeout), t) { var n = (e.partTargetDuration || e.targetDuration) / 2 * 1e3 || 5e3; this.finalRenditionTimeout = window.setTimeout(this.media.bind(this, e, !1), n) } else { var r = this.state, a = !this.media_ || e.id !== this.media_.id, s = this.master.playlists[e.id]; if (s && s.endList || e.endList && e.segments.length) return this.request && (this.request.onreadystatechange = null, this.request.abort(), this.request = null), this.state = "HAVE_METADATA", this.media_ = e, void (a && (this.trigger("mediachanging"), "HAVE_MASTER" === r ? this.trigger("loadedmetadata") : this.trigger("mediachange"))); if (this.updateMediaUpdateTimeout_(be(e, !0)), a) { if (this.state = "SWITCHING_MEDIA", this.request) { if (e.resolvedUri === this.request.url) return; this.request.onreadystatechange = null, this.request.abort(), this.request = null } this.media_ && this.trigger("mediachanging"), this.pendingMedia_ = e, this.request = this.vhs_.xhr({ uri: e.resolvedUri, withCredentials: this.withCredentials }, (function (t, n) { if (i.request) { if (e.lastRequest = Date.now(), e.resolvedUri = h(i.handleManifestRedirects, e.resolvedUri, n), t) return i.playlistRequestError(i.request, e, r); i.haveMetadata({ playlistString: n.responseText, url: e.uri, id: e.id }), "HAVE_MASTER" === r ? i.trigger("loadedmetadata") : i.trigger("mediachange") } })) } } }, i.pause = function () { this.mediaUpdateTimeout && (window.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), this.stopRequest(), "HAVE_NOTHING" === this.state && (this.started = !1), "SWITCHING_MEDIA" === this.state ? this.media_ ? this.state = "HAVE_METADATA" : this.state = "HAVE_MASTER" : "HAVE_CURRENT_METADATA" === this.state && (this.state = "HAVE_METADATA") }, i.load = function (e) { var t = this; this.mediaUpdateTimeout && (window.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null); var i = this.media(); if (e) { var n = i ? (i.partTargetDuration || i.targetDuration) / 2 * 1e3 : 5e3; this.mediaUpdateTimeout = window.setTimeout((function () { t.mediaUpdateTimeout = null, t.load() }), n) } else this.started ? i && !i.endList ? this.trigger("mediaupdatetimeout") : this.trigger("loadedplaylist") : this.start() }, i.updateMediaUpdateTimeout_ = function (e) { var t = this; this.mediaUpdateTimeout && (window.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), this.media() && !this.media().endList && (this.mediaUpdateTimeout = window.setTimeout((function () { t.mediaUpdateTimeout = null, t.trigger("mediaupdatetimeout"), t.updateMediaUpdateTimeout_(e) }), e)) }, i.start = function () { var e = this; if (this.started = !0, "object" == typeof this.src) return this.src.uri || (this.src.uri = window.location.href), this.src.resolvedUri = this.src.uri, void setTimeout((function () { e.setupInitialPlaylist(e.src) }), 0); this.request = this.vhs_.xhr({ uri: this.src, withCredentials: this.withCredentials }, (function (t, i) { if (e.request) { if (e.request = null, t) return e.error = { status: i.status, message: "HLS playlist request error at URL: " + e.src + ".", responseText: i.responseText, code: 2 }, "HAVE_NOTHING" === e.state && (e.started = !1), e.trigger("error"); e.src = h(e.handleManifestRedirects, e.src, i); var n = e.parseManifest_({ manifestString: i.responseText, url: e.src }); e.setupInitialPlaylist(n) } })) }, i.srcUri = function () { return "string" == typeof this.src ? this.src : this.src.uri }, i.setupInitialPlaylist = function (e) { if (this.state = "HAVE_MASTER", e.playlists) return this.master = e, function (e, t) { e.uri = t; for (var i = 0; i < e.playlists.length; i++)if (!e.playlists[i].uri) { var n = "placeholder-uri-" + i; e.playlists[i].uri = n } var r = ue(e); ce(e, (function (t, i, n, a) { var s = "placeholder-uri-" + i + "-" + n + "-" + a; if (!t.playlists || !t.playlists.length) { if (r && "AUDIO" === i && !t.uri) for (var o = 0; o < e.playlists.length; o++) { var u = e.playlists[o]; if (u.attributes && u.attributes.AUDIO && u.attributes.AUDIO === n) return } t.playlists = [f({}, t)] } t.playlists.forEach((function (t, i) { var n = he(i, s); t.uri ? t.resolvedUri = t.resolvedUri || l(e.uri, t.uri) : (t.uri = 0 === i ? s : n, t.resolvedUri = t.uri), t.id = t.id || n, t.attributes = t.attributes || {}, e.playlists[t.id] = t, e.playlists[t.uri] = t })) })), function (e) { for (var t = e.playlists.length; t--;) { var i = e.playlists[t]; fe({ playlist: i, id: he(t, i.uri) }), i.resolvedUri = l(e.uri, i.uri), e.playlists[i.id] = i, e.playlists[i.uri] = i, i.attributes.BANDWIDTH || le.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.") } }(e), function (e) { ce(e, (function (t) { t.uri && (t.resolvedUri = l(e.uri, t.uri)) })) }(e) }(this.master, this.srcUri()), e.playlists.forEach((function (e) { e.segments = _e(e), e.segments.forEach((function (t) { ye(t, e.resolvedUri) })) })), this.trigger("loadedplaylist"), void (this.request || this.media(this.master.playlists[0])); var t = this.srcUri() || window.location.href; this.master = function (e, t) { var i = he(0, t), n = { mediaGroups: { AUDIO: {}, VIDEO: {} }, uri: window.location.href, resolvedUri: window.location.href, playlists: [{ uri: t, id: i, resolvedUri: t, attributes: {} }] }; return n.playlists[i] = n.playlists[0], n.playlists[t] = n.playlists[0], n }(0, t), this.haveMetadata({ playlistObject: e, url: t, id: this.master.playlists[0].id }), this.trigger("loadedmetadata") }, t }(me), Se = n.default.xhr, we = n.default.mergeOptions, Ie = function () { var e = function e(t, i) { t = we({ timeout: 45e3 }, t); var r = e.beforeRequest || n.default.Vhs.xhr.beforeRequest; if (r && "function" == typeof r) { var a = r(t); a && (t = a) } var s = (!0 === n.default.Vhs.xhr.original ? Se : n.default.Vhs.xhr)(t, (function (e, t) { return function (e, t, i, n) { var r = "arraybuffer" === e.responseType ? e.response : e.responseText; !t && r && (e.responseTime = Date.now(), e.roundTripTime = e.responseTime - e.requestTime, e.bytesReceived = r.byteLength || r.length, e.bandwidth || (e.bandwidth = Math.floor(e.bytesReceived / e.roundTripTime * 8 * 1e3))), i.headers && (e.responseHeaders = i.headers), t && "ETIMEDOUT" === t.code && (e.timedout = !0), t || e.aborted || 200 === i.statusCode || 206 === i.statusCode || 0 === i.statusCode || (t = new Error("XHR Failed with a response of: " + (e && (r || e.responseText)))), n(t, e) }(s, e, t, i) })), o = s.abort; return s.abort = function () { return s.aborted = !0, o.apply(s, arguments) }, s.uri = t.uri, s.requestTime = Date.now(), s }; return e.original = !0, e }, Ee = function (e) { var t, i = {}; return e.byterange && (i.Range = "bytes=" + (t = e.byterange).offset + "-" + ("bigint" == typeof t.offset || "bigint" == typeof t.length ? window.BigInt(t.offset) + window.BigInt(t.length) - window.BigInt(1) : t.offset + t.length - 1)), i }, Ae = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i, Le = /^application\/dash\+xml/i, ke = function (e) { return Ae.test(e) ? "hls" : Le.test(e) ? "dash" : "application/vnd.videojs.vhs+json" === e ? "vhs-json" : null }, xe = function (e) { return "function" === ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer }, Pe = function (e) { return e instanceof Uint8Array ? e : (Array.isArray(e) || xe(e) || e instanceof ArrayBuffer || (e = "number" != typeof e || "number" == typeof e && e != e ? 0 : [e]), new Uint8Array(e && e.buffer || e, e && e.byteOffset || 0, e && e.byteLength || 0)) }, Oe = window.BigInt || Number, De = [Oe("0x1"), Oe("0x100"), Oe("0x10000"), Oe("0x1000000"), Oe("0x100000000"), Oe("0x10000000000"), Oe("0x1000000000000"), Oe("0x100000000000000"), Oe("0x10000000000000000")]; g = new Uint16Array([65484]), 255 === (y = new Uint8Array(g.buffer, g.byteOffset, g.byteLength))[0] || y[0]; var Ce = function (e, t) { var i = void 0 === t ? {} : t, n = i.signed, r = void 0 !== n && n, a = i.le, s = void 0 !== a && a; e = Pe(e); var o = s ? "reduce" : "reduceRight", u = (e[o] ? e[o] : Array.prototype[o]).call(e, (function (t, i, n) { var r = s ? n : Math.abs(n + 1 - e.length); return t + Oe(i) * De[r] }), Oe(0)); if (r) { var d = De[e.length] / Oe(2) - Oe(1); (u = Oe(u)) > d && (u -= d, u -= d, u -= Oe(2)) } return Number(u) }, Re = function (e, t, i) { var n = void 0 === i ? {} : i, r = n.offset, a = void 0 === r ? 0 : r, s = n.mask, o = void 0 === s ? [] : s; e = Pe(e); var u = (t = Pe(t)).every ? t.every : Array.prototype.every; return t.length && e.length - a >= t.length && u.call(t, (function (t, i) { return t === (o[i] ? o[i] & e[a + i] : e[a + i]) })) }, Ue = function (e, t) { return e.start(t) + "-" + e.end(t) }, Me = function (e, t) { var i = e.toString(16); return "00".substring(0, 2 - i.length) + i + (t % 2 ? " " : "") }, Be = function (e) { return e >= 32 && e < 126 ? String.fromCharCode(e) : "." }, Fe = function (e) { var t = {}; return Object.keys(e).forEach((function (i) { var n = e[i]; xe(n) ? t[i] = { bytes: n.buffer, byteOffset: n.byteOffset, byteLength: n.byteLength } : t[i] = n })), t }, Ne = function (e) { var t = e.byterange || { length: 1 / 0, offset: 0 }; return [t.length, t.offset, e.resolvedUri].join(",") }, qe = function (e) { return e.resolvedUri }, We = function (e) { for (var t = Array.prototype.slice.call(e), i = 16, n = "", r = 0; r < t.length / i; r++)n += t.slice(r * i, r * i + i).map(Me).join("") + " " + t.slice(r * i, r * i + i).map(Be).join("") + "\n"; return n }, He = Object.freeze({ __proto__: null, createTransferableMessage: Fe, initSegmentId: Ne, segmentKeyId: qe, hexDump: We, tagDump: function (e) { var t = e.bytes; return We(t) }, textRanges: function (e) { var t, i = ""; for (t = 0; t < e.length; t++)i += Ue(e, t) + " "; return i } }), Ge = function e(t) { var i = t.programTime, n = t.playlist, r = t.retryCount, a = void 0 === r ? 2 : r, s = t.seekTo, o = t.pauseAfterSeek, u = void 0 === o || o, d = t.tech, l = t.callback; if (!l) throw new Error("seekToProgramTime: callback must be provided"); if (void 0 === i || !n || !s) return l({ message: "seekToProgramTime: programTime, seekTo and playlist must be provided" }); if (!n.endList && !d.hasStarted_) return l({ message: "player must be playing a live stream to start buffering" }); if (!function (e) { if (!e.segments || 0 === e.segments.length) return !1; for (var t = 0; t < e.segments.length; t++)if (!e.segments[t].dateTimeObject) return !1; return !0 }(n)) return l({ message: "programDateTime tags must be provided in the manifest " + n.resolvedUri }); var h = function (e, t) { var i; try { i = new Date(e) } catch (e) { return null } if (!t || !t.segments || 0 === t.segments.length) return null; var n = t.segments[0]; if (i < n.dateTimeObject) return null; for (var r = 0; r < t.segments.length - 1 && (n = t.segments[r], !(i < t.segments[r + 1].dateTimeObject)); r++); var a, s = t.segments[t.segments.length - 1], o = s.dateTimeObject, u = s.videoTimingInfo ? (a = s.videoTimingInfo).transmuxedPresentationEnd - a.transmuxedPresentationStart - a.transmuxerPrependedSeconds : s.duration + .25 * s.duration; return i > new Date(o.getTime() + 1e3 * u) ? null : (i > o && (n = s), { segment: n, estimatedStart: n.videoTimingInfo ? n.videoTimingInfo.transmuxedPresentationStart : de.duration(t, t.mediaSequence + t.segments.indexOf(n)), type: n.videoTimingInfo ? "accurate" : "estimate" }) }(i, n); if (!h) return l({ message: i + " was not found in the stream" }); var c = h.segment, f = function (e, t) { var i, n; try { i = new Date(e), n = new Date(t) } catch (e) { } var r = i.getTime(); return (n.getTime() - r) / 1e3 }(c.dateTimeObject, i); if ("estimate" === h.type) return 0 === a ? l({ message: i + " is not buffered yet. Try again" }) : (s(h.estimatedStart + f), void d.one("seeked", (function () { e({ programTime: i, playlist: n, retryCount: a - 1, seekTo: s, pauseAfterSeek: u, tech: d, callback: l }) }))); var p = c.start + f; d.one("seeked", (function () { return l(null, d.currentTime()) })), u && d.pause(), s(p) }, Ve = { GOAL_BUFFER_LENGTH: 30, MAX_GOAL_BUFFER_LENGTH: 60, BACK_BUFFER_LENGTH: 30, GOAL_BUFFER_LENGTH_RATE: 1, INITIAL_BANDWIDTH: 4194304, BANDWIDTH_VARIANCE: 1.2, BUFFER_LOW_WATER_LINE: 0, MAX_BUFFER_LOW_WATER_LINE: 30, EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16, BUFFER_LOW_WATER_LINE_RATE: 1, BUFFER_HIGH_WATER_LINE: 30 }, je = function (e) { return e.on = e.addEventListener, e.off = e.removeEventListener, e }, Xe = function (e) { return function () { var t = function (e) { try { return URL.createObjectURL(new Blob([e], { type: "application/javascript" })) } catch (i) { var t = new BlobBuilder; return t.append(e), URL.createObjectURL(t.getBlob()) } }(e), i = je(new Worker(t)); i.objURL = t; var n = i.terminate; return i.on = i.addEventListener, i.off = i.removeEventListener, i.terminate = function () { return URL.revokeObjectURL(t), n.call(this) }, i } }, Qe = function (e) { return "var browserWorkerPolyFill = " + je.toString() + ";\nbrowserWorkerPolyFill(self);\n" + e }, ze = function (e) { return e.toString().replace(/^function.+?{/, "").slice(0, -1) }, Ye = Qe(ze((function () { var e = function () { this.init = function () { var e = {}; this.on = function (t, i) { e[t] || (e[t] = []), e[t] = e[t].concat(i) }, this.off = function (t, i) { var n; return !!e[t] && (n = e[t].indexOf(i), e[t] = e[t].slice(), e[t].splice(n, 1), n > -1) }, this.trigger = function (t) { var i, n, r, a; if (i = e[t]) if (2 === arguments.length) for (r = i.length, n = 0; n < r; ++n)i[n].call(this, arguments[1]); else { for (a = [], n = arguments.length, n = 1; n < arguments.length; ++n)a.push(arguments[n]); for (r = i.length, n = 0; n < r; ++n)i[n].apply(this, a) } }, this.dispose = function () { e = {} } } }; e.prototype.pipe = function (e) { return this.on("data", (function (t) { e.push(t) })), this.on("done", (function (t) { e.flush(t) })), this.on("partialdone", (function (t) { e.partialFlush(t) })), this.on("endedtimeline", (function (t) { e.endTimeline(t) })), this.on("reset", (function (t) { e.reset(t) })), e }, e.prototype.push = function (e) { this.trigger("data", e) }, e.prototype.flush = function (e) { this.trigger("done", e) }, e.prototype.partialFlush = function (e) { this.trigger("partialdone", e) }, e.prototype.endTimeline = function (e) { this.trigger("endedtimeline", e) }, e.prototype.reset = function (e) { this.trigger("reset", e) }; var t, i, n, r, a, s, o, u, d, l, h, c, f, p, m, g, y, _, v, b, T, S, w, I, E, A, L, k, x, P, O, D, C, R, U, M, B, F, N, q, W = e, H = Math.pow(2, 32), G = { getUint64: function (e) { var t, i = new DataView(e.buffer, e.byteOffset, e.byteLength); return i.getBigUint64 ? (t = i.getBigUint64(0)) < Number.MAX_SAFE_INTEGER ? Number(t) : t : i.getUint32(0) * H + i.getUint32(4) }, MAX_UINT32: H }, V = G.MAX_UINT32; !function () { var e; if (S = { avc1: [], avcC: [], btrt: [], dinf: [], dref: [], esds: [], ftyp: [], hdlr: [], mdat: [], mdhd: [], mdia: [], mfhd: [], minf: [], moof: [], moov: [], mp4a: [], mvex: [], mvhd: [], pasp: [], sdtp: [], smhd: [], stbl: [], stco: [], stsc: [], stsd: [], stsz: [], stts: [], styp: [], tfdt: [], tfhd: [], traf: [], trak: [], trun: [], trex: [], tkhd: [], vmhd: [] }, "undefined" != typeof Uint8Array) { for (e in S) S.hasOwnProperty(e) && (S[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]); w = new Uint8Array(["i".charCodeAt(0), "s".charCodeAt(0), "o".charCodeAt(0), "m".charCodeAt(0)]), E = new Uint8Array(["a".charCodeAt(0), "v".charCodeAt(0), "c".charCodeAt(0), "1".charCodeAt(0)]), I = new Uint8Array([0, 0, 0, 1]), A = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), L = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]), k = { video: A, audio: L }, O = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), P = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), D = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), C = D, R = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), U = D, x = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]) } }(), t = function (e) { var t, i, n = [], r = 0; for (t = 1; t < arguments.length; t++)n.push(arguments[t]); for (t = n.length; t--;)r += n[t].byteLength; for (i = new Uint8Array(r + 8), new DataView(i.buffer, i.byteOffset, i.byteLength).setUint32(0, i.byteLength), i.set(e, 4), t = 0, r = 8; t < n.length; t++)i.set(n[t], r), r += n[t].byteLength; return i }, i = function () { return t(S.dinf, t(S.dref, O)) }, n = function (e) { return t(S.esds, new Uint8Array([0, 0, 0, 0, 3, 25, 0, 0, 0, 4, 17, 64, 21, 0, 6, 0, 0, 0, 218, 192, 0, 0, 218, 192, 5, 2, e.audioobjecttype << 3 | e.samplingfrequencyindex >>> 1, e.samplingfrequencyindex << 7 | e.channelcount << 3, 6, 1, 2])) }, m = function (e) { return t(S.hdlr, k[e]) }, p = function (e) { var i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 1, 95, 144, e.duration >>> 24 & 255, e.duration >>> 16 & 255, e.duration >>> 8 & 255, 255 & e.duration, 85, 196, 0, 0]); return e.samplerate && (i[12] = e.samplerate >>> 24 & 255, i[13] = e.samplerate >>> 16 & 255, i[14] = e.samplerate >>> 8 & 255, i[15] = 255 & e.samplerate), t(S.mdhd, i) }, f = function (e) { return t(S.mdia, p(e), m(e.type), s(e)) }, a = function (e) { return t(S.mfhd, new Uint8Array([0, 0, 0, 0, (4278190080 & e) >> 24, (16711680 & e) >> 16, (65280 & e) >> 8, 255 & e])) }, s = function (e) { return t(S.minf, "video" === e.type ? t(S.vmhd, x) : t(S.smhd, P), i(), y(e)) }, o = function (e, i) { for (var n = [], r = i.length; r--;)n[r] = v(i[r]); return t.apply(null, [S.moof, a(e)].concat(n)) }, u = function (e) { for (var i = e.length, n = []; i--;)n[i] = h(e[i]); return t.apply(null, [S.moov, l(4294967295)].concat(n).concat(d(e))) }, d = function (e) { for (var i = e.length, n = []; i--;)n[i] = b(e[i]); return t.apply(null, [S.mvex].concat(n)) }, l = function (e) { var i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 1, 95, 144, (4278190080 & e) >> 24, (16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]); return t(S.mvhd, i) }, g = function (e) { var i, n, r = e.samples || [], a = new Uint8Array(4 + r.length); for (n = 0; n < r.length; n++)i = r[n].flags, a[n + 4] = i.dependsOn << 4 | i.isDependedOn << 2 | i.hasRedundancy; return t(S.sdtp, a) }, y = function (e) { return t(S.stbl, _(e), t(S.stts, U), t(S.stsc, C), t(S.stsz, R), t(S.stco, D)) }, _ = function (e) { return t(S.stsd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]), "video" === e.type ? M(e) : B(e)) }, M = function (e) { var i, n, r = e.sps || [], a = e.pps || [], s = [], o = []; for (i = 0; i < r.length; i++)s.push((65280 & r[i].byteLength) >>> 8), s.push(255 & r[i].byteLength), s = s.concat(Array.prototype.slice.call(r[i])); for (i = 0; i < a.length; i++)o.push((65280 & a[i].byteLength) >>> 8), o.push(255 & a[i].byteLength), o = o.concat(Array.prototype.slice.call(a[i])); if (n = [S.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (65280 & e.width) >> 8, 255 & e.width, (65280 & e.height) >> 8, 255 & e.height, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 19, 118, 105, 100, 101, 111, 106, 115, 45, 99, 111, 110, 116, 114, 105, 98, 45, 104, 108, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), t(S.avcC, new Uint8Array([1, e.profileIdc, e.profileCompatibility, e.levelIdc, 255].concat([r.length], s, [a.length], o))), t(S.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192]))], e.sarRatio) { var u = e.sarRatio[0], d = e.sarRatio[1]; n.push(t(S.pasp, new Uint8Array([(4278190080 & u) >> 24, (16711680 & u) >> 16, (65280 & u) >> 8, 255 & u, (4278190080 & d) >> 24, (16711680 & d) >> 16, (65280 & d) >> 8, 255 & d]))) } return t.apply(null, n) }, B = function (e) { return t(S.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, (65280 & e.channelcount) >> 8, 255 & e.channelcount, (65280 & e.samplesize) >> 8, 255 & e.samplesize, 0, 0, 0, 0, (65280 & e.samplerate) >> 8, 255 & e.samplerate, 0, 0]), n(e)) }, c = function (e) { var i = new Uint8Array([0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 0, (4278190080 & e.duration) >> 24, (16711680 & e.duration) >> 16, (65280 & e.duration) >> 8, 255 & e.duration, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, (65280 & e.width) >> 8, 255 & e.width, 0, 0, (65280 & e.height) >> 8, 255 & e.height, 0, 0]); return t(S.tkhd, i) }, v = function (e) { var i, n, r, a, s, o; return i = t(S.tfhd, new Uint8Array([0, 0, 0, 58, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])), s = Math.floor(e.baseMediaDecodeTime / V), o = Math.floor(e.baseMediaDecodeTime % V), n = t(S.tfdt, new Uint8Array([1, 0, 0, 0, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, 255 & o])), "audio" === e.type ? (r = T(e, 92), t(S.traf, i, n, r)) : (a = g(e), r = T(e, a.length + 92), t(S.traf, i, n, r, a)) }, h = function (e) { return e.duration = e.duration || 4294967295, t(S.trak, c(e), f(e)) }, b = function (e) { var i = new Uint8Array([0, 0, 0, 0, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]); return "video" !== e.type && (i[i.length - 1] = 0), t(S.trex, i) }, q = function (e, t) { var i = 0, n = 0, r = 0, a = 0; return e.length && (void 0 !== e[0].duration && (i = 1), void 0 !== e[0].size && (n = 2), void 0 !== e[0].flags && (r = 4), void 0 !== e[0].compositionTimeOffset && (a = 8)), [0, 0, i | n | r | a, 1, (4278190080 & e.length) >>> 24, (16711680 & e.length) >>> 16, (65280 & e.length) >>> 8, 255 & e.length, (4278190080 & t) >>> 24, (16711680 & t) >>> 16, (65280 & t) >>> 8, 255 & t] }, N = function (e, i) { var n, r, a, s, o, u; for (i += 20 + 16 * (s = e.samples || []).length, a = q(s, i), (r = new Uint8Array(a.length + 16 * s.length)).set(a), n = a.length, u = 0; u < s.length; u++)o = s[u], r[n++] = (4278190080 & o.duration) >>> 24, r[n++] = (16711680 & o.duration) >>> 16, r[n++] = (65280 & o.duration) >>> 8, r[n++] = 255 & o.duration, r[n++] = (4278190080 & o.size) >>> 24, r[n++] = (16711680 & o.size) >>> 16, r[n++] = (65280 & o.size) >>> 8, r[n++] = 255 & o.size, r[n++] = o.flags.isLeading << 2 | o.flags.dependsOn, r[n++] = o.flags.isDependedOn << 6 | o.flags.hasRedundancy << 4 | o.flags.paddingValue << 1 | o.flags.isNonSyncSample, r[n++] = 61440 & o.flags.degradationPriority, r[n++] = 15 & o.flags.degradationPriority, r[n++] = (4278190080 & o.compositionTimeOffset) >>> 24, r[n++] = (16711680 & o.compositionTimeOffset) >>> 16, r[n++] = (65280 & o.compositionTimeOffset) >>> 8, r[n++] = 255 & o.compositionTimeOffset; return t(S.trun, r) }, F = function (e, i) { var n, r, a, s, o, u; for (i += 20 + 8 * (s = e.samples || []).length, a = q(s, i), (n = new Uint8Array(a.length + 8 * s.length)).set(a), r = a.length, u = 0; u < s.length; u++)o = s[u], n[r++] = (4278190080 & o.duration) >>> 24, n[r++] = (16711680 & o.duration) >>> 16, n[r++] = (65280 & o.duration) >>> 8, n[r++] = 255 & o.duration, n[r++] = (4278190080 & o.size) >>> 24, n[r++] = (16711680 & o.size) >>> 16, n[r++] = (65280 & o.size) >>> 8, n[r++] = 255 & o.size; return t(S.trun, n) }, T = function (e, t) { return "audio" === e.type ? F(e, t) : N(e, t) }, r = function () { return t(S.ftyp, w, I, w, E) }; var j, X, Q, z, Y, K, $, J, Z = function (e) { return t(S.mdat, e) }, ee = o, te = function (e, t) { var i = { size: 0, flags: { isLeading: 0, dependsOn: 1, isDependedOn: 0, hasRedundancy: 0, degradationPriority: 0, isNonSyncSample: 1 } }; return i.dataOffset = t, i.compositionTimeOffset = e.pts - e.dts, i.duration = e.duration, i.size = 4 * e.length, i.size += e.byteLength, e.keyFrame && (i.flags.dependsOn = 2, i.flags.isNonSyncSample = 0), i }, ie = [33, 16, 5, 32, 164, 27], ne = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252], re = function (e) { for (var t = []; e--;)t.push(0); return t }, ae = 9e4; K = function (e, t) { return X(Y(e, t)) }, $ = function (e, t) { return Q(z(e), t) }, J = function (e, t, i) { return z(i ? e : e - t) }; var se = ae, oe = X = function (e) { return e * ae }, ue = (Q = function (e, t) { return e * t }, z = function (e) { return e / ae }), de = (Y = function (e, t) { return e / t }, K), le = $, he = J, ce = function (e, t, i, n) { var r, a, s, o, u, d = 0, l = 0, h = 0; if (t.length && (r = de(e.baseMediaDecodeTime, e.samplerate), a = Math.ceil(se / (e.samplerate / 1024)), i && n && (d = r - Math.max(i, n), h = (l = Math.floor(d / a)) * a), !(l < 1 || h > 45e3))) { for ((s = function () { if (!j) { var e = { 96e3: [ie, [227, 64], re(154), [56]], 88200: [ie, [231], re(170), [56]], 64e3: [ie, [248, 192], re(240), [56]], 48e3: [ie, [255, 192], re(268), [55, 148, 128], re(54), [112]], 44100: [ie, [255, 192], re(268), [55, 163, 128], re(84), [112]], 32e3: [ie, [255, 192], re(268), [55, 234], re(226), [112]], 24e3: [ie, [255, 192], re(268), [55, 255, 128], re(268), [111, 112], re(126), [224]], 16e3: [ie, [255, 192], re(268), [55, 255, 128], re(268), [111, 255], re(269), [223, 108], re(195), [1, 192]], 12e3: [ne, re(268), [3, 127, 248], re(268), [6, 255, 240], re(268), [13, 255, 224], re(268), [27, 253, 128], re(259), [56]], 11025: [ne, re(268), [3, 127, 248], re(268), [6, 255, 240], re(268), [13, 255, 224], re(268), [27, 255, 192], re(268), [55, 175, 128], re(108), [112]], 8e3: [ne, re(268), [3, 121, 16], re(47), [7]] }; t = e, j = Object.keys(t).reduce((function (e, i) { return e[i] = new Uint8Array(t[i].reduce((function (e, t) { return e.concat(t) }), [])), e }), {}) } var t; return j }()[e.samplerate]) || (s = t[0].data), o = 0; o < l; o++)u = t[0], t.splice(0, 0, { data: s, dts: u.dts - a, pts: u.pts - a }); return e.baseMediaDecodeTime -= Math.floor(le(h, e.samplerate)), h } }, fe = function (e) { delete e.minSegmentDts, delete e.maxSegmentDts, delete e.minSegmentPts, delete e.maxSegmentPts }, pe = function (e, t) { var i, n = e.minSegmentDts; return t || (n -= e.timelineStartInfo.dts), i = e.timelineStartInfo.baseMediaDecodeTime, i += n, i = Math.max(0, i), "audio" === e.type && (i *= e.samplerate / 9e4, i = Math.floor(i)), i }, me = function (e, t) { "number" == typeof t.pts && (void 0 === e.timelineStartInfo.pts && (e.timelineStartInfo.pts = t.pts), void 0 === e.minSegmentPts ? e.minSegmentPts = t.pts : e.minSegmentPts = Math.min(e.minSegmentPts, t.pts), void 0 === e.maxSegmentPts ? e.maxSegmentPts = t.pts : e.maxSegmentPts = Math.max(e.maxSegmentPts, t.pts)), "number" == typeof t.dts && (void 0 === e.timelineStartInfo.dts && (e.timelineStartInfo.dts = t.dts), void 0 === e.minSegmentDts ? e.minSegmentDts = t.dts : e.minSegmentDts = Math.min(e.minSegmentDts, t.dts), void 0 === e.maxSegmentDts ? e.maxSegmentDts = t.dts : e.maxSegmentDts = Math.max(e.maxSegmentDts, t.dts)) }, ge = function e(t) { t = t || {}, e.prototype.init.call(this), this.parse708captions_ = "boolean" != typeof t.parse708captions || t.parse708captions, this.captionPackets_ = [], this.ccStreams_ = [new Ae(0, 0), new Ae(0, 1), new Ae(1, 0), new Ae(1, 1)], this.parse708captions_ && (this.cc708Stream_ = new Te({ captionServices: t.captionServices })), this.reset(), this.ccStreams_.forEach((function (e) { e.on("data", this.trigger.bind(this, "data")), e.on("partialdone", this.trigger.bind(this, "partialdone")), e.on("done", this.trigger.bind(this, "done")) }), this), this.parse708captions_ && (this.cc708Stream_.on("data", this.trigger.bind(this, "data")), this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone")), this.cc708Stream_.on("done", this.trigger.bind(this, "done"))) }; (ge.prototype = new W).push = function (e) { var t, i, n; if ("sei_rbsp" === e.nalUnitType && (t = function (e) { for (var t = 0, i = { payloadType: -1, payloadSize: 0 }, n = 0, r = 0; t < e.byteLength && 128 !== e[t];) { for (; 255 === e[t];)n += 255, t++; for (n += e[t++]; 255 === e[t];)r += 255, t++; if (r += e[t++], !i.payload && 4 === n) { if ("GA94" === String.fromCharCode(e[t + 3], e[t + 4], e[t + 5], e[t + 6])) { i.payloadType = n, i.payloadSize = r, i.payload = e.subarray(t, t + r); break } i.payload = void 0 } t += r, n = 0, r = 0 } return i }(e.escapedRBSP)).payload && 4 === t.payloadType && (i = function (e) { return 181 !== e.payload[0] || 49 != (e.payload[1] << 8 | e.payload[2]) || "GA94" !== String.fromCharCode(e.payload[3], e.payload[4], e.payload[5], e.payload[6]) || 3 !== e.payload[7] ? null : e.payload.subarray(8, e.payload.length - 1) }(t))) if (e.dts < this.latestDts_) this.ignoreNextEqualDts_ = !0; else { if (e.dts === this.latestDts_ && this.ignoreNextEqualDts_) return this.numSameDts_--, void (this.numSameDts_ || (this.ignoreNextEqualDts_ = !1)); n = function (e, t) { var i, n, r, a, s = []; if (!(64 & t[0])) return s; for (n = 31 & t[0], i = 0; i < n; i++)a = { type: 3 & t[2 + (r = 3 * i)], pts: e }, 4 & t[r + 2] && (a.ccData = t[r + 3] << 8 | t[r + 4], s.push(a)); return s }(e.pts, i), this.captionPackets_ = this.captionPackets_.concat(n), this.latestDts_ !== e.dts && (this.numSameDts_ = 0), this.numSameDts_++, this.latestDts_ = e.dts } }, ge.prototype.flushCCStreams = function (e) { this.ccStreams_.forEach((function (t) { return "flush" === e ? t.flush() : t.partialFlush() }), this) }, ge.prototype.flushStream = function (e) { this.captionPackets_.length ? (this.captionPackets_.forEach((function (e, t) { e.presortIndex = t })), this.captionPackets_.sort((function (e, t) { return e.pts === t.pts ? e.presortIndex - t.presortIndex : e.pts - t.pts })), this.captionPackets_.forEach((function (e) { e.type < 2 ? this.dispatchCea608Packet(e) : this.dispatchCea708Packet(e) }), this), this.captionPackets_.length = 0, this.flushCCStreams(e)) : this.flushCCStreams(e) }, ge.prototype.flush = function () { return this.flushStream("flush") }, ge.prototype.partialFlush = function () { return this.flushStream("partialFlush") }, ge.prototype.reset = function () { this.latestDts_ = null, this.ignoreNextEqualDts_ = !1, this.numSameDts_ = 0, this.activeCea608Channel_ = [null, null], this.ccStreams_.forEach((function (e) { e.reset() })) }, ge.prototype.dispatchCea608Packet = function (e) { this.setsTextOrXDSActive(e) ? this.activeCea608Channel_[e.type] = null : this.setsChannel1Active(e) ? this.activeCea608Channel_[e.type] = 0 : this.setsChannel2Active(e) && (this.activeCea608Channel_[e.type] = 1), null !== this.activeCea608Channel_[e.type] && this.ccStreams_[(e.type << 1) + this.activeCea608Channel_[e.type]].push(e) }, ge.prototype.setsChannel1Active = function (e) { return 4096 == (30720 & e.ccData) }, ge.prototype.setsChannel2Active = function (e) { return 6144 == (30720 & e.ccData) }, ge.prototype.setsTextOrXDSActive = function (e) { return 256 == (28928 & e.ccData) || 4138 == (30974 & e.ccData) || 6186 == (30974 & e.ccData) }, ge.prototype.dispatchCea708Packet = function (e) { this.parse708captions_ && this.cc708Stream_.push(e) }; var ye = { 127: 9834, 4128: 32, 4129: 160, 4133: 8230, 4138: 352, 4140: 338, 4144: 9608, 4145: 8216, 4146: 8217, 4147: 8220, 4148: 8221, 4149: 8226, 4153: 8482, 4154: 353, 4156: 339, 4157: 8480, 4159: 376, 4214: 8539, 4215: 8540, 4216: 8541, 4217: 8542, 4218: 9168, 4219: 9124, 4220: 9123, 4221: 9135, 4222: 9126, 4223: 9121, 4256: 12600 }, _e = function (e) { return 32 <= e && e <= 127 || 160 <= e && e <= 255 }, ve = function (e) { this.windowNum = e, this.reset() }; ve.prototype.reset = function () { this.clearText(), this.pendingNewLine = !1, this.winAttr = {}, this.penAttr = {}, this.penLoc = {}, this.penColor = {}, this.visible = 0, this.rowLock = 0, this.columnLock = 0, this.priority = 0, this.relativePositioning = 0, this.anchorVertical = 0, this.anchorHorizontal = 0, this.anchorPoint = 0, this.rowCount = 1, this.virtualRowCount = this.rowCount + 1, this.columnCount = 41, this.windowStyle = 0, this.penStyle = 0 }, ve.prototype.getText = function () { return this.rows.join("\n") }, ve.prototype.clearText = function () { this.rows = [""], this.rowIdx = 0 }, ve.prototype.newLine = function (e) { for (this.rows.length >= this.virtualRowCount && "function" == typeof this.beforeRowOverflow && this.beforeRowOverflow(e), this.rows.length > 0 && (this.rows.push(""), this.rowIdx++); this.rows.length > this.virtualRowCount;)this.rows.shift(), this.rowIdx-- }, ve.prototype.isEmpty = function () { return 0 === this.rows.length || 1 === this.rows.length && "" === this.rows[0] }, ve.prototype.addText = function (e) { this.rows[this.rowIdx] += e }, ve.prototype.backspace = function () { if (!this.isEmpty()) { var e = this.rows[this.rowIdx]; this.rows[this.rowIdx] = e.substr(0, e.length - 1) } }; var be = function (e, t, i) { this.serviceNum = e, this.text = "", this.currentWindow = new ve(-1), this.windows = [], this.stream = i, "string" == typeof t && this.createTextDecoder(t) }; be.prototype.init = function (e, t) { this.startPts = e; for (var i = 0; i < 8; i++)this.windows[i] = new ve(i), "function" == typeof t && (this.windows[i].beforeRowOverflow = t) }, be.prototype.setCurrentWindow = function (e) { this.currentWindow = this.windows[e] }, be.prototype.createTextDecoder = function (e) { if ("undefined" == typeof TextDecoder) this.stream.trigger("log", { level: "warn", message: "The `encoding` option is unsupported without TextDecoder support" }); else try { this.textDecoder_ = new TextDecoder(e) } catch (t) { this.stream.trigger("log", { level: "warn", message: "TextDecoder could not be created with " + e + " encoding. " + t }) } }; var Te = function e(t) { t = t || {}, e.prototype.init.call(this); var i, n = this, r = t.captionServices || {}, a = {}; Object.keys(r).forEach((function (e) { i = r[e], /^SERVICE/.test(e) && (a[e] = i.encoding) })), this.serviceEncodings = a, this.current708Packet = null, this.services = {}, this.push = function (e) { 3 === e.type ? (n.new708Packet(), n.add708Bytes(e)) : (null === n.current708Packet && n.new708Packet(), n.add708Bytes(e)) } }; Te.prototype = new W, Te.prototype.new708Packet = function () { null !== this.current708Packet && this.push708Packet(), this.current708Packet = { data: [], ptsVals: [] } }, Te.prototype.add708Bytes = function (e) { var t = e.ccData, i = t >>> 8, n = 255 & t; this.current708Packet.ptsVals.push(e.pts), this.current708Packet.data.push(i), this.current708Packet.data.push(n) }, Te.prototype.push708Packet = function () { var e = this.current708Packet, t = e.data, i = null, n = null, r = 0, a = t[r++]; for (e.seq = a >> 6, e.sizeCode = 63 & a; r < t.length; r++)n = 31 & (a = t[r++]), 7 == (i = a >> 5) && n > 0 && (i = a = t[r++]), this.pushServiceBlock(i, r, n), n > 0 && (r += n - 1) }, Te.prototype.pushServiceBlock = function (e, t, i) { var n, r = t, a = this.current708Packet.data, s = this.services[e]; for (s || (s = this.initService(e, r)); r < t + i && r < a.length; r++)n = a[r], _e(n) ? r = this.handleText(r, s) : 24 === n ? r = this.multiByteCharacter(r, s) : 16 === n ? r = this.extendedCommands(r, s) : 128 <= n && n <= 135 ? r = this.setCurrentWindow(r, s) : 152 <= n && n <= 159 ? r = this.defineWindow(r, s) : 136 === n ? r = this.clearWindows(r, s) : 140 === n ? r = this.deleteWindows(r, s) : 137 === n ? r = this.displayWindows(r, s) : 138 === n ? r = this.hideWindows(r, s) : 139 === n ? r = this.toggleWindows(r, s) : 151 === n ? r = this.setWindowAttributes(r, s) : 144 === n ? r = this.setPenAttributes(r, s) : 145 === n ? r = this.setPenColor(r, s) : 146 === n ? r = this.setPenLocation(r, s) : 143 === n ? s = this.reset(r, s) : 8 === n ? s.currentWindow.backspace() : 12 === n ? s.currentWindow.clearText() : 13 === n ? s.currentWindow.pendingNewLine = !0 : 14 === n ? s.currentWindow.clearText() : 141 === n && r++ }, Te.prototype.extendedCommands = function (e, t) { var i = this.current708Packet.data[++e]; return _e(i) && (e = this.handleText(e, t, { isExtended: !0 })), e }, Te.prototype.getPts = function (e) { return this.current708Packet.ptsVals[Math.floor(e / 2)] }, Te.prototype.initService = function (e, t) { var i, n, r = this; return (i = "SERVICE" + e) in this.serviceEncodings && (n = this.serviceEncodings[i]), this.services[e] = new be(e, n, r), this.services[e].init(this.getPts(t), (function (t) { r.flushDisplayed(t, r.services[e]) })), this.services[e] }, Te.prototype.handleText = function (e, t, i) { var n, r, a, s, o = i && i.isExtended, u = i && i.isMultiByte, d = this.current708Packet.data, l = o ? 4096 : 0, h = d[e], c = d[e + 1], f = t.currentWindow; return t.textDecoder_ && !o ? (u ? (r = [h, c], e++) : r = [h], n = t.textDecoder_.decode(new Uint8Array(r))) : (s = ye[a = l | h] || a, n = 4096 & a && a === s ? "" : String.fromCharCode(s)), f.pendingNewLine && !f.isEmpty() && f.newLine(this.getPts(e)), f.pendingNewLine = !1, f.addText(n), e }, Te.prototype.multiByteCharacter = function (e, t) { var i = this.current708Packet.data, n = i[e + 1], r = i[e + 2]; return _e(n) && _e(r) && (e = this.handleText(++e, t, { isMultiByte: !0 })), e }, Te.prototype.setCurrentWindow = function (e, t) { var i = 7 & this.current708Packet.data[e]; return t.setCurrentWindow(i), e }, Te.prototype.defineWindow = function (e, t) { var i = this.current708Packet.data, n = i[e], r = 7 & n; t.setCurrentWindow(r); var a = t.currentWindow; return n = i[++e], a.visible = (32 & n) >> 5, a.rowLock = (16 & n) >> 4, a.columnLock = (8 & n) >> 3, a.priority = 7 & n, n = i[++e], a.relativePositioning = (128 & n) >> 7, a.anchorVertical = 127 & n, n = i[++e], a.anchorHorizontal = n, n = i[++e], a.anchorPoint = (240 & n) >> 4, a.rowCount = 15 & n, n = i[++e], a.columnCount = 63 & n, n = i[++e], a.windowStyle = (56 & n) >> 3, a.penStyle = 7 & n, a.virtualRowCount = a.rowCount + 1, e }, Te.prototype.setWindowAttributes = function (e, t) { var i = this.current708Packet.data, n = i[e], r = t.currentWindow.winAttr; return n = i[++e], r.fillOpacity = (192 & n) >> 6, r.fillRed = (48 & n) >> 4, r.fillGreen = (12 & n) >> 2, r.fillBlue = 3 & n, n = i[++e], r.borderType = (192 & n) >> 6, r.borderRed = (48 & n) >> 4, r.borderGreen = (12 & n) >> 2, r.borderBlue = 3 & n, n = i[++e], r.borderType += (128 & n) >> 5, r.wordWrap = (64 & n) >> 6, r.printDirection = (48 & n) >> 4, r.scrollDirection = (12 & n) >> 2, r.justify = 3 & n, n = i[++e], r.effectSpeed = (240 & n) >> 4, r.effectDirection = (12 & n) >> 2, r.displayEffect = 3 & n, e }, Te.prototype.flushDisplayed = function (e, t) { for (var i = [], n = 0; n < 8; n++)t.windows[n].visible && !t.windows[n].isEmpty() && i.push(t.windows[n].getText()); t.endPts = e, t.text = i.join("\n\n"), this.pushCaption(t), t.startPts = e }, Te.prototype.pushCaption = function (e) { "" !== e.text && (this.trigger("data", { startPts: e.startPts, endPts: e.endPts, text: e.text, stream: "cc708_" + e.serviceNum }), e.text = "", e.startPts = e.endPts) }, Te.prototype.displayWindows = function (e, t) { var i = this.current708Packet.data[++e], n = this.getPts(e); this.flushDisplayed(n, t); for (var r = 0; r < 8; r++)i & 1 << r && (t.windows[r].visible = 1); return e }, Te.prototype.hideWindows = function (e, t) { var i = this.current708Packet.data[++e], n = this.getPts(e); this.flushDisplayed(n, t); for (var r = 0; r < 8; r++)i & 1 << r && (t.windows[r].visible = 0); return e }, Te.prototype.toggleWindows = function (e, t) { var i = this.current708Packet.data[++e], n = this.getPts(e); this.flushDisplayed(n, t); for (var r = 0; r < 8; r++)i & 1 << r && (t.windows[r].visible ^= 1); return e }, Te.prototype.clearWindows = function (e, t) { var i = this.current708Packet.data[++e], n = this.getPts(e); this.flushDisplayed(n, t); for (var r = 0; r < 8; r++)i & 1 << r && t.windows[r].clearText(); return e }, Te.prototype.deleteWindows = function (e, t) { var i = this.current708Packet.data[++e], n = this.getPts(e); this.flushDisplayed(n, t); for (var r = 0; r < 8; r++)i & 1 << r && t.windows[r].reset(); return e }, Te.prototype.setPenAttributes = function (e, t) { var i = this.current708Packet.data, n = i[e], r = t.currentWindow.penAttr; return n = i[++e], r.textTag = (240 & n) >> 4, r.offset = (12 & n) >> 2, r.penSize = 3 & n, n = i[++e], r.italics = (128 & n) >> 7, r.underline = (64 & n) >> 6, r.edgeType = (56 & n) >> 3, r.fontStyle = 7 & n, e }, Te.prototype.setPenColor = function (e, t) { var i = this.current708Packet.data, n = i[e], r = t.currentWindow.penColor; return n = i[++e], r.fgOpacity = (192 & n) >> 6, r.fgRed = (48 & n) >> 4, r.fgGreen = (12 & n) >> 2, r.fgBlue = 3 & n, n = i[++e], r.bgOpacity = (192 & n) >> 6, r.bgRed = (48 & n) >> 4, r.bgGreen = (12 & n) >> 2, r.bgBlue = 3 & n, n = i[++e], r.edgeRed = (48 & n) >> 4, r.edgeGreen = (12 & n) >> 2, r.edgeBlue = 3 & n, e }, Te.prototype.setPenLocation = function (e, t) { var i = this.current708Packet.data, n = i[e], r = t.currentWindow.penLoc; return t.currentWindow.pendingNewLine = !0, n = i[++e], r.row = 15 & n, n = i[++e], r.column = 63 & n, e }, Te.prototype.reset = function (e, t) { var i = this.getPts(e); return this.flushDisplayed(i, t), this.initService(t.serviceNum, e) }; var Se = { 42: 225, 92: 233, 94: 237, 95: 243, 96: 250, 123: 231, 124: 247, 125: 209, 126: 241, 127: 9608, 304: 174, 305: 176, 306: 189, 307: 191, 308: 8482, 309: 162, 310: 163, 311: 9834, 312: 224, 313: 160, 314: 232, 315: 226, 316: 234, 317: 238, 318: 244, 319: 251, 544: 193, 545: 201, 546: 211, 547: 218, 548: 220, 549: 252, 550: 8216, 551: 161, 552: 42, 553: 39, 554: 8212, 555: 169, 556: 8480, 557: 8226, 558: 8220, 559: 8221, 560: 192, 561: 194, 562: 199, 563: 200, 564: 202, 565: 203, 566: 235, 567: 206, 568: 207, 569: 239, 570: 212, 571: 217, 572: 249, 573: 219, 574: 171, 575: 187, 800: 195, 801: 227, 802: 205, 803: 204, 804: 236, 805: 210, 806: 242, 807: 213, 808: 245, 809: 123, 810: 125, 811: 92, 812: 94, 813: 95, 814: 124, 815: 126, 816: 196, 817: 228, 818: 214, 819: 246, 820: 223, 821: 165, 822: 164, 823: 9474, 824: 197, 825: 229, 826: 216, 827: 248, 828: 9484, 829: 9488, 830: 9492, 831: 9496 }, we = function (e) { return null === e ? "" : (e = Se[e] || e, String.fromCharCode(e)) }, Ie = [4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152], Ee = function () { for (var e = [], t = 15; t--;)e.push(""); return e }, Ae = function e(t, i) { e.prototype.init.call(this), this.field_ = t || 0, this.dataChannel_ = i || 0, this.name_ = "CC" + (1 + (this.field_ << 1 | this.dataChannel_)), this.setConstants(), this.reset(), this.push = function (e) { var t, i, n, r, a; if ((t = 32639 & e.ccData) !== this.lastControlCode_) { if (4096 == (61440 & t) ? this.lastControlCode_ = t : t !== this.PADDING_ && (this.lastControlCode_ = null), n = t >>> 8, r = 255 & t, t !== this.PADDING_) if (t === this.RESUME_CAPTION_LOADING_) this.mode_ = "popOn"; else if (t === this.END_OF_CAPTION_) this.mode_ = "popOn", this.clearFormatting(e.pts), this.flushDisplayed(e.pts), i = this.displayed_, this.displayed_ = this.nonDisplayed_, this.nonDisplayed_ = i, this.startPts_ = e.pts; else if (t === this.ROLL_UP_2_ROWS_) this.rollUpRows_ = 2, this.setRollUp(e.pts); else if (t === this.ROLL_UP_3_ROWS_) this.rollUpRows_ = 3, this.setRollUp(e.pts); else if (t === this.ROLL_UP_4_ROWS_) this.rollUpRows_ = 4, this.setRollUp(e.pts); else if (t === this.CARRIAGE_RETURN_) this.clearFormatting(e.pts), this.flushDisplayed(e.pts), this.shiftRowsUp_(), this.startPts_ = e.pts; else if (t === this.BACKSPACE_) "popOn" === this.mode_ ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1); else if (t === this.ERASE_DISPLAYED_MEMORY_) this.flushDisplayed(e.pts), this.displayed_ = Ee(); else if (t === this.ERASE_NON_DISPLAYED_MEMORY_) this.nonDisplayed_ = Ee(); else if (t === this.RESUME_DIRECT_CAPTIONING_) "paintOn" !== this.mode_ && (this.flushDisplayed(e.pts), this.displayed_ = Ee()), this.mode_ = "paintOn", this.startPts_ = e.pts; else if (this.isSpecialCharacter(n, r)) a = we((n = (3 & n) << 8) | r), this[this.mode_](e.pts, a), this.column_++; else if (this.isExtCharacter(n, r)) "popOn" === this.mode_ ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1), a = we((n = (3 & n) << 8) | r), this[this.mode_](e.pts, a), this.column_++; else if (this.isMidRowCode(n, r)) this.clearFormatting(e.pts), this[this.mode_](e.pts, " "), this.column_++, 14 == (14 & r) && this.addFormatting(e.pts, ["i"]), 1 == (1 & r) && this.addFormatting(e.pts, ["u"]); else if (this.isOffsetControlCode(n, r)) this.column_ += 3 & r; else if (this.isPAC(n, r)) { var s = Ie.indexOf(7968 & t); "rollUp" === this.mode_ && (s - this.rollUpRows_ + 1 < 0 && (s = this.rollUpRows_ - 1), this.setRollUp(e.pts, s)), s !== this.row_ && (this.clearFormatting(e.pts), this.row_ = s), 1 & r && -1 === this.formatting_.indexOf("u") && this.addFormatting(e.pts, ["u"]), 16 == (16 & t) && (this.column_ = 4 * ((14 & t) >> 1)), this.isColorPAC(r) && 14 == (14 & r) && this.addFormatting(e.pts, ["i"]) } else this.isNormalChar(n) && (0 === r && (r = null), a = we(n), a += we(r), this[this.mode_](e.pts, a), this.column_ += a.length) } else this.lastControlCode_ = null } }; Ae.prototype = new W, Ae.prototype.flushDisplayed = function (e) { var t = this.displayed_.map((function (e, t) { try { return e.trim() } catch (e) { return this.trigger("log", { level: "warn", message: "Skipping a malformed 608 caption at index " + t + "." }), "" } }), this).join("\n").replace(/^\n+|\n+$/g, ""); t.length && this.trigger("data", { startPts: this.startPts_, endPts: e, text: t, stream: this.name_ }) }, Ae.prototype.reset = function () { this.mode_ = "popOn", this.topRow_ = 0, this.startPts_ = 0, this.displayed_ = Ee(), this.nonDisplayed_ = Ee(), this.lastControlCode_ = null, this.column_ = 0, this.row_ = 14, this.rollUpRows_ = 2, this.formatting_ = [] }, Ae.prototype.setConstants = function () { 0 === this.dataChannel_ ? (this.BASE_ = 16, this.EXT_ = 17, this.CONTROL_ = (20 | this.field_) << 8, this.OFFSET_ = 23) : 1 === this.dataChannel_ && (this.BASE_ = 24, this.EXT_ = 25, this.CONTROL_ = (28 | this.field_) << 8, this.OFFSET_ = 31), this.PADDING_ = 0, this.RESUME_CAPTION_LOADING_ = 32 | this.CONTROL_, this.END_OF_CAPTION_ = 47 | this.CONTROL_, this.ROLL_UP_2_ROWS_ = 37 | this.CONTROL_, this.ROLL_UP_3_ROWS_ = 38 | this.CONTROL_, this.ROLL_UP_4_ROWS_ = 39 | this.CONTROL_, this.CARRIAGE_RETURN_ = 45 | this.CONTROL_, this.RESUME_DIRECT_CAPTIONING_ = 41 | this.CONTROL_, this.BACKSPACE_ = 33 | this.CONTROL_, this.ERASE_DISPLAYED_MEMORY_ = 44 | this.CONTROL_, this.ERASE_NON_DISPLAYED_MEMORY_ = 46 | this.CONTROL_ }, Ae.prototype.isSpecialCharacter = function (e, t) { return e === this.EXT_ && t >= 48 && t <= 63 }, Ae.prototype.isExtCharacter = function (e, t) { return (e === this.EXT_ + 1 || e === this.EXT_ + 2) && t >= 32 && t <= 63 }, Ae.prototype.isMidRowCode = function (e, t) { return e === this.EXT_ && t >= 32 && t <= 47 }, Ae.prototype.isOffsetControlCode = function (e, t) { return e === this.OFFSET_ && t >= 33 && t <= 35 }, Ae.prototype.isPAC = function (e, t) { return e >= this.BASE_ && e < this.BASE_ + 8 && t >= 64 && t <= 127 }, Ae.prototype.isColorPAC = function (e) { return e >= 64 && e <= 79 || e >= 96 && e <= 127 }, Ae.prototype.isNormalChar = function (e) { return e >= 32 && e <= 127 }, Ae.prototype.setRollUp = function (e, t) { if ("rollUp" !== this.mode_ && (this.row_ = 14, this.mode_ = "rollUp", this.flushDisplayed(e), this.nonDisplayed_ = Ee(), this.displayed_ = Ee()), void 0 !== t && t !== this.row_) for (var i = 0; i < this.rollUpRows_; i++)this.displayed_[t - i] = this.displayed_[this.row_ - i], this.displayed_[this.row_ - i] = ""; void 0 === t && (t = this.row_), this.topRow_ = t - this.rollUpRows_ + 1 }, Ae.prototype.addFormatting = function (e, t) { this.formatting_ = this.formatting_.concat(t); var i = t.reduce((function (e, t) { return e + "<" + t + ">" }), ""); this[this.mode_](e, i) }, Ae.prototype.clearFormatting = function (e) { if (this.formatting_.length) { var t = this.formatting_.reverse().reduce((function (e, t) { return e + "</" + t + ">" }), ""); this.formatting_ = [], this[this.mode_](e, t) } }, Ae.prototype.popOn = function (e, t) { var i = this.nonDisplayed_[this.row_]; i += t, this.nonDisplayed_[this.row_] = i }, Ae.prototype.rollUp = function (e, t) { var i = this.displayed_[this.row_]; i += t, this.displayed_[this.row_] = i }, Ae.prototype.shiftRowsUp_ = function () { var e; for (e = 0; e < this.topRow_; e++)this.displayed_[e] = ""; for (e = this.row_ + 1; e < 15; e++)this.displayed_[e] = ""; for (e = this.topRow_; e < this.row_; e++)this.displayed_[e] = this.displayed_[e + 1]; this.displayed_[this.row_] = "" }, Ae.prototype.paintOn = function (e, t) { var i = this.displayed_[this.row_]; i += t, this.displayed_[this.row_] = i }; var Le = { CaptionStream: ge, Cea608Stream: Ae, Cea708Stream: Te }, ke = { H264_STREAM_TYPE: 27, ADTS_STREAM_TYPE: 15, METADATA_STREAM_TYPE: 21 }, xe = "shared", Pe = function (e, t) { var i = 1; for (e > t && (i = -1); Math.abs(t - e) > 4294967296;)e += 8589934592 * i; return e }, Oe = function e(t) { var i, n; e.prototype.init.call(this), this.type_ = t || xe, this.push = function (e) { this.type_ !== xe && e.type !== this.type_ || (void 0 === n && (n = e.dts), e.dts = Pe(e.dts, n), e.pts = Pe(e.pts, n), i = e.dts, this.trigger("data", e)) }, this.flush = function () { n = i, this.trigger("done") }, this.endTimeline = function () { this.flush(), this.trigger("endedtimeline") }, this.discontinuity = function () { n = void 0, i = void 0 }, this.reset = function () { this.discontinuity(), this.trigger("reset") } }; Oe.prototype = new W; var De, Ce = Oe, Re = Pe, Ue = function (e, t, i) { var n, r = ""; for (n = t; n < i; n++)r += "%" + ("00" + e[n].toString(16)).slice(-2); return r }, Me = function (e, t, i) { return decodeURIComponent(Ue(e, t, i)) }, Be = function (e) { return e[0] << 21 | e[1] << 14 | e[2] << 7 | e[3] }, Fe = { TXXX: function (e) { var t; if (3 === e.data[0]) { for (t = 1; t < e.data.length; t++)if (0 === e.data[t]) { e.description = Me(e.data, 1, t), e.value = Me(e.data, t + 1, e.data.length).replace(/\0*$/, ""); break } e.data = e.value } }, WXXX: function (e) { var t; if (3 === e.data[0]) for (t = 1; t < e.data.length; t++)if (0 === e.data[t]) { e.description = Me(e.data, 1, t), e.url = Me(e.data, t + 1, e.data.length); break } }, PRIV: function (e) { var t, i; for (t = 0; t < e.data.length; t++)if (0 === e.data[t]) { e.owner = (i = e.data, unescape(Ue(i, 0, t))); break } e.privateData = e.data.subarray(t + 1), e.data = e.privateData } }; (De = function (e) { var t, i = { descriptor: e && e.descriptor }, n = 0, r = [], a = 0; if (De.prototype.init.call(this), this.dispatchType = ke.METADATA_STREAM_TYPE.toString(16), i.descriptor) for (t = 0; t < i.descriptor.length; t++)this.dispatchType += ("00" + i.descriptor[t].toString(16)).slice(-2); this.push = function (e) { var t, i, s, o, u; if ("timed-metadata" === e.type) if (e.dataAlignmentIndicator && (a = 0, r.length = 0), 0 === r.length && (e.data.length < 10 || e.data[0] !== "I".charCodeAt(0) || e.data[1] !== "D".charCodeAt(0) || e.data[2] !== "3".charCodeAt(0))) this.trigger("log", { level: "warn", message: "Skipping unrecognized metadata packet" }); else if (r.push(e), a += e.data.byteLength, 1 === r.length && (n = Be(e.data.subarray(6, 10)), n += 10), !(a < n)) { for (t = { data: new Uint8Array(n), frames: [], pts: r[0].pts, dts: r[0].dts }, u = 0; u < n;)t.data.set(r[0].data.subarray(0, n - u), u), u += r[0].data.byteLength, a -= r[0].data.byteLength, r.shift(); i = 10, 64 & t.data[5] && (i += 4, i += Be(t.data.subarray(10, 14)), n -= Be(t.data.subarray(16, 20))); do { if ((s = Be(t.data.subarray(i + 4, i + 8))) < 1) return void this.trigger("log", { level: "warn", message: "Malformed ID3 frame encountered. Skipping metadata parsing." }); if ((o = { id: String.fromCharCode(t.data[i], t.data[i + 1], t.data[i + 2], t.data[i + 3]), data: t.data.subarray(i + 10, i + s + 10) }).key = o.id, Fe[o.id] && (Fe[o.id](o), "com.apple.streaming.transportStreamTimestamp" === o.owner)) { var d = o.data, l = (1 & d[3]) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2; l *= 4, l += 3 & d[7], o.timeStamp = l, void 0 === t.pts && void 0 === t.dts && (t.pts = o.timeStamp, t.dts = o.timeStamp), this.trigger("timestamp", o) } t.frames.push(o), i += 10, i += s } while (i < n); this.trigger("data", t) } } }).prototype = new W; var Ne, qe, We, He = De, Ge = Ce, Ve = 188; (Ne = function () { var e = new Uint8Array(Ve), t = 0; Ne.prototype.init.call(this), this.push = function (i) { var n, r = 0, a = Ve; for (t ? ((n = new Uint8Array(i.byteLength + t)).set(e.subarray(0, t)), n.set(i, t), t = 0) : n = i; a < n.byteLength;)71 !== n[r] || 71 !== n[a] ? (r++, a++) : (this.trigger("data", n.subarray(r, a)), r += Ve, a += Ve); r < n.byteLength && (e.set(n.subarray(r), 0), t = n.byteLength - r) }, this.flush = function () { t === Ve && 71 === e[0] && (this.trigger("data", e), t = 0), this.trigger("done") }, this.endTimeline = function () { this.flush(), this.trigger("endedtimeline") }, this.reset = function () { t = 0, this.trigger("reset") } }).prototype = new W, (qe = function () { var e, t, i, n; qe.prototype.init.call(this), n = this, this.packetsWaitingForPmt = [], this.programMapTable = void 0, e = function (e, n) { var r = 0; n.payloadUnitStartIndicator && (r += e[r] + 1), "pat" === n.type ? t(e.subarray(r), n) : i(e.subarray(r), n) }, t = function (e, t) { t.section_number = e[7], t.last_section_number = e[8], n.pmtPid = (31 & e[10]) << 8 | e[11], t.pmtPid = n.pmtPid }, i = function (e, t) { var i, r; if (1 & e[5]) { for (n.programMapTable = { video: null, audio: null, "timed-metadata": {} }, i = 3 + ((15 & e[1]) << 8 | e[2]) - 4, r = 12 + ((15 & e[10]) << 8 | e[11]); r < i;) { var a = e[r], s = (31 & e[r + 1]) << 8 | e[r + 2]; a === ke.H264_STREAM_TYPE && null === n.programMapTable.video ? n.programMapTable.video = s : a === ke.ADTS_STREAM_TYPE && null === n.programMapTable.audio ? n.programMapTable.audio = s : a === ke.METADATA_STREAM_TYPE && (n.programMapTable["timed-metadata"][s] = a), r += 5 + ((15 & e[r + 3]) << 8 | e[r + 4]) } t.programMapTable = n.programMapTable } }, this.push = function (t) { var i = {}, n = 4; if (i.payloadUnitStartIndicator = !!(64 & t[1]), i.pid = 31 & t[1], i.pid <<= 8, i.pid |= t[2], (48 & t[3]) >>> 4 > 1 && (n += t[n] + 1), 0 === i.pid) i.type = "pat", e(t.subarray(n), i), this.trigger("data", i); else if (i.pid === this.pmtPid) for (i.type = "pmt", e(t.subarray(n), i), this.trigger("data", i); this.packetsWaitingForPmt.length;)this.processPes_.apply(this, this.packetsWaitingForPmt.shift()); else void 0 === this.programMapTable ? this.packetsWaitingForPmt.push([t, n, i]) : this.processPes_(t, n, i) }, this.processPes_ = function (e, t, i) { i.pid === this.programMapTable.video ? i.streamType = ke.H264_STREAM_TYPE : i.pid === this.programMapTable.audio ? i.streamType = ke.ADTS_STREAM_TYPE : i.streamType = this.programMapTable["timed-metadata"][i.pid], i.type = "pes", i.data = e.subarray(t), this.trigger("data", i) } }).prototype = new W, qe.STREAM_TYPES = { h264: 27, adts: 15 }, We = function () { var e, t = this, i = !1, n = { data: [], size: 0 }, r = { data: [], size: 0 }, a = { data: [], size: 0 }, s = function (e, i, n) { var r, a, s = new Uint8Array(e.size), o = { type: i }, u = 0, d = 0; if (e.data.length && !(e.size < 9)) { for (o.trackId = e.data[0].pid, u = 0; u < e.data.length; u++)a = e.data[u], s.set(a.data, d), d += a.data.byteLength; var l, h, c, f; h = o, f = (l = s)[0] << 16 | l[1] << 8 | l[2], h.data = new Uint8Array, 1 === f && (h.packetLength = 6 + (l[4] << 8 | l[5]), h.dataAlignmentIndicator = 0 != (4 & l[6]), 192 & (c = l[7]) && (h.pts = (14 & l[9]) << 27 | (255 & l[10]) << 20 | (254 & l[11]) << 12 | (255 & l[12]) << 5 | (254 & l[13]) >>> 3, h.pts *= 4, h.pts += (6 & l[13]) >>> 1, h.dts = h.pts, 64 & c && (h.dts = (14 & l[14]) << 27 | (255 & l[15]) << 20 | (254 & l[16]) << 12 | (255 & l[17]) << 5 | (254 & l[18]) >>> 3, h.dts *= 4, h.dts += (6 & l[18]) >>> 1)), h.data = l.subarray(9 + l[8])), r = "video" === i || o.packetLength <= e.size, (n || r) && (e.size = 0, e.data.length = 0), r && t.trigger("data", o) } }; We.prototype.init.call(this), this.push = function (o) { ({ pat: function () { }, pes: function () { var e, t; switch (o.streamType) { case ke.H264_STREAM_TYPE: e = n, t = "video"; break; case ke.ADTS_STREAM_TYPE: e = r, t = "audio"; break; case ke.METADATA_STREAM_TYPE: e = a, t = "timed-metadata"; break; default: return }o.payloadUnitStartIndicator && s(e, t, !0), e.data.push(o), e.size += o.data.byteLength }, pmt: function () { var n = { type: "metadata", tracks: [] }; null !== (e = o.programMapTable).video && n.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +e.video, codec: "avc", type: "video" }), null !== e.audio && n.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +e.audio, codec: "adts", type: "audio" }), i = !0, t.trigger("data", n) } })[o.type]() }, this.reset = function () { n.size = 0, n.data.length = 0, r.size = 0, r.data.length = 0, this.trigger("reset") }, this.flushStreams_ = function () { s(n, "video"), s(r, "audio"), s(a, "timed-metadata") }, this.flush = function () { if (!i && e) { var n = { type: "metadata", tracks: [] }; null !== e.video && n.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +e.video, codec: "avc", type: "video" }), null !== e.audio && n.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +e.audio, codec: "adts", type: "audio" }), t.trigger("data", n) } i = !1, this.flushStreams_(), this.trigger("done") } }, We.prototype = new W; var je = { PAT_PID: 0, MP2T_PACKET_LENGTH: Ve, TransportPacketStream: Ne, TransportParseStream: qe, ElementaryStream: We, TimestampRolloverStream: Ge, CaptionStream: Le.CaptionStream, Cea608Stream: Le.Cea608Stream, Cea708Stream: Le.Cea708Stream, MetadataStream: He }; for (var Xe in ke) ke.hasOwnProperty(Xe) && (je[Xe] = ke[Xe]); var Qe, ze = je, Ye = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350]; (Qe = function (e) { var t, i = 0; Qe.prototype.init.call(this), this.skipWarn_ = function (e, t) { this.trigger("log", { level: "warn", message: "adts skiping bytes " + e + " to " + t + " in frame " + i + " outside syncword" }) }, this.push = function (n) { var r, a, s, o, u, d = 0; if (e || (i = 0), "audio" === n.type) { var l; for (t && t.length ? (s = t, (t = new Uint8Array(s.byteLength + n.data.byteLength)).set(s), t.set(n.data, s.byteLength)) : t = n.data; d + 7 < t.length;)if (255 === t[d] && 240 == (246 & t[d + 1])) { if ("number" == typeof l && (this.skipWarn_(l, d), l = null), a = 2 * (1 & ~t[d + 1]), r = (3 & t[d + 3]) << 11 | t[d + 4] << 3 | (224 & t[d + 5]) >> 5, u = 9e4 * (o = 1024 * (1 + (3 & t[d + 6]))) / Ye[(60 & t[d + 2]) >>> 2], t.byteLength - d < r) break; this.trigger("data", { pts: n.pts + i * u, dts: n.dts + i * u, sampleCount: o, audioobjecttype: 1 + (t[d + 2] >>> 6 & 3), channelcount: (1 & t[d + 2]) << 2 | (192 & t[d + 3]) >>> 6, samplerate: Ye[(60 & t[d + 2]) >>> 2], samplingfrequencyindex: (60 & t[d + 2]) >>> 2, samplesize: 16, data: t.subarray(d + 7 + a, d + r) }), i++, d += r } else "number" != typeof l && (l = d), d++; "number" == typeof l && (this.skipWarn_(l, d), l = null), t = t.subarray(d) } }, this.flush = function () { i = 0, this.trigger("done") }, this.reset = function () { t = void 0, this.trigger("reset") }, this.endTimeline = function () { t = void 0, this.trigger("endedtimeline") } }).prototype = new W; var Ke, $e, Je, Ze = Qe, et = function (e) { var t = e.byteLength, i = 0, n = 0; this.length = function () { return 8 * t }, this.bitsAvailable = function () { return 8 * t + n }, this.loadWord = function () { var r = e.byteLength - t, a = new Uint8Array(4), s = Math.min(4, t); if (0 === s) throw new Error("no bytes available"); a.set(e.subarray(r, r + s)), i = new DataView(a.buffer).getUint32(0), n = 8 * s, t -= s }, this.skipBits = function (e) { var r; n > e ? (i <<= e, n -= e) : (e -= n, e -= 8 * (r = Math.floor(e / 8)), t -= r, this.loadWord(), i <<= e, n -= e) }, this.readBits = function (e) { var r = Math.min(n, e), a = i >>> 32 - r; return (n -= r) > 0 ? i <<= r : t > 0 && this.loadWord(), (r = e - r) > 0 ? a << r | this.readBits(r) : a }, this.skipLeadingZeros = function () { var e; for (e = 0; e < n; ++e)if (0 != (i & 2147483648 >>> e)) return i <<= e, n -= e, e; return this.loadWord(), e + this.skipLeadingZeros() }, this.skipUnsignedExpGolomb = function () { this.skipBits(1 + this.skipLeadingZeros()) }, this.skipExpGolomb = function () { this.skipBits(1 + this.skipLeadingZeros()) }, this.readUnsignedExpGolomb = function () { var e = this.skipLeadingZeros(); return this.readBits(e + 1) - 1 }, this.readExpGolomb = function () { var e = this.readUnsignedExpGolomb(); return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1) }, this.readBoolean = function () { return 1 === this.readBits(1) }, this.readUnsignedByte = function () { return this.readBits(8) }, this.loadWord() }; ($e = function () { var e, t, i = 0; $e.prototype.init.call(this), this.push = function (n) { var r; t ? ((r = new Uint8Array(t.byteLength + n.data.byteLength)).set(t), r.set(n.data, t.byteLength), t = r) : t = n.data; for (var a = t.byteLength; i < a - 3; i++)if (1 === t[i + 2]) { e = i + 5; break } for (; e < a;)switch (t[e]) { case 0: if (0 !== t[e - 1]) { e += 2; break } if (0 !== t[e - 2]) { e++; break } i + 3 !== e - 2 && this.trigger("data", t.subarray(i + 3, e - 2)); do { e++ } while (1 !== t[e] && e < a); i = e - 2, e += 3; break; case 1: if (0 !== t[e - 1] || 0 !== t[e - 2]) { e += 3; break } this.trigger("data", t.subarray(i + 3, e - 2)), i = e - 2, e += 3; break; default: e += 3 }t = t.subarray(i), e -= i, i = 0 }, this.reset = function () { t = null, i = 0, this.trigger("reset") }, this.flush = function () { t && t.byteLength > 3 && this.trigger("data", t.subarray(i + 3)), t = null, i = 0, this.trigger("done") }, this.endTimeline = function () { this.flush(), this.trigger("endedtimeline") } }).prototype = new W, Je = { 100: !0, 110: !0, 122: !0, 244: !0, 44: !0, 83: !0, 86: !0, 118: !0, 128: !0, 138: !0, 139: !0, 134: !0 }, Ke = function () { var e, t, i, n, r, a, s, o = new $e; Ke.prototype.init.call(this), e = this, this.push = function (e) { "video" === e.type && (t = e.trackId, i = e.pts, n = e.dts, o.push(e)) }, o.on("data", (function (s) { var o = { trackId: t, pts: i, dts: n, data: s, nalUnitTypeCode: 31 & s[0] }; switch (o.nalUnitTypeCode) { case 5: o.nalUnitType = "slice_layer_without_partitioning_rbsp_idr"; break; case 6: o.nalUnitType = "sei_rbsp", o.escapedRBSP = r(s.subarray(1)); break; case 7: o.nalUnitType = "seq_parameter_set_rbsp", o.escapedRBSP = r(s.subarray(1)), o.config = a(o.escapedRBSP); break; case 8: o.nalUnitType = "pic_parameter_set_rbsp"; break; case 9: o.nalUnitType = "access_unit_delimiter_rbsp" }e.trigger("data", o) })), o.on("done", (function () { e.trigger("done") })), o.on("partialdone", (function () { e.trigger("partialdone") })), o.on("reset", (function () { e.trigger("reset") })), o.on("endedtimeline", (function () { e.trigger("endedtimeline") })), this.flush = function () { o.flush() }, this.partialFlush = function () { o.partialFlush() }, this.reset = function () { o.reset() }, this.endTimeline = function () { o.endTimeline() }, s = function (e, t) { var i, n = 8, r = 8; for (i = 0; i < e; i++)0 !== r && (r = (n + t.readExpGolomb() + 256) % 256), n = 0 === r ? n : r }, r = function (e) { for (var t, i, n = e.byteLength, r = [], a = 1; a < n - 2;)0 === e[a] && 0 === e[a + 1] && 3 === e[a + 2] ? (r.push(a + 2), a += 2) : a++; if (0 === r.length) return e; t = n - r.length, i = new Uint8Array(t); var s = 0; for (a = 0; a < t; s++, a++)s === r[0] && (s++, r.shift()), i[a] = e[s]; return i }, a = function (e) { var t, i, n, r, a, o, u, d, l, h, c, f, p = 0, m = 0, g = 0, y = 0, _ = [1, 1]; if (i = (t = new et(e)).readUnsignedByte(), r = t.readUnsignedByte(), n = t.readUnsignedByte(), t.skipUnsignedExpGolomb(), Je[i] && (3 === (a = t.readUnsignedExpGolomb()) && t.skipBits(1), t.skipUnsignedExpGolomb(), t.skipUnsignedExpGolomb(), t.skipBits(1), t.readBoolean())) for (c = 3 !== a ? 8 : 12, f = 0; f < c; f++)t.readBoolean() && s(f < 6 ? 16 : 64, t); if (t.skipUnsignedExpGolomb(), 0 === (o = t.readUnsignedExpGolomb())) t.readUnsignedExpGolomb(); else if (1 === o) for (t.skipBits(1), t.skipExpGolomb(), t.skipExpGolomb(), u = t.readUnsignedExpGolomb(), f = 0; f < u; f++)t.skipExpGolomb(); if (t.skipUnsignedExpGolomb(), t.skipBits(1), d = t.readUnsignedExpGolomb(), l = t.readUnsignedExpGolomb(), 0 === (h = t.readBits(1)) && t.skipBits(1), t.skipBits(1), t.readBoolean() && (p = t.readUnsignedExpGolomb(), m = t.readUnsignedExpGolomb(), g = t.readUnsignedExpGolomb(), y = t.readUnsignedExpGolomb()), t.readBoolean() && t.readBoolean()) { switch (t.readUnsignedByte()) { case 1: _ = [1, 1]; break; case 2: _ = [12, 11]; break; case 3: _ = [10, 11]; break; case 4: _ = [16, 11]; break; case 5: _ = [40, 33]; break; case 6: _ = [24, 11]; break; case 7: _ = [20, 11]; break; case 8: _ = [32, 11]; break; case 9: _ = [80, 33]; break; case 10: _ = [18, 11]; break; case 11: _ = [15, 11]; break; case 12: _ = [64, 33]; break; case 13: _ = [160, 99]; break; case 14: _ = [4, 3]; break; case 15: _ = [3, 2]; break; case 16: _ = [2, 1]; break; case 255: _ = [t.readUnsignedByte() << 8 | t.readUnsignedByte(), t.readUnsignedByte() << 8 | t.readUnsignedByte()] }_ && (_[0], _[1]) } return { profileIdc: i, levelIdc: n, profileCompatibility: r, width: 16 * (d + 1) - 2 * p - 2 * m, height: (2 - h) * (l + 1) * 16 - 2 * g - 2 * y, sarRatio: _ } } }, Ke.prototype = new W; var tt, it = { H264Stream: Ke, NalByteStream: $e }, nt = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], rt = function (e, t) { var i = e[t + 6] << 21 | e[t + 7] << 14 | e[t + 8] << 7 | e[t + 9]; return i = i >= 0 ? i : 0, (16 & e[t + 5]) >> 4 ? i + 20 : i + 10 }, at = function e(t, i) { return t.length - i < 10 || t[i] !== "I".charCodeAt(0) || t[i + 1] !== "D".charCodeAt(0) || t[i + 2] !== "3".charCodeAt(0) ? i : e(t, i += rt(t, i)) }, st = function (e) { return e[0] << 21 | e[1] << 14 | e[2] << 7 | e[3] }, ot = { isLikelyAacData: function (e) { var t = at(e, 0); return e.length >= t + 2 && 255 == (255 & e[t]) && 240 == (240 & e[t + 1]) && 16 == (22 & e[t + 1]) }, parseId3TagSize: rt, parseAdtsSize: function (e, t) { var i = (224 & e[t + 5]) >> 5, n = e[t + 4] << 3; return 6144 & e[t + 3] | n | i }, parseType: function (e, t) { return e[t] === "I".charCodeAt(0) && e[t + 1] === "D".charCodeAt(0) && e[t + 2] === "3".charCodeAt(0) ? "timed-metadata" : !0 & e[t] && 240 == (240 & e[t + 1]) ? "audio" : null }, parseSampleRate: function (e) { for (var t = 0; t + 5 < e.length;) { if (255 === e[t] && 240 == (246 & e[t + 1])) return nt[(60 & e[t + 2]) >>> 2]; t++ } return null }, parseAacTimestamp: function (e) { var t, i, n; t = 10, 64 & e[5] && (t += 4, t += st(e.subarray(10, 14))); do { if ((i = st(e.subarray(t + 4, t + 8))) < 1) return null; if ("PRIV" === String.fromCharCode(e[t], e[t + 1], e[t + 2], e[t + 3])) { n = e.subarray(t + 10, t + i + 10); for (var r = 0; r < n.byteLength; r++)if (0 === n[r]) { var a = unescape(function (e, t, i) { var n, r = ""; for (n = 0; n < i; n++)r += "%" + ("00" + e[n].toString(16)).slice(-2); return r }(n, 0, r)); if ("com.apple.streaming.transportStreamTimestamp" === a) { var s = n.subarray(r + 1), o = (1 & s[3]) << 30 | s[4] << 22 | s[5] << 14 | s[6] << 6 | s[7] >>> 2; return (o *= 4) + (3 & s[7]) } break } } t += 10, t += i } while (t < e.byteLength); return null } }; (tt = function () { var e = new Uint8Array, t = 0; tt.prototype.init.call(this), this.setTimestamp = function (e) { t = e }, this.push = function (i) { var n, r, a, s, o = 0, u = 0; for (e.length ? (s = e.length, (e = new Uint8Array(i.byteLength + s)).set(e.subarray(0, s)), e.set(i, s)) : e = i; e.length - u >= 3;)if (e[u] !== "I".charCodeAt(0) || e[u + 1] !== "D".charCodeAt(0) || e[u + 2] !== "3".charCodeAt(0)) if (255 != (255 & e[u]) || 240 != (240 & e[u + 1])) u++; else { if (e.length - u < 7) break; if (u + (o = ot.parseAdtsSize(e, u)) > e.length) break; a = { type: "audio", data: e.subarray(u, u + o), pts: t, dts: t }, this.trigger("data", a), u += o } else { if (e.length - u < 10) break; if (u + (o = ot.parseId3TagSize(e, u)) > e.length) break; r = { type: "timed-metadata", data: e.subarray(u, u + o) }, this.trigger("data", r), u += o } n = e.length - u, e = n > 0 ? e.subarray(u) : new Uint8Array }, this.reset = function () { e = new Uint8Array, this.trigger("reset") }, this.endTimeline = function () { e = new Uint8Array, this.trigger("endedtimeline") } }).prototype = new W; var ut, dt, lt, ht, ct = tt, ft = ["audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize"], pt = ["width", "height", "profileIdc", "levelIdc", "profileCompatibility", "sarRatio"], mt = it.H264Stream, gt = ot.isLikelyAacData, yt = function (e, t) { t.stream = e, this.trigger("log", t) }, _t = function (e, t) { for (var i = Object.keys(t), n = 0; n < i.length; n++) { var r = i[n]; "headOfPipeline" !== r && t[r].on && t[r].on("log", yt.bind(e, r)) } }, vt = function (e, t) { var i; if (e.length !== t.length) return !1; for (i = 0; i < e.length; i++)if (e[i] !== t[i]) return !1; return !0 }, bt = function (e, t, i, n, r, a) { return { start: { dts: e, pts: e + (i - t) }, end: { dts: e + (n - t), pts: e + (r - i) }, prependedContentDuration: a, baseMediaDecodeTime: e } }; dt = function (e, t) { var i, n = [], r = 0, a = 0, s = 1 / 0; i = (t = t || {}).firstSequenceNumber || 0, dt.prototype.init.call(this), this.push = function (t) { me(e, t), e && ft.forEach((function (i) { e[i] = t[i] })), n.push(t) }, this.setEarliestDts = function (e) { r = e }, this.setVideoBaseMediaDecodeTime = function (e) { s = e }, this.setAudioAppendStart = function (e) { a = e }, this.flush = function () { var o, u, d, l, h, c, f; 0 !== n.length ? (o = function (e, t, i) { return t.minSegmentDts >= i ? e : (t.minSegmentDts = 1 / 0, e.filter((function (e) { return e.dts >= i && (t.minSegmentDts = Math.min(t.minSegmentDts, e.dts), t.minSegmentPts = t.minSegmentDts, !0) }))) }(n, e, r), e.baseMediaDecodeTime = pe(e, t.keepOriginalTimestamps), f = ce(e, o, a, s), e.samples = function (e) { var t, i, n = []; for (t = 0; t < e.length; t++)i = e[t], n.push({ size: i.data.byteLength, duration: 1024 }); return n }(o), d = Z(function (e) { var t, i, n = 0, r = new Uint8Array(function (e) { var t, i = 0; for (t = 0; t < e.length; t++)i += e[t].data.byteLength; return i }(e)); for (t = 0; t < e.length; t++)i = e[t], r.set(i.data, n), n += i.data.byteLength; return r }(o)), n = [], u = ee(i, [e]), l = new Uint8Array(u.byteLength + d.byteLength), i++, l.set(u), l.set(d, u.byteLength), fe(e), h = Math.ceil(9216e4 / e.samplerate), o.length && (c = o.length * h, this.trigger("segmentTimingInfo", bt(de(e.baseMediaDecodeTime, e.samplerate), o[0].dts, o[0].pts, o[0].dts + c, o[0].pts + c, f || 0)), this.trigger("timingInfo", { start: o[0].pts, end: o[0].pts + c })), this.trigger("data", { track: e, boxes: l }), this.trigger("done", "AudioSegmentStream")) : this.trigger("done", "AudioSegmentStream") }, this.reset = function () { fe(e), n = [], this.trigger("reset") } }, dt.prototype = new W, ut = function (e, t) { var i, n, r, a = [], s = []; i = (t = t || {}).firstSequenceNumber || 0, ut.prototype.init.call(this), delete e.minPTS, this.gopCache_ = [], this.push = function (t) { me(e, t), "seq_parameter_set_rbsp" !== t.nalUnitType || n || (n = t.config, e.sps = [t.data], pt.forEach((function (t) { e[t] = n[t] }), this)), "pic_parameter_set_rbsp" !== t.nalUnitType || r || (r = t.data, e.pps = [t.data]), a.push(t) }, this.flush = function () { for (var n, r, o, u, d, l, h, c, f = 0; a.length && "access_unit_delimiter_rbsp" !== a[0].nalUnitType;)a.shift(); if (0 === a.length) return this.resetStream_(), void this.trigger("done", "VideoSegmentStream"); if (n = function (e) { var t, i, n = [], r = []; for (r.byteLength = 0, r.nalCount = 0, r.duration = 0, n.byteLength = 0, t = 0; t < e.length; t++)"access_unit_delimiter_rbsp" === (i = e[t]).nalUnitType ? (n.length && (n.duration = i.dts - n.dts, r.byteLength += n.byteLength, r.nalCount += n.length, r.duration += n.duration, r.push(n)), (n = [i]).byteLength = i.data.byteLength, n.pts = i.pts, n.dts = i.dts) : ("slice_layer_without_partitioning_rbsp_idr" === i.nalUnitType && (n.keyFrame = !0), n.duration = i.dts - n.dts, n.byteLength += i.data.byteLength, n.push(i)); return r.length && (!n.duration || n.duration <= 0) && (n.duration = r[r.length - 1].duration), r.byteLength += n.byteLength, r.nalCount += n.length, r.duration += n.duration, r.push(n), r }(a), (o = function (e) { var t, i, n = [], r = []; for (n.byteLength = 0, n.nalCount = 0, n.duration = 0, n.pts = e[0].pts, n.dts = e[0].dts, r.byteLength = 0, r.nalCount = 0, r.duration = 0, r.pts = e[0].pts, r.dts = e[0].dts, t = 0; t < e.length; t++)(i = e[t]).keyFrame ? (n.length && (r.push(n), r.byteLength += n.byteLength, r.nalCount += n.nalCount, r.duration += n.duration), (n = [i]).nalCount = i.length, n.byteLength = i.byteLength, n.pts = i.pts, n.dts = i.dts, n.duration = i.duration) : (n.duration += i.duration, n.nalCount += i.length, n.byteLength += i.byteLength, n.push(i)); return r.length && n.duration <= 0 && (n.duration = r[r.length - 1].duration), r.byteLength += n.byteLength, r.nalCount += n.nalCount, r.duration += n.duration, r.push(n), r }(n))[0][0].keyFrame || ((r = this.getGopForFusion_(a[0], e)) ? (f = r.duration, o.unshift(r), o.byteLength += r.byteLength, o.nalCount += r.nalCount, o.pts = r.pts, o.dts = r.dts, o.duration += r.duration) : o = function (e) { var t; return !e[0][0].keyFrame && e.length > 1 && (t = e.shift(), e.byteLength -= t.byteLength, e.nalCount -= t.nalCount, e[0][0].dts = t.dts, e[0][0].pts = t.pts, e[0][0].duration += t.duration), e }(o)), s.length) { var p; if (!(p = t.alignGopsAtEnd ? this.alignGopsAtEnd_(o) : this.alignGopsAtStart_(o))) return this.gopCache_.unshift({ gop: o.pop(), pps: e.pps, sps: e.sps }), this.gopCache_.length = Math.min(6, this.gopCache_.length), a = [], this.resetStream_(), void this.trigger("done", "VideoSegmentStream"); fe(e), o = p } me(e, o), e.samples = function (e, t) { var i, n, r, a, s, o = t || 0, u = []; for (i = 0; i < e.length; i++)for (a = e[i], n = 0; n < a.length; n++)s = a[n], o += (r = te(s, o)).size, u.push(r); return u }(o), d = Z(function (e) { var t, i, n, r, a, s, o = 0, u = e.byteLength, d = e.nalCount, l = new Uint8Array(u + 4 * d), h = new DataView(l.buffer); for (t = 0; t < e.length; t++)for (r = e[t], i = 0; i < r.length; i++)for (a = r[i], n = 0; n < a.length; n++)s = a[n], h.setUint32(o, s.data.byteLength), o += 4, l.set(s.data, o), o += s.data.byteLength; return l }(o)), e.baseMediaDecodeTime = pe(e, t.keepOriginalTimestamps), this.trigger("processedGopsInfo", o.map((function (e) { return { pts: e.pts, dts: e.dts, byteLength: e.byteLength } }))), h = o[0], c = o[o.length - 1], this.trigger("segmentTimingInfo", bt(e.baseMediaDecodeTime, h.dts, h.pts, c.dts + c.duration, c.pts + c.duration, f)), this.trigger("timingInfo", { start: o[0].pts, end: o[o.length - 1].pts + o[o.length - 1].duration }), this.gopCache_.unshift({ gop: o.pop(), pps: e.pps, sps: e.sps }), this.gopCache_.length = Math.min(6, this.gopCache_.length), a = [], this.trigger("baseMediaDecodeTime", e.baseMediaDecodeTime), this.trigger("timelineStartInfo", e.timelineStartInfo), u = ee(i, [e]), l = new Uint8Array(u.byteLength + d.byteLength), i++, l.set(u), l.set(d, u.byteLength), this.trigger("data", { track: e, boxes: l }), this.resetStream_(), this.trigger("done", "VideoSegmentStream") }, this.reset = function () { this.resetStream_(), a = [], this.gopCache_.length = 0, s.length = 0, this.trigger("reset") }, this.resetStream_ = function () { fe(e), n = void 0, r = void 0 }, this.getGopForFusion_ = function (t) { var i, n, r, a, s, o = 1 / 0; for (s = 0; s < this.gopCache_.length; s++)r = (a = this.gopCache_[s]).gop, e.pps && vt(e.pps[0], a.pps[0]) && e.sps && vt(e.sps[0], a.sps[0]) && (r.dts < e.timelineStartInfo.dts || (i = t.dts - r.dts - r.duration) >= -1e4 && i <= 45e3 && (!n || o > i) && (n = a, o = i)); return n ? n.gop : null }, this.alignGopsAtStart_ = function (e) { var t, i, n, r, a, o, u, d; for (a = e.byteLength, o = e.nalCount, u = e.duration, t = i = 0; t < s.length && i < e.length && (n = s[t], r = e[i], n.pts !== r.pts);)r.pts > n.pts ? t++ : (i++, a -= r.byteLength, o -= r.nalCount, u -= r.duration); return 0 === i ? e : i === e.length ? null : ((d = e.slice(i)).byteLength = a, d.duration = u, d.nalCount = o, d.pts = d[0].pts, d.dts = d[0].dts, d) }, this.alignGopsAtEnd_ = function (e) { var t, i, n, r, a, o, u; for (t = s.length - 1, i = e.length - 1, a = null, o = !1; t >= 0 && i >= 0;) { if (n = s[t], r = e[i], n.pts === r.pts) { o = !0; break } n.pts > r.pts ? t-- : (t === s.length - 1 && (a = i), i--) } if (!o && null === a) return null; if (0 === (u = o ? i : a)) return e; var d = e.slice(u), l = d.reduce((function (e, t) { return e.byteLength += t.byteLength, e.duration += t.duration, e.nalCount += t.nalCount, e }), { byteLength: 0, duration: 0, nalCount: 0 }); return d.byteLength = l.byteLength, d.duration = l.duration, d.nalCount = l.nalCount, d.pts = d[0].pts, d.dts = d[0].dts, d }, this.alignGopsWith = function (e) { s = e } }, ut.prototype = new W, ht = function (e, t) { this.numberOfTracks = 0, this.metadataStream = t, void 0 !== (e = e || {}).remux ? this.remuxTracks = !!e.remux : this.remuxTracks = !0, "boolean" == typeof e.keepOriginalTimestamps ? this.keepOriginalTimestamps = e.keepOriginalTimestamps : this.keepOriginalTimestamps = !1, this.pendingTracks = [], this.videoTrack = null, this.pendingBoxes = [], this.pendingCaptions = [], this.pendingMetadata = [], this.pendingBytes = 0, this.emittedTracks = 0, ht.prototype.init.call(this), this.push = function (e) { return e.text ? this.pendingCaptions.push(e) : e.frames ? this.pendingMetadata.push(e) : (this.pendingTracks.push(e.track), this.pendingBytes += e.boxes.byteLength, "video" === e.track.type && (this.videoTrack = e.track, this.pendingBoxes.push(e.boxes)), void ("audio" === e.track.type && (this.audioTrack = e.track, this.pendingBoxes.unshift(e.boxes)))) } }, ht.prototype = new W, ht.prototype.flush = function (e) { var t, i, n, a, s, o, d, l, h = 0, c = { captions: [], captionStreams: {}, metadata: [], info: {} }, f = 0; if (this.pendingTracks.length < this.numberOfTracks) { if ("VideoSegmentStream" !== e && "AudioSegmentStream" !== e) return; if (this.remuxTracks) return; if (0 === this.pendingTracks.length) return this.emittedTracks++, void (this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0)) } if (this.videoTrack ? (f = this.videoTrack.timelineStartInfo.pts, pt.forEach((function (e) { c.info[e] = this.videoTrack[e] }), this)) : this.audioTrack && (f = this.audioTrack.timelineStartInfo.pts, ft.forEach((function (e) { c.info[e] = this.audioTrack[e] }), this)), this.videoTrack || this.audioTrack) { for (1 === this.pendingTracks.length ? c.type = this.pendingTracks[0].type : c.type = "combined", this.emittedTracks += this.pendingTracks.length, s = this.pendingTracks, o = void 0, d = void 0, l = void 0, d = r(), l = u(s), (o = new Uint8Array(d.byteLength + l.byteLength)).set(d), o.set(l, d.byteLength), n = o, c.initSegment = new Uint8Array(n.byteLength), c.initSegment.set(n), c.data = new Uint8Array(this.pendingBytes), a = 0; a < this.pendingBoxes.length; a++)c.data.set(this.pendingBoxes[a], h), h += this.pendingBoxes[a].byteLength; for (a = 0; a < this.pendingCaptions.length; a++)(t = this.pendingCaptions[a]).startTime = he(t.startPts, f, this.keepOriginalTimestamps), t.endTime = he(t.endPts, f, this.keepOriginalTimestamps), c.captionStreams[t.stream] = !0, c.captions.push(t); for (a = 0; a < this.pendingMetadata.length; a++)(i = this.pendingMetadata[a]).cueTime = he(i.pts, f, this.keepOriginalTimestamps), c.metadata.push(i); for (c.metadata.dispatchType = this.metadataStream.dispatchType, this.pendingTracks.length = 0, this.videoTrack = null, this.pendingBoxes.length = 0, this.pendingCaptions.length = 0, this.pendingBytes = 0, this.pendingMetadata.length = 0, this.trigger("data", c), a = 0; a < c.captions.length; a++)t = c.captions[a], this.trigger("caption", t); for (a = 0; a < c.metadata.length; a++)i = c.metadata[a], this.trigger("id3Frame", i) } this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0) }, ht.prototype.setRemux = function (e) { this.remuxTracks = e }, (lt = function (e) { var t, i, n = this, r = !0; lt.prototype.init.call(this), e = e || {}, this.baseMediaDecodeTime = e.baseMediaDecodeTime || 0, this.transmuxPipeline_ = {}, this.setupAacPipeline = function () { var r = {}; this.transmuxPipeline_ = r, r.type = "aac", r.metadataStream = new ze.MetadataStream, r.aacStream = new ct, r.audioTimestampRolloverStream = new ze.TimestampRolloverStream("audio"), r.timedMetadataTimestampRolloverStream = new ze.TimestampRolloverStream("timed-metadata"), r.adtsStream = new Ze, r.coalesceStream = new ht(e, r.metadataStream), r.headOfPipeline = r.aacStream, r.aacStream.pipe(r.audioTimestampRolloverStream).pipe(r.adtsStream), r.aacStream.pipe(r.timedMetadataTimestampRolloverStream).pipe(r.metadataStream).pipe(r.coalesceStream), r.metadataStream.on("timestamp", (function (e) { r.aacStream.setTimestamp(e.timeStamp) })), r.aacStream.on("data", (function (a) { "timed-metadata" !== a.type && "audio" !== a.type || r.audioSegmentStream || (i = i || { timelineStartInfo: { baseMediaDecodeTime: n.baseMediaDecodeTime }, codec: "adts", type: "audio" }, r.coalesceStream.numberOfTracks++, r.audioSegmentStream = new dt(i, e), r.audioSegmentStream.on("log", n.getLogTrigger_("audioSegmentStream")), r.audioSegmentStream.on("timingInfo", n.trigger.bind(n, "audioTimingInfo")), r.adtsStream.pipe(r.audioSegmentStream).pipe(r.coalesceStream), n.trigger("trackinfo", { hasAudio: !!i, hasVideo: !!t })) })), r.coalesceStream.on("data", this.trigger.bind(this, "data")), r.coalesceStream.on("done", this.trigger.bind(this, "done")), _t(this, r) }, this.setupTsPipeline = function () { var r = {}; this.transmuxPipeline_ = r, r.type = "ts", r.metadataStream = new ze.MetadataStream, r.packetStream = new ze.TransportPacketStream, r.parseStream = new ze.TransportParseStream, r.elementaryStream = new ze.ElementaryStream, r.timestampRolloverStream = new ze.TimestampRolloverStream, r.adtsStream = new Ze, r.h264Stream = new mt, r.captionStream = new ze.CaptionStream(e), r.coalesceStream = new ht(e, r.metadataStream), r.headOfPipeline = r.packetStream, r.packetStream.pipe(r.parseStream).pipe(r.elementaryStream).pipe(r.timestampRolloverStream), r.timestampRolloverStream.pipe(r.h264Stream), r.timestampRolloverStream.pipe(r.adtsStream), r.timestampRolloverStream.pipe(r.metadataStream).pipe(r.coalesceStream), r.h264Stream.pipe(r.captionStream).pipe(r.coalesceStream), r.elementaryStream.on("data", (function (a) { var s; if ("metadata" === a.type) { for (s = a.tracks.length; s--;)t || "video" !== a.tracks[s].type ? i || "audio" !== a.tracks[s].type || ((i = a.tracks[s]).timelineStartInfo.baseMediaDecodeTime = n.baseMediaDecodeTime) : (t = a.tracks[s]).timelineStartInfo.baseMediaDecodeTime = n.baseMediaDecodeTime; t && !r.videoSegmentStream && (r.coalesceStream.numberOfTracks++, r.videoSegmentStream = new ut(t, e), r.videoSegmentStream.on("log", n.getLogTrigger_("videoSegmentStream")), r.videoSegmentStream.on("timelineStartInfo", (function (t) { i && !e.keepOriginalTimestamps && (i.timelineStartInfo = t, r.audioSegmentStream.setEarliestDts(t.dts - n.baseMediaDecodeTime)) })), r.videoSegmentStream.on("processedGopsInfo", n.trigger.bind(n, "gopInfo")), r.videoSegmentStream.on("segmentTimingInfo", n.trigger.bind(n, "videoSegmentTimingInfo")), r.videoSegmentStream.on("baseMediaDecodeTime", (function (e) { i && r.audioSegmentStream.setVideoBaseMediaDecodeTime(e) })), r.videoSegmentStream.on("timingInfo", n.trigger.bind(n, "videoTimingInfo")), r.h264Stream.pipe(r.videoSegmentStream).pipe(r.coalesceStream)), i && !r.audioSegmentStream && (r.coalesceStream.numberOfTracks++, r.audioSegmentStream = new dt(i, e), r.audioSegmentStream.on("log", n.getLogTrigger_("audioSegmentStream")), r.audioSegmentStream.on("timingInfo", n.trigger.bind(n, "audioTimingInfo")), r.audioSegmentStream.on("segmentTimingInfo", n.trigger.bind(n, "audioSegmentTimingInfo")), r.adtsStream.pipe(r.audioSegmentStream).pipe(r.coalesceStream)), n.trigger("trackinfo", { hasAudio: !!i, hasVideo: !!t }) } })), r.coalesceStream.on("data", this.trigger.bind(this, "data")), r.coalesceStream.on("id3Frame", (function (e) { e.dispatchType = r.metadataStream.dispatchType, n.trigger("id3Frame", e) })), r.coalesceStream.on("caption", this.trigger.bind(this, "caption")), r.coalesceStream.on("done", this.trigger.bind(this, "done")), _t(this, r) }, this.setBaseMediaDecodeTime = function (n) { var r = this.transmuxPipeline_; e.keepOriginalTimestamps || (this.baseMediaDecodeTime = n), i && (i.timelineStartInfo.dts = void 0, i.timelineStartInfo.pts = void 0, fe(i), r.audioTimestampRolloverStream && r.audioTimestampRolloverStream.discontinuity()), t && (r.videoSegmentStream && (r.videoSegmentStream.gopCache_ = []), t.timelineStartInfo.dts = void 0, t.timelineStartInfo.pts = void 0, fe(t), r.captionStream.reset()), r.timestampRolloverStream && r.timestampRolloverStream.discontinuity() }, this.setAudioAppendStart = function (e) { i && this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(e) }, this.setRemux = function (t) { var i = this.transmuxPipeline_; e.remux = t, i && i.coalesceStream && i.coalesceStream.setRemux(t) }, this.alignGopsWith = function (e) { t && this.transmuxPipeline_.videoSegmentStream && this.transmuxPipeline_.videoSegmentStream.alignGopsWith(e) }, this.getLogTrigger_ = function (e) { var t = this; return function (i) { i.stream = e, t.trigger("log", i) } }, this.push = function (e) { if (r) { var t = gt(e); t && "aac" !== this.transmuxPipeline_.type ? this.setupAacPipeline() : t || "ts" === this.transmuxPipeline_.type || this.setupTsPipeline(), r = !1 } this.transmuxPipeline_.headOfPipeline.push(e) }, this.flush = function () { r = !0, this.transmuxPipeline_.headOfPipeline.flush() }, this.endTimeline = function () { this.transmuxPipeline_.headOfPipeline.endTimeline() }, this.reset = function () { this.transmuxPipeline_.headOfPipeline && this.transmuxPipeline_.headOfPipeline.reset() }, this.resetCaptions = function () { this.transmuxPipeline_.captionStream && this.transmuxPipeline_.captionStream.reset() } }).prototype = new W; var Tt, St, wt, It = { Transmuxer: lt, VideoSegmentStream: ut, AudioSegmentStream: dt, AUDIO_PROPERTIES: ft, VIDEO_PROPERTIES: pt, generateSegmentTimingInfo: bt }, Et = function (e) { return e >>> 0 }, At = function (e) { var t = ""; return t += String.fromCharCode(e[0]), t += String.fromCharCode(e[1]), (t += String.fromCharCode(e[2])) + String.fromCharCode(e[3]) }, Lt = Et, kt = function e(t, i) { var n, r, a, s, o, u = []; if (!i.length) return null; for (n = 0; n < t.byteLength;)r = Lt(t[n] << 24 | t[n + 1] << 16 | t[n + 2] << 8 | t[n + 3]), a = At(t.subarray(n + 4, n + 8)), s = r > 1 ? n + r : t.byteLength, a === i[0] && (1 === i.length ? u.push(t.subarray(n + 8, s)) : (o = e(t.subarray(n + 8, s), i.slice(1))).length && (u = u.concat(o))), n = s; return u }, xt = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, Pt = "undefined" != typeof window ? window : void 0 !== xt ? xt : "undefined" != typeof self ? self : {}, Ot = Et, Dt = function (e) { return ("00" + e.toString(16)).slice(-2) }, Ct = G.getUint64; Tt = function (e, t) { var i = kt(t, ["moof", "traf"]).reduce((function (t, i) { var n, r, a = kt(i, ["tfhd"])[0], s = Ot(a[4] << 24 | a[5] << 16 | a[6] << 8 | a[7]), o = e[s] || 9e4, u = kt(i, ["tfdt"])[0], d = new DataView(u.buffer, u.byteOffset, u.byteLength); return "bigint" == typeof (n = 1 === u[0] ? Ct(u.subarray(4, 12)) : d.getUint32(4)) ? r = n / Pt.BigInt(o) : "number" != typeof n || isNaN(n) || (r = n / o), r < Number.MAX_SAFE_INTEGER && (r = Number(r)), r < t && (t = r), t }), 1 / 0); return "bigint" == typeof i || isFinite(i) ? i : 0 }, wt = function (e) { var t = 0 === e[0] ? 12 : 20; return Ot(e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) }, St = function (e) { var t = kt(e, ["moov", "trak"]), i = []; return t.forEach((function (e) { var t, n, r = {}, a = kt(e, ["tkhd"])[0]; a && (n = (t = new DataView(a.buffer, a.byteOffset, a.byteLength)).getUint8(0), r.id = 0 === n ? t.getUint32(12) : t.getUint32(20)); var s = kt(e, ["mdia", "hdlr"])[0]; if (s) { var o = At(s.subarray(8, 12)); r.type = "vide" === o ? "video" : "soun" === o ? "audio" : o } var u = kt(e, ["mdia", "minf", "stbl", "stsd"])[0]; if (u) { var d = u.subarray(8); r.codec = At(d.subarray(4, 8)); var l, h = kt(d, [r.codec])[0]; h && (/^[asm]vc[1-9]$/i.test(r.codec) ? (l = h.subarray(78), "avcC" === At(l.subarray(4, 8)) && l.length > 11 ? (r.codec += ".", r.codec += Dt(l[9]), r.codec += Dt(l[10]), r.codec += Dt(l[11])) : r.codec = "avc1.4d400d") : /^mp4[a,v]$/i.test(r.codec) ? (l = h.subarray(28), "esds" === At(l.subarray(4, 8)) && l.length > 20 && 0 !== l[19] ? (r.codec += "." + Dt(l[19]), r.codec += "." + Dt(l[20] >>> 2 & 63).replace(/^0/, "")) : r.codec = "mp4a.40.2") : r.codec = r.codec.toLowerCase()) } var c = kt(e, ["mdia", "mdhd"])[0]; c && (r.timescale = wt(c)), i.push(r) })), i }; var Rt = Tt, Ut = St, Mt = function (e) { var t = 31 & e[1]; return (t <<= 8) | e[2] }, Bt = function (e) { return !!(64 & e[1]) }, Ft = function (e) { var t = 0; return (48 & e[3]) >>> 4 > 1 && (t += e[4] + 1), t }, Nt = function (e) { switch (e) { case 5: return "slice_layer_without_partitioning_rbsp_idr"; case 6: return "sei_rbsp"; case 7: return "seq_parameter_set_rbsp"; case 8: return "pic_parameter_set_rbsp"; case 9: return "access_unit_delimiter_rbsp"; default: return null } }, qt = { parseType: function (e, t) { var i = Mt(e); return 0 === i ? "pat" : i === t ? "pmt" : t ? "pes" : null }, parsePat: function (e) { var t = Bt(e), i = 4 + Ft(e); return t && (i += e[i] + 1), (31 & e[i + 10]) << 8 | e[i + 11] }, parsePmt: function (e) { var t = {}, i = Bt(e), n = 4 + Ft(e); if (i && (n += e[n] + 1), 1 & e[n + 5]) { var r; r = 3 + ((15 & e[n + 1]) << 8 | e[n + 2]) - 4; for (var a = 12 + ((15 & e[n + 10]) << 8 | e[n + 11]); a < r;) { var s = n + a; t[(31 & e[s + 1]) << 8 | e[s + 2]] = e[s], a += 5 + ((15 & e[s + 3]) << 8 | e[s + 4]) } return t } }, parsePayloadUnitStartIndicator: Bt, parsePesType: function (e, t) { switch (t[Mt(e)]) { case ke.H264_STREAM_TYPE: return "video"; case ke.ADTS_STREAM_TYPE: return "audio"; case ke.METADATA_STREAM_TYPE: return "timed-metadata"; default: return null } }, parsePesTime: function (e) { if (!Bt(e)) return null; var t = 4 + Ft(e); if (t >= e.byteLength) return null; var i, n = null; return 192 & (i = e[t + 7]) && ((n = {}).pts = (14 & e[t + 9]) << 27 | (255 & e[t + 10]) << 20 | (254 & e[t + 11]) << 12 | (255 & e[t + 12]) << 5 | (254 & e[t + 13]) >>> 3, n.pts *= 4, n.pts += (6 & e[t + 13]) >>> 1, n.dts = n.pts, 64 & i && (n.dts = (14 & e[t + 14]) << 27 | (255 & e[t + 15]) << 20 | (254 & e[t + 16]) << 12 | (255 & e[t + 17]) << 5 | (254 & e[t + 18]) >>> 3, n.dts *= 4, n.dts += (6 & e[t + 18]) >>> 1)), n }, videoPacketContainsKeyFrame: function (e) { for (var t = 4 + Ft(e), i = e.subarray(t), n = 0, r = 0, a = !1; r < i.byteLength - 3; r++)if (1 === i[r + 2]) { n = r + 5; break } for (; n < i.byteLength;)switch (i[n]) { case 0: if (0 !== i[n - 1]) { n += 2; break } if (0 !== i[n - 2]) { n++; break } r + 3 !== n - 2 && "slice_layer_without_partitioning_rbsp_idr" === Nt(31 & i[r + 3]) && (a = !0); do { n++ } while (1 !== i[n] && n < i.length); r = n - 2, n += 3; break; case 1: if (0 !== i[n - 1] || 0 !== i[n - 2]) { n += 3; break } "slice_layer_without_partitioning_rbsp_idr" === Nt(31 & i[r + 3]) && (a = !0), r = n - 2, n += 3; break; default: n += 3 }return i = i.subarray(r), n -= r, r = 0, i && i.byteLength > 3 && "slice_layer_without_partitioning_rbsp_idr" === Nt(31 & i[r + 3]) && (a = !0), a } }, Wt = Re, Ht = {}; Ht.ts = qt, Ht.aac = ot; var Gt = se, Vt = 188, jt = 71, Xt = function (e, t, i) { for (var n, r, a, s, o = 0, u = Vt, d = !1; u <= e.byteLength;)if (e[o] !== jt || e[u] !== jt && u !== e.byteLength) o++, u++; else { if (n = e.subarray(o, u), "pes" === Ht.ts.parseType(n, t.pid) && (r = Ht.ts.parsePesType(n, t.table), a = Ht.ts.parsePayloadUnitStartIndicator(n), "audio" === r && a && (s = Ht.ts.parsePesTime(n)) && (s.type = "audio", i.audio.push(s), d = !0)), d) break; o += Vt, u += Vt } for (o = (u = e.byteLength) - Vt, d = !1; o >= 0;)if (e[o] !== jt || e[u] !== jt && u !== e.byteLength) o--, u--; else { if (n = e.subarray(o, u), "pes" === Ht.ts.parseType(n, t.pid) && (r = Ht.ts.parsePesType(n, t.table), a = Ht.ts.parsePayloadUnitStartIndicator(n), "audio" === r && a && (s = Ht.ts.parsePesTime(n)) && (s.type = "audio", i.audio.push(s), d = !0)), d) break; o -= Vt, u -= Vt } }, Qt = function (e, t, i) { for (var n, r, a, s, o, u, d, l = 0, h = Vt, c = !1, f = { data: [], size: 0 }; h < e.byteLength;)if (e[l] !== jt || e[h] !== jt) l++, h++; else { if (n = e.subarray(l, h), "pes" === Ht.ts.parseType(n, t.pid) && (r = Ht.ts.parsePesType(n, t.table), a = Ht.ts.parsePayloadUnitStartIndicator(n), "video" === r && (a && !c && (s = Ht.ts.parsePesTime(n)) && (s.type = "video", i.video.push(s), c = !0), !i.firstKeyFrame))) { if (a && 0 !== f.size) { for (o = new Uint8Array(f.size), u = 0; f.data.length;)d = f.data.shift(), o.set(d, u), u += d.byteLength; if (Ht.ts.videoPacketContainsKeyFrame(o)) { var p = Ht.ts.parsePesTime(o); p ? (i.firstKeyFrame = p, i.firstKeyFrame.type = "video") : console.warn("Failed to extract PTS/DTS from PES at first keyframe. This could be an unusual TS segment, or else mux.js did not parse your TS segment correctly. If you know your TS segments do contain PTS/DTS on keyframes please file a bug report! You can try ffprobe to double check for yourself.") } f.size = 0 } f.data.push(n), f.size += n.byteLength } if (c && i.firstKeyFrame) break; l += Vt, h += Vt } for (l = (h = e.byteLength) - Vt, c = !1; l >= 0;)if (e[l] !== jt || e[h] !== jt) l--, h--; else { if (n = e.subarray(l, h), "pes" === Ht.ts.parseType(n, t.pid) && (r = Ht.ts.parsePesType(n, t.table), a = Ht.ts.parsePayloadUnitStartIndicator(n), "video" === r && a && (s = Ht.ts.parsePesTime(n)) && (s.type = "video", i.video.push(s), c = !0)), c) break; l -= Vt, h -= Vt } }, zt = function (e, t) { var i; return i = Ht.aac.isLikelyAacData(e) ? function (e) { for (var t, i = !1, n = 0, r = null, a = null, s = 0, o = 0; e.length - o >= 3;) { switch (Ht.aac.parseType(e, o)) { case "timed-metadata": if (e.length - o < 10) { i = !0; break } if ((s = Ht.aac.parseId3TagSize(e, o)) > e.length) { i = !0; break } null === a && (t = e.subarray(o, o + s), a = Ht.aac.parseAacTimestamp(t)), o += s; break; case "audio": if (e.length - o < 7) { i = !0; break } if ((s = Ht.aac.parseAdtsSize(e, o)) > e.length) { i = !0; break } null === r && (t = e.subarray(o, o + s), r = Ht.aac.parseSampleRate(t)), n++, o += s; break; default: o++ }if (i) return null } if (null === r || null === a) return null; var u = Gt / r; return { audio: [{ type: "audio", dts: a, pts: a }, { type: "audio", dts: a + 1024 * n * u, pts: a + 1024 * n * u }] } }(e) : function (e) { var t = { pid: null, table: null }, i = {}; for (var n in function (e, t) { for (var i, n = 0, r = Vt; r < e.byteLength;)if (e[n] !== jt || e[r] !== jt) n++, r++; else { switch (i = e.subarray(n, r), Ht.ts.parseType(i, t.pid)) { case "pat": t.pid = Ht.ts.parsePat(i); break; case "pmt": var a = Ht.ts.parsePmt(i); t.table = t.table || {}, Object.keys(a).forEach((function (e) { t.table[e] = a[e] })) }n += Vt, r += Vt } }(e, t), t.table) if (t.table.hasOwnProperty(n)) switch (t.table[n]) { case ke.H264_STREAM_TYPE: i.video = [], Qt(e, t, i), 0 === i.video.length && delete i.video; break; case ke.ADTS_STREAM_TYPE: i.audio = [], Xt(e, t, i), 0 === i.audio.length && delete i.audio }return i }(e), i && (i.audio || i.video) ? (function (e, t) { if (e.audio && e.audio.length) { var i = t; (void 0 === i || isNaN(i)) && (i = e.audio[0].dts), e.audio.forEach((function (e) { e.dts = Wt(e.dts, i), e.pts = Wt(e.pts, i), e.dtsTime = e.dts / Gt, e.ptsTime = e.pts / Gt })) } if (e.video && e.video.length) { var n = t; if ((void 0 === n || isNaN(n)) && (n = e.video[0].dts), e.video.forEach((function (e) { e.dts = Wt(e.dts, n), e.pts = Wt(e.pts, n), e.dtsTime = e.dts / Gt, e.ptsTime = e.pts / Gt })), e.firstKeyFrame) { var r = e.firstKeyFrame; r.dts = Wt(r.dts, n), r.pts = Wt(r.pts, n), r.dtsTime = r.dts / Gt, r.ptsTime = r.pts / Gt } } }(i, t), i) : null }, Yt = function () { function e(e, t) { this.options = t || {}, this.self = e, this.init() } var t = e.prototype; return t.init = function () { this.transmuxer && this.transmuxer.dispose(), this.transmuxer = new It.Transmuxer(this.options), function (e, t) { t.on("data", (function (t) { var i = t.initSegment; t.initSegment = { data: i.buffer, byteOffset: i.byteOffset, byteLength: i.byteLength }; var n = t.data; t.data = n.buffer, e.postMessage({ action: "data", segment: t, byteOffset: n.byteOffset, byteLength: n.byteLength }, [t.data]) })), t.on("done", (function (t) { e.postMessage({ action: "done" }) })), t.on("gopInfo", (function (t) { e.postMessage({ action: "gopInfo", gopInfo: t }) })), t.on("videoSegmentTimingInfo", (function (t) { var i = { start: { decode: ue(t.start.dts), presentation: ue(t.start.pts) }, end: { decode: ue(t.end.dts), presentation: ue(t.end.pts) }, baseMediaDecodeTime: ue(t.baseMediaDecodeTime) }; t.prependedContentDuration && (i.prependedContentDuration = ue(t.prependedContentDuration)), e.postMessage({ action: "videoSegmentTimingInfo", videoSegmentTimingInfo: i }) })), t.on("audioSegmentTimingInfo", (function (t) { var i = { start: { decode: ue(t.start.dts), presentation: ue(t.start.pts) }, end: { decode: ue(t.end.dts), presentation: ue(t.end.pts) }, baseMediaDecodeTime: ue(t.baseMediaDecodeTime) }; t.prependedContentDuration && (i.prependedContentDuration = ue(t.prependedContentDuration)), e.postMessage({ action: "audioSegmentTimingInfo", audioSegmentTimingInfo: i }) })), t.on("id3Frame", (function (t) { e.postMessage({ action: "id3Frame", id3Frame: t }) })), t.on("trackinfo", (function (t) { e.postMessage({ action: "trackinfo", trackInfo: t }) })), t.on("audioTimingInfo", (function (t) { e.postMessage({ action: "audioTimingInfo", audioTimingInfo: { start: ue(t.start), end: ue(t.end) } }) })), t.on("videoTimingInfo", (function (t) { e.postMessage({ action: "videoTimingInfo", videoTimingInfo: { start: ue(t.start), end: ue(t.end) } }) })), t.on("log", (function (t) { e.postMessage({ action: "log", log: t }) })) }(this.self, this.transmuxer) }, t.probeMp4StartTime = function (e) { var t = e.timescales, i = e.data, n = Rt(t, i); this.self.postMessage({ action: "probeMp4StartTime", startTime: n, data: i }, [i.buffer]) }, t.probeMp4Tracks = function (e) { var t = e.data, i = Ut(t); this.self.postMessage({ action: "probeMp4Tracks", tracks: i, data: t }, [t.buffer]) }, t.probeTs = function (e) { var t = e.data, i = e.baseStartTime, n = "number" != typeof i || isNaN(i) ? void 0 : i * se, r = zt(t, n), a = null; r && ((a = { hasVideo: r.video && 2 === r.video.length || !1, hasAudio: r.audio && 2 === r.audio.length || !1 }).hasVideo && (a.videoStart = r.video[0].ptsTime), a.hasAudio && (a.audioStart = r.audio[0].ptsTime)), this.self.postMessage({ action: "probeTs", result: a, data: t }, [t.buffer]) }, t.push = function (e) { var t = new Uint8Array(e.data, e.byteOffset, e.byteLength); this.transmuxer.push(t) }, t.reset = function () { this.transmuxer.reset() }, t.setTimestampOffset = function (e) { var t = e.timestampOffset || 0; this.transmuxer.setBaseMediaDecodeTime(Math.round(oe(t))) }, t.setAudioAppendStart = function (e) { this.transmuxer.setAudioAppendStart(Math.ceil(oe(e.appendStart))) }, t.setRemux = function (e) { this.transmuxer.setRemux(e.remux) }, t.flush = function (e) { this.transmuxer.flush(), self.postMessage({ action: "done", type: "transmuxed" }) }, t.endTimeline = function () { this.transmuxer.endTimeline(), self.postMessage({ action: "endedtimeline", type: "transmuxed" }) }, t.alignGopsWith = function (e) { this.transmuxer.alignGopsWith(e.gopsToAlignWith.slice()) }, e }(); self.onmessage = function (e) { "init" === e.data.action && e.data.options ? this.messageHandlers = new Yt(self, e.data.options) : (this.messageHandlers || (this.messageHandlers = new Yt(self)), e.data && e.data.action && "init" !== e.data.action && this.messageHandlers[e.data.action] && this.messageHandlers[e.data.action](e.data)) } }))), Ke = Xe(Ye), $e = function (e) { var t = e.transmuxer, i = e.bytes, n = e.audioAppendStart, r = e.gopsToAlignWith, a = e.remux, s = e.onData, o = e.onTrackInfo, u = e.onAudioTimingInfo, d = e.onVideoTimingInfo, l = e.onVideoSegmentTimingInfo, h = e.onAudioSegmentTimingInfo, c = e.onId3, f = e.onDone, p = e.onEndedTimeline, m = e.onTransmuxerLog, g = e.isEndOfTimeline, y = { buffer: [] }, _ = g; if (t.onmessage = function (i) { t.currentTransmux === e && ("data" === i.data.action && function (e, t, i) { var n = e.data.segment, r = n.type, a = n.initSegment, s = n.metadata, o = n.videoFrameDtsTime, u = n.videoFramePtsTime; t.buffer.push({ metadata: s }); var d = e.data.segment.boxes || { data: e.data.segment.data }, l = { type: r, data: new Uint8Array(d.data, d.data.byteOffset, d.data.byteLength), initSegment: new Uint8Array(a.data, a.byteOffset, a.byteLength) }; void 0 !== o && (l.videoFrameDtsTime = o), void 0 !== u && (l.videoFramePtsTime = u), i(l) }(i, y, s), "trackinfo" === i.data.action && o(i.data.trackInfo), "gopInfo" === i.data.action && function (e, t) { t.gopInfo = e.data.gopInfo }(i, y), "audioTimingInfo" === i.data.action && u(i.data.audioTimingInfo), "videoTimingInfo" === i.data.action && d(i.data.videoTimingInfo), "videoSegmentTimingInfo" === i.data.action && l(i.data.videoSegmentTimingInfo), "audioSegmentTimingInfo" === i.data.action && h(i.data.audioSegmentTimingInfo), "id3Frame" === i.data.action && c([i.data.id3Frame], i.data.id3Frame.dispatchType), "endedtimeline" === i.data.action && (_ = !1, p()), "log" === i.data.action && m(i.data.log), "transmuxed" === i.data.type && (_ || (t.onmessage = null, function (e) { var t = e.transmuxedData, i = e.callback; t.buffer = [], i(t) }({ transmuxedData: y, callback: f }), Je(t)))) }, n && t.postMessage({ action: "setAudioAppendStart", appendStart: n }), Array.isArray(r) && t.postMessage({ action: "alignGopsWith", gopsToAlignWith: r }), void 0 !== a && t.postMessage({ action: "setRemux", remux: a }), i.byteLength) { var v = i instanceof ArrayBuffer ? i : i.buffer, b = i instanceof ArrayBuffer ? 0 : i.byteOffset; t.postMessage({ action: "push", data: v, byteOffset: b, byteLength: i.byteLength }, [v]) } g && t.postMessage({ action: "endTimeline" }), t.postMessage({ action: "flush" }) }, Je = function (e) { e.currentTransmux = null, e.transmuxQueue.length && (e.currentTransmux = e.transmuxQueue.shift(), "function" == typeof e.currentTransmux ? e.currentTransmux() : $e(e.currentTransmux)) }, Ze = function (e, t) { e.postMessage({ action: t }), Je(e) }, et = function (e) { !function (e, t) { if (!t.currentTransmux) return t.currentTransmux = e, void Ze(t, e); t.transmuxQueue.push(Ze.bind(null, t, e)) }("reset", e) }, tt = function (e) { var t = e.transmuxer, i = e.endAction || e.action, n = e.callback, r = f({}, e, { endAction: null, transmuxer: null, callback: null }); if (t.addEventListener("message", (function r(a) { a.data.action === i && (t.removeEventListener("message", r), a.data.data && (a.data.data = new Uint8Array(a.data.data, e.byteOffset || 0, e.byteLength || a.data.data.byteLength), e.data && (e.data = a.data.data)), n(a.data)) })), e.data) { var a = e.data instanceof ArrayBuffer; r.byteOffset = a ? 0 : e.data.byteOffset, r.byteLength = e.data.byteLength; var s = [a ? e.data : e.data.buffer]; t.postMessage(r, s) } else t.postMessage(r) }, it = function (e) { return "string" == typeof e ? function (e, t) { if ("string" != typeof e && e && "function" == typeof e.toString && (e = e.toString()), "string" != typeof e) return new Uint8Array; e = unescape(encodeURIComponent(e)); for (var i = new Uint8Array(e.length), n = 0; n < e.length; n++)i[n] = e.charCodeAt(n); return i }(e) : e }, nt = function e(t, i, n) { void 0 === n && (n = !1), i = function (e) { return Array.isArray(e) ? e.map((function (e) { return it(e) })) : [it(e)] }(i), t = Pe(t); var r = []; if (!i.length) return r; for (var a = 0; a < t.length;) { var s = (t[a] << 24 | t[a + 1] << 16 | t[a + 2] << 8 | t[a + 3]) >>> 0, o = t.subarray(a + 4, a + 8); if (0 === s) break; var u = a + s; if (u > t.length) { if (n) break; u = t.length } var d = t.subarray(a + 8, u); Re(o, i[0]) && (1 === i.length ? r.push(d) : r.push.apply(r, e(d, i.slice(1), n))), a = u } return r }, rt = { EBML: Pe([26, 69, 223, 163]), DocType: Pe([66, 130]), Segment: Pe([24, 83, 128, 103]), SegmentInfo: Pe([21, 73, 169, 102]), Tracks: Pe([22, 84, 174, 107]), Track: Pe([174]), TrackNumber: Pe([215]), DefaultDuration: Pe([35, 227, 131]), TrackEntry: Pe([174]), TrackType: Pe([131]), FlagDefault: Pe([136]), CodecID: Pe([134]), CodecPrivate: Pe([99, 162]), VideoTrack: Pe([224]), AudioTrack: Pe([225]), Cluster: Pe([31, 67, 182, 117]), Timestamp: Pe([231]), TimestampScale: Pe([42, 215, 177]), BlockGroup: Pe([160]), BlockDuration: Pe([155]), Block: Pe([161]), SimpleBlock: Pe([163]) }, at = [128, 64, 32, 16, 8, 4, 2, 1], st = function (e, t, i, n) { void 0 === i && (i = !0), void 0 === n && (n = !1); var r = function (e) { for (var t = 1, i = 0; i < at.length && !(e & at[i]); i++)t++; return t }(e[t]), a = e.subarray(t, t + r); return i && ((a = Array.prototype.slice.call(e, t, t + r))[0] ^= at[r - 1]), { length: r, value: Ce(a, { signed: n }), bytes: a } }, ot = function e(t) { return "string" == typeof t ? t.match(/.{1,2}/g).map((function (t) { return e(t) })) : "number" == typeof t ? function (e, t) { var i = (void 0 === t ? {} : t).le, n = void 0 !== i && i; ("bigint" != typeof e && "number" != typeof e || "number" == typeof e && e != e) && (e = 0); for (var r, a = (r = e = Oe(e), Math.ceil(function (e) { return e.toString(2).length }(r) / 8)), s = new Uint8Array(new ArrayBuffer(a)), o = 0; o < a; o++) { var u = n ? o : Math.abs(o + 1 - s.length); s[u] = Number(e / De[o] & Oe(255)), e < 0 && (s[u] = Math.abs(~s[u]), s[u] -= 0 === o ? 1 : 2) } return s }(t) : t }, ut = function e(t, i, n) { if (n >= i.length) return i.length; var r = st(i, n, !1); if (Re(t.bytes, r.bytes)) return n; var a = st(i, n + r.length); return e(t, i, n + a.length + a.value + r.length) }, dt = function e(t, i) { i = function (e) { return Array.isArray(e) ? e.map((function (e) { return ot(e) })) : [ot(e)] }(i), t = Pe(t); var n = []; if (!i.length) return n; for (var r = 0; r < t.length;) { var a = st(t, r, !1), s = st(t, r + a.length), o = r + a.length + s.length; 127 === s.value && (s.value = ut(a, t, o), s.value !== t.length && (s.value -= o)); var u = o + s.value > t.length ? t.length : o + s.value, d = t.subarray(o, u); Re(i[0], a.bytes) && (1 === i.length ? n.push(d) : n = n.concat(e(d, i.slice(1)))), r += a.length + s.length + d.length } return n }, lt = Pe([73, 68, 51]), ht = function e(t, i) { return void 0 === i && (i = 0), (t = Pe(t)).length - i < 10 || !Re(t, lt, { offset: i }) ? i : (i += function (e, t) { void 0 === t && (t = 0); var i = (e = Pe(e))[t + 5], n = e[t + 6] << 21 | e[t + 7] << 14 | e[t + 8] << 7 | e[t + 9]; return (16 & i) >> 4 ? n + 20 : n + 10 }(t, i), e(t, i)) }, ct = Pe([0, 0, 0, 1]), ft = Pe([0, 0, 1]), pt = Pe([0, 0, 3]), mt = function (e) { for (var t = [], i = 1; i < e.length - 2;)Re(e.subarray(i, i + 3), pt) && (t.push(i + 2), i++), i++; if (0 === t.length) return e; var n = e.length - t.length, r = new Uint8Array(n), a = 0; for (i = 0; i < n; a++, i++)a === t[0] && (a++, t.shift()), r[i] = e[a]; return r }, gt = function (e, t, i, n) { void 0 === n && (n = 1 / 0), e = Pe(e), i = [].concat(i); for (var r, a = 0, s = 0; a < e.length && (s < n || r);) { var o = void 0; if (Re(e.subarray(a), ct) ? o = 4 : Re(e.subarray(a), ft) && (o = 3), o) { if (s++, r) return mt(e.subarray(r, a)); var u = void 0; "h264" === t ? u = 31 & e[a + o] : "h265" === t && (u = e[a + o] >> 1 & 63), -1 !== i.indexOf(u) && (r = a + o), a += o + ("h264" === t ? 1 : 2) } else a++ } return e.subarray(0, 0) }, yt = { webm: Pe([119, 101, 98, 109]), matroska: Pe([109, 97, 116, 114, 111, 115, 107, 97]), flac: Pe([102, 76, 97, 67]), ogg: Pe([79, 103, 103, 83]), ac3: Pe([11, 119]), riff: Pe([82, 73, 70, 70]), avi: Pe([65, 86, 73]), wav: Pe([87, 65, 86, 69]), "3gp": Pe([102, 116, 121, 112, 51, 103]), mp4: Pe([102, 116, 121, 112]), fmp4: Pe([115, 116, 121, 112]), mov: Pe([102, 116, 121, 112, 113, 116]), moov: Pe([109, 111, 111, 118]), moof: Pe([109, 111, 111, 102]) }, _t = { aac: function (e) { var t = ht(e); return Re(e, [255, 16], { offset: t, mask: [255, 22] }) }, mp3: function (e) { var t = ht(e); return Re(e, [255, 2], { offset: t, mask: [255, 6] }) }, webm: function (e) { var t = dt(e, [rt.EBML, rt.DocType])[0]; return Re(t, yt.webm) }, mkv: function (e) { var t = dt(e, [rt.EBML, rt.DocType])[0]; return Re(t, yt.matroska) }, mp4: function (e) { return !_t["3gp"](e) && !_t.mov(e) && (!(!Re(e, yt.mp4, { offset: 4 }) && !Re(e, yt.fmp4, { offset: 4 })) || !(!Re(e, yt.moof, { offset: 4 }) && !Re(e, yt.moov, { offset: 4 })) || void 0) }, mov: function (e) { return Re(e, yt.mov, { offset: 4 }) }, "3gp": function (e) { return Re(e, yt["3gp"], { offset: 4 }) }, ac3: function (e) { var t = ht(e); return Re(e, yt.ac3, { offset: t }) }, ts: function (e) { if (e.length < 189 && e.length >= 1) return 71 === e[0]; for (var t = 0; t + 188 < e.length && t < 188;) { if (71 === e[t] && 71 === e[t + 188]) return !0; t += 1 } return !1 }, flac: function (e) { var t = ht(e); return Re(e, yt.flac, { offset: t }) }, ogg: function (e) { return Re(e, yt.ogg) }, avi: function (e) { return Re(e, yt.riff) && Re(e, yt.avi, { offset: 8 }) }, wav: function (e) { return Re(e, yt.riff) && Re(e, yt.wav, { offset: 8 }) }, h264: function (e) { return function (e, t, i) { return gt(e, "h264", 7, 3) }(e).length }, h265: function (e) { return function (e, t, i) { return gt(e, "h265", [32, 33], 3) }(e).length } }, vt = Object.keys(_t).filter((function (e) { return "ts" !== e && "h264" !== e && "h265" !== e })).concat(["ts", "h264", "h265"]); vt.forEach((function (e) { var t = _t[e]; _t[e] = function (e) { return t(Pe(e)) } })); var bt = _t, Tt = function (e) { e = Pe(e); for (var t = 0; t < vt.length; t++) { var i = vt[t]; if (bt[i](e)) return i } return "" }, St = function (e) { e.forEach((function (e) { e.abort() })) }, wt = function (e, t) { return t.timedout ? { status: t.status, message: "HLS request timed-out at URL: " + t.uri, code: -101, xhr: t } : t.aborted ? { status: t.status, message: "HLS request aborted at URL: " + t.uri, code: -102, xhr: t } : e ? { status: t.status, message: "HLS request errored at URL: " + t.uri, code: 2, xhr: t } : "arraybuffer" === t.responseType && 0 === t.response.byteLength ? { status: t.status, message: "Empty HLS response at URL: " + t.uri, code: 2, xhr: t } : null }, It = function (e, t, i) { return function (n, r) { var a = r.response, s = wt(n, r); if (s) return i(s, e); if (16 !== a.byteLength) return i({ status: r.status, message: "Invalid HLS key at URL: " + r.uri, code: 2, xhr: r }, e); for (var o = new DataView(a), u = new Uint32Array([o.getUint32(0), o.getUint32(4), o.getUint32(8), o.getUint32(12)]), d = 0; d < t.length; d++)t[d].bytes = u; return i(null, e) } }, Et = function (e, t) { var i = Tt(e.map.bytes); if ("mp4" !== i) { var n = e.map.resolvedUri || e.map.uri; return t({ internal: !0, message: "Found unsupported " + (i || "unknown") + " container for initialization segment at URL: " + n, code: 2 }) } tt({ action: "probeMp4Tracks", data: e.map.bytes, transmuxer: e.transmuxer, callback: function (i) { var n = i.tracks, r = i.data; return e.map.bytes = r, n.forEach((function (t) { e.map.tracks = e.map.tracks || {}, e.map.tracks[t.type] || (e.map.tracks[t.type] = t, "number" == typeof t.id && t.timescale && (e.map.timescales = e.map.timescales || {}, e.map.timescales[t.id] = t.timescale)) })), t(null) } }) }, At = function (e) { var t = e.segment, i = e.bytes, n = e.trackInfoFn, r = e.timingInfoFn, a = e.videoSegmentTimingInfoFn, s = e.audioSegmentTimingInfoFn, o = e.id3Fn, u = e.isEndOfTimeline, d = e.endedTimelineFn, l = e.dataFn, h = e.doneFn, c = e.onTransmuxerLog, f = t.map && t.map.tracks || {}, p = Boolean(f.audio && f.video), m = r.bind(null, t, "audio", "start"), g = r.bind(null, t, "audio", "end"), y = r.bind(null, t, "video", "start"), _ = r.bind(null, t, "video", "end"); tt({ action: "probeTs", transmuxer: t.transmuxer, data: i, baseStartTime: t.baseStartTime, callback: function (e) { t.bytes = i = e.data; var r = e.result; r && (n(t, { hasAudio: r.hasAudio, hasVideo: r.hasVideo, isMuxed: p }), n = null, r.hasAudio && !p && m(r.audioStart), r.hasVideo && y(r.videoStart), m = null, y = null), function (e) { if (!e.transmuxer.currentTransmux) return e.transmuxer.currentTransmux = e, void $e(e); e.transmuxer.transmuxQueue.push(e) }({ bytes: i, transmuxer: t.transmuxer, audioAppendStart: t.audioAppendStart, gopsToAlignWith: t.gopsToAlignWith, remux: p, onData: function (e) { e.type = "combined" === e.type ? "video" : e.type, l(t, e) }, onTrackInfo: function (e) { n && (p && (e.isMuxed = !0), n(t, e)) }, onAudioTimingInfo: function (e) { m && void 0 !== e.start && (m(e.start), m = null), g && void 0 !== e.end && g(e.end) }, onVideoTimingInfo: function (e) { y && void 0 !== e.start && (y(e.start), y = null), _ && void 0 !== e.end && _(e.end) }, onVideoSegmentTimingInfo: function (e) { a(e) }, onAudioSegmentTimingInfo: function (e) { s(e) }, onId3: function (e, i) { o(t, e, i) }, isEndOfTimeline: u, onEndedTimeline: function () { d() }, onTransmuxerLog: c, onDone: function (e) { h && (e.type = "combined" === e.type ? "video" : e.type, h(null, t, e)) } }) } }) }, Lt = function (e) { var t = e.segment, i = e.bytes, n = e.trackInfoFn, r = e.timingInfoFn, a = e.videoSegmentTimingInfoFn, s = e.audioSegmentTimingInfoFn, o = e.id3Fn, u = e.isEndOfTimeline, d = e.endedTimelineFn, l = e.dataFn, h = e.doneFn, c = e.onTransmuxerLog, f = new Uint8Array(i); if (function (e) { return nt(e, ["moof"]).length > 0 }(f)) { t.isFmp4 = !0; var p = t.map.tracks, m = { isFmp4: !0, hasVideo: !!p.video, hasAudio: !!p.audio }; p.audio && p.audio.codec && "enca" !== p.audio.codec && (m.audioCodec = p.audio.codec), p.video && p.video.codec && "encv" !== p.video.codec && (m.videoCodec = p.video.codec), p.video && p.audio && (m.isMuxed = !0), n(t, m), tt({ action: "probeMp4StartTime", timescales: t.map.timescales, data: f, transmuxer: t.transmuxer, callback: function (e) { var n = e.data, a = e.startTime; if (i = n.buffer, t.bytes = f = n, m.hasAudio && !m.isMuxed && r(t, "audio", "start", a), m.hasVideo && r(t, "video", "start", a), !p.video || !n.byteLength || !t.transmuxer) return l(t, { data: f, type: m.hasAudio && !m.isMuxed ? "audio" : "video" }), void h(null, t, {}) } }) } else if (t.transmuxer) { if (void 0 === t.container && (t.container = Tt(f)), "ts" !== t.container && "aac" !== t.container) return n(t, { hasAudio: !1, hasVideo: !1 }), void h(null, t, {}); At({ segment: t, bytes: i, trackInfoFn: n, timingInfoFn: r, videoSegmentTimingInfoFn: a, audioSegmentTimingInfoFn: s, id3Fn: o, isEndOfTimeline: u, endedTimelineFn: d, dataFn: l, doneFn: h, onTransmuxerLog: c }) } else h(null, t, {}) }, kt = function (e, t) { var i, n = e.id, r = e.key, a = e.encryptedBytes, s = e.decryptionWorker; s.addEventListener("message", (function e(i) { if (i.data.source === n) { s.removeEventListener("message", e); var r = i.data.decrypted; t(new Uint8Array(r.bytes, r.byteOffset, r.byteLength)) } })), i = r.bytes.slice ? r.bytes.slice() : new Uint32Array(Array.prototype.slice.call(r.bytes)), s.postMessage(Fe({ source: n, encrypted: a, key: i, iv: r.iv }), [a.buffer, i.buffer]) }, xt = function (e) { var t = e.xhr, i = e.xhrOptions, r = e.decryptionWorker, a = e.segment, s = e.abortFn, o = e.progressFn, u = e.trackInfoFn, d = e.timingInfoFn, l = e.videoSegmentTimingInfoFn, h = e.audioSegmentTimingInfoFn, c = e.id3Fn, f = e.isEndOfTimeline, p = e.endedTimelineFn, m = e.dataFn, g = e.doneFn, y = e.onTransmuxerLog, _ = [], v = function (e) { var t = e.activeXhrs, i = e.decryptionWorker, n = e.trackInfoFn, r = e.timingInfoFn, a = e.videoSegmentTimingInfoFn, s = e.audioSegmentTimingInfoFn, o = e.id3Fn, u = e.isEndOfTimeline, d = e.endedTimelineFn, l = e.dataFn, h = e.doneFn, c = e.onTransmuxerLog, f = 0, p = !1; return function (e, m) { if (!p) { if (e) return p = !0, St(t), h(e, m); if ((f += 1) === t.length) { var g = function () { if (m.encryptedBytes) return function (e) { var t = e.decryptionWorker, i = e.segment, n = e.trackInfoFn, r = e.timingInfoFn, a = e.videoSegmentTimingInfoFn, s = e.audioSegmentTimingInfoFn, o = e.id3Fn, u = e.isEndOfTimeline, d = e.endedTimelineFn, l = e.dataFn, h = e.doneFn, c = e.onTransmuxerLog; kt({ id: i.requestId, key: i.key, encryptedBytes: i.encryptedBytes, decryptionWorker: t }, (function (e) { i.bytes = e, Lt({ segment: i, bytes: i.bytes, trackInfoFn: n, timingInfoFn: r, videoSegmentTimingInfoFn: a, audioSegmentTimingInfoFn: s, id3Fn: o, isEndOfTimeline: u, endedTimelineFn: d, dataFn: l, doneFn: h, onTransmuxerLog: c }) })) }({ decryptionWorker: i, segment: m, trackInfoFn: n, timingInfoFn: r, videoSegmentTimingInfoFn: a, audioSegmentTimingInfoFn: s, id3Fn: o, isEndOfTimeline: u, endedTimelineFn: d, dataFn: l, doneFn: h, onTransmuxerLog: c }); Lt({ segment: m, bytes: m.bytes, trackInfoFn: n, timingInfoFn: r, videoSegmentTimingInfoFn: a, audioSegmentTimingInfoFn: s, id3Fn: o, isEndOfTimeline: u, endedTimelineFn: d, dataFn: l, doneFn: h, onTransmuxerLog: c }) }; if (m.endOfAllRequests = Date.now(), m.map && m.map.encryptedBytes && !m.map.bytes) return kt({ decryptionWorker: i, id: m.requestId + "-init", encryptedBytes: m.map.encryptedBytes, key: m.map.key }, (function (e) { m.map.bytes = e, Et(m, (function (e) { if (e) return St(t), h(e, m); g() })) })); g() } } } }({ activeXhrs: _, decryptionWorker: r, trackInfoFn: u, timingInfoFn: d, videoSegmentTimingInfoFn: l, audioSegmentTimingInfoFn: h, id3Fn: c, isEndOfTimeline: f, endedTimelineFn: p, dataFn: m, doneFn: g, onTransmuxerLog: y }); if (a.key && !a.key.bytes) { var b = [a.key]; a.map && !a.map.bytes && a.map.key && a.map.key.resolvedUri === a.key.resolvedUri && b.push(a.map.key); var T = t(n.default.mergeOptions(i, { uri: a.key.resolvedUri, responseType: "arraybuffer" }), It(a, b, v)); _.push(T) } if (a.map && !a.map.bytes) { if (a.map.key && (!a.key || a.key.resolvedUri !== a.map.key.resolvedUri)) { var S = t(n.default.mergeOptions(i, { uri: a.map.key.resolvedUri, responseType: "arraybuffer" }), It(a, [a.map.key], v)); _.push(S) } var w = n.default.mergeOptions(i, { uri: a.map.resolvedUri, responseType: "arraybuffer", headers: Ee(a.map) }), I = function (e) { var t = e.segment, i = e.finishProcessingFn; return function (e, n) { var r = wt(e, n); if (r) return i(r, t); var a = new Uint8Array(n.response); if (t.map.key) return t.map.encryptedBytes = a, i(null, t); t.map.bytes = a, Et(t, (function (e) { if (e) return e.xhr = n, e.status = n.status, i(e, t); i(null, t) })) } }({ segment: a, finishProcessingFn: v }), E = t(w, I); _.push(E) } var A = n.default.mergeOptions(i, { uri: a.part && a.part.resolvedUri || a.resolvedUri, responseType: "arraybuffer", headers: Ee(a) }), L = t(A, function (e) { var t = e.segment, i = e.finishProcessingFn, n = e.responseType; return function (e, r) { var a = wt(e, r); if (a) return i(a, t); var s = "arraybuffer" !== n && r.responseText ? function (e) { for (var t = new Uint8Array(new ArrayBuffer(e.length)), i = 0; i < e.length; i++)t[i] = e.charCodeAt(i); return t.buffer }(r.responseText.substring(t.lastReachedChar || 0)) : r.response; return t.stats = function (e) { return { bandwidth: e.bandwidth, bytesReceived: e.bytesReceived || 0, roundTripTime: e.roundTripTime || 0 } }(r), t.key ? t.encryptedBytes = new Uint8Array(s) : t.bytes = new Uint8Array(s), i(null, t) } }({ segment: a, finishProcessingFn: v, responseType: A.responseType })); L.addEventListener("progress", function (e) { var t = e.segment, i = e.progressFn; return function (e) { if (!e.target.aborted) return t.stats = n.default.mergeOptions(t.stats, (a = (r = e).target, (s = { bandwidth: 1 / 0, bytesReceived: 0, roundTripTime: Date.now() - a.requestTime || 0 }).bytesReceived = r.loaded, s.bandwidth = Math.floor(s.bytesReceived / s.roundTripTime * 8 * 1e3), s)), !t.stats.firstBytesReceivedAt && t.stats.bytesReceived && (t.stats.firstBytesReceivedAt = Date.now()), i(e, t); var r, a, s } }({ segment: a, progressFn: o, trackInfoFn: u, timingInfoFn: d, videoSegmentTimingInfoFn: l, audioSegmentTimingInfoFn: h, id3Fn: c, isEndOfTimeline: f, endedTimelineFn: p, dataFn: m })), _.push(L); var k = {}; return _.forEach((function (e) { e.addEventListener("loadend", function (e) { var t = e.loadendState, i = e.abortFn; return function (e) { e.target.aborted && i && !t.calledAbortFn && (i(), t.calledAbortFn = !0) } }({ loadendState: k, abortFn: s })) })), function () { return St(_) } }, Pt = c("CodecUtils"), Ot = function (e, t) { var i = t.attributes || {}; return e && e.mediaGroups && e.mediaGroups.AUDIO && i.AUDIO && e.mediaGroups.AUDIO[i.AUDIO] }, Dt = function (e) { var t = {}; return e.forEach((function (e) { var i = e.mediaType, n = e.type, r = e.details; t[i] = t[i] || [], t[i].push(x("" + n + r)) })), Object.keys(t).forEach((function (e) { if (t[e].length > 1) return Pt("multiple " + e + " codecs found as attributes: " + t[e].join(", ") + ". Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs."), void (t[e] = null); t[e] = t[e][0] })), t }, Ct = function (e) { var t = 0; return e.audio && t++, e.video && t++, t }, Rt = function (e, t) { var i = t.attributes || {}, n = Dt(function (e) { var t = e.attributes || {}; if (t.CODECS) return P(t.CODECS) }(t) || []); if (Ot(e, t) && !n.audio && !function (e, t) { if (!Ot(e, t)) return !0; var i = t.attributes || {}, n = e.mediaGroups.AUDIO[i.AUDIO]; for (var r in n) if (!n[r].uri && !n[r].playlists) return !0; return !1 }(e, t)) { var r = Dt(function (e, t) { if (!e.mediaGroups.AUDIO || !t) return null; var i = e.mediaGroups.AUDIO[t]; if (!i) return null; for (var n in i) { var r = i[n]; if (r.default && r.playlists) return P(r.playlists[0].attributes.CODECS) } return null }(e, i.AUDIO) || []); r.audio && (n.audio = r.audio) } return n }, Ut = c("PlaylistSelector"), Mt = function (e) { if (e && e.playlist) { var t = e.playlist; return JSON.stringify({ id: t.id, bandwidth: e.bandwidth, width: e.width, height: e.height, codecs: t.attributes && t.attributes.CODECS || "" }) } }, Bt = function (e, t) { if (!e) return ""; var i = window.getComputedStyle(e); return i ? i[t] : "" }, Ft = function (e, t) { var i = e.slice(); e.sort((function (e, n) { var r = t(e, n); return 0 === r ? i.indexOf(e) - i.indexOf(n) : r })) }, Nt = function (e, t) { var i, n; return e.attributes.BANDWIDTH && (i = e.attributes.BANDWIDTH), i = i || window.Number.MAX_VALUE, t.attributes.BANDWIDTH && (n = t.attributes.BANDWIDTH), i - (n || window.Number.MAX_VALUE) }, qt = function (e, t, i, n, r, a) { if (e) { var s = { bandwidth: t, width: i, height: n, limitRenditionByPlayerDimensions: r }, o = e.playlists; de.isAudioOnly(e) && (o = a.getAudioTrackPlaylists_(), s.audioOnly = !0); var u = o.map((function (e) { var t = e.attributes && e.attributes.RESOLUTION && e.attributes.RESOLUTION.width, i = e.attributes && e.attributes.RESOLUTION && e.attributes.RESOLUTION.height; return { bandwidth: e.attributes && e.attributes.BANDWIDTH || window.Number.MAX_VALUE, width: t, height: i, playlist: e } })); Ft(u, (function (e, t) { return e.bandwidth - t.bandwidth })); var d = (u = u.filter((function (e) { return !de.isIncompatible(e.playlist) }))).filter((function (e) { return de.isEnabled(e.playlist) })); d.length || (d = u.filter((function (e) { return !de.isDisabled(e.playlist) }))); var l = d.filter((function (e) { return e.bandwidth * Ve.BANDWIDTH_VARIANCE < t })), h = l[l.length - 1], c = l.filter((function (e) { return e.bandwidth === h.bandwidth }))[0]; if (!1 === r) { var f = c || d[0] || u[0]; if (f && f.playlist) { var p = "sortedPlaylistReps"; return c && (p = "bandwidthBestRep"), d[0] && (p = "enabledPlaylistReps"), Ut("choosing " + Mt(f) + " using " + p + " with options", s), f.playlist } return Ut("could not choose a playlist with options", s), null } var m = l.filter((function (e) { return e.width && e.height })); Ft(m, (function (e, t) { return e.width - t.width })); var g = m.filter((function (e) { return e.width === i && e.height === n })); h = g[g.length - 1]; var y, _, v, b, T = g.filter((function (e) { return e.bandwidth === h.bandwidth }))[0]; if (T || (_ = (y = m.filter((function (e) { return e.width > i || e.height > n }))).filter((function (e) { return e.width === y[0].width && e.height === y[0].height })), h = _[_.length - 1], v = _.filter((function (e) { return e.bandwidth === h.bandwidth }))[0]), a.experimentalLeastPixelDiffSelector) { var S = m.map((function (e) { return e.pixelDiff = Math.abs(e.width - i) + Math.abs(e.height - n), e })); Ft(S, (function (e, t) { return e.pixelDiff === t.pixelDiff ? t.bandwidth - e.bandwidth : e.pixelDiff - t.pixelDiff })), b = S[0] } var w = b || v || T || c || d[0] || u[0]; if (w && w.playlist) { var I = "sortedPlaylistReps"; return b ? I = "leastPixelDiffRep" : v ? I = "resolutionPlusOneRep" : T ? I = "resolutionBestRep" : c ? I = "bandwidthBestRep" : d[0] && (I = "enabledPlaylistReps"), Ut("choosing " + Mt(w) + " using " + I + " with options", s), w.playlist } return Ut("could not choose a playlist with options", s), null } }, Wt = function () { var e = this.useDevicePixelRatio && window.devicePixelRatio || 1; return qt(this.playlists.master, this.systemBandwidth, parseInt(Bt(this.tech_.el(), "width"), 10) * e, parseInt(Bt(this.tech_.el(), "height"), 10) * e, this.limitRenditionByPlayerDimensions, this.masterPlaylistController_) }, Ht = 9e4, Gt = Ht, Vt = (function (e) { return e * Ht }, function (e, t) { return e * t }, function (e) { return e / Ht }, function (e, t) { return e / t }, 1 / 60), jt = function (e) { var t = e.startOfSegment, i = e.duration, n = e.segment, r = e.part, a = e.playlist, s = a.mediaSequence, o = a.id, u = a.segments, d = void 0 === u ? [] : u, l = e.mediaIndex, h = e.partIndex, c = e.timeline, f = d.length - 1, p = "mediaIndex/partIndex increment"; e.getMediaInfoForTime ? p = "getMediaInfoForTime (" + e.getMediaInfoForTime + ")" : e.isSyncRequest && (p = "getSyncSegmentCandidate (isSyncRequest)"), e.independent && (p += " with independent " + e.independent); var m = "number" == typeof h, g = e.segment.uri ? "segment" : "pre-segment", y = m ? Y({ preloadSegment: n }) - 1 : 0; return g + " [" + (s + l) + "/" + (s + f) + "]" + (m ? " part [" + h + "/" + y + "]" : "") + " segment start/end [" + n.start + " => " + n.end + "]" + (m ? " part start/end [" + r.start + " => " + r.end + "]" : "") + " startOfSegment [" + t + "] duration [" + i + "] timeline [" + c + "] selected by [" + p + "] playlist [" + o + "]" }, Xt = function (e) { return e + "TimingInfo" }, Qt = function (e) { var t = e.timelineChangeController, i = e.currentTimeline, n = e.segmentTimeline, r = e.loaderType, a = e.audioDisabled; if (i === n) return !1; if ("audio" === r) { var s = t.lastTimelineChange({ type: "main" }); return !s || s.to !== n } if ("main" === r && a) { var o = t.pendingTimelineChange({ type: "audio" }); return !o || o.to !== n } return !1 }, zt = function (e) { var t = e.segmentDuration, i = e.maxDuration; return !!t && Math.round(t) > i + M }, Yt = function (e) { function t(t, i) { var r; if (r = e.call(this) || this, !t) throw new TypeError("Initialization settings are required"); if ("function" != typeof t.currentTime) throw new TypeError("No currentTime getter specified"); if (!t.mediaSource) throw new TypeError("No MediaSource specified"); return r.bandwidth = t.bandwidth, r.throughput = { rate: 0, count: 0 }, r.roundTrip = NaN, r.resetStats_(), r.mediaIndex = null, r.partIndex = null, r.hasPlayed_ = t.hasPlayed, r.currentTime_ = t.currentTime, r.seekable_ = t.seekable, r.seeking_ = t.seeking, r.duration_ = t.duration, r.mediaSource_ = t.mediaSource, r.vhs_ = t.vhs, r.loaderType_ = t.loaderType, r.currentMediaInfo_ = void 0, r.startingMediaInfo_ = void 0, r.segmentMetadataTrack_ = t.segmentMetadataTrack, r.goalBufferLength_ = t.goalBufferLength, r.sourceType_ = t.sourceType, r.sourceUpdater_ = t.sourceUpdater, r.inbandTextTracks_ = t.inbandTextTracks, r.state_ = "INIT", r.timelineChangeController_ = t.timelineChangeController, r.shouldSaveSegmentTimingInfo_ = !0, r.useDtsForTimestampOffset_ = t.useDtsForTimestampOffset, r.experimentalExactManifestTimings = t.experimentalExactManifestTimings, r.checkBufferTimeout_ = null, r.error_ = void 0, r.currentTimeline_ = -1, r.pendingSegment_ = null, r.xhrOptions_ = null, r.pendingSegments_ = [], r.audioDisabled_ = !1, r.isPendingTimestampOffset_ = !1, r.gopBuffer_ = [], r.timeMapping_ = 0, r.safeAppend_ = n.default.browser.IE_VERSION >= 11, r.appendInitSegment_ = { audio: !0, video: !0 }, r.playlistOfLastInitSegment_ = { audio: null, video: null }, r.callQueue_ = [], r.loadQueue_ = [], r.metadataQueue_ = { id3: [] }, r.waitingOnRemove_ = !1, r.quotaExceededErrorRetryTimeout_ = null, r.activeInitSegmentId_ = null, r.initSegments_ = {}, r.cacheEncryptionKeys_ = t.cacheEncryptionKeys, r.keyCache_ = {}, r.decrypter_ = t.decrypter, r.syncController_ = t.syncController, r.syncPoint_ = { segmentIndex: 0, time: 0 }, r.transmuxer_ = r.createTransmuxer_(), r.triggerSyncInfoUpdate_ = function () { return r.trigger("syncinfoupdate") }, r.syncController_.on("syncinfoupdate", r.triggerSyncInfoUpdate_), r.mediaSource_.addEventListener("sourceopen", (function () { r.isEndOfStream_() || (r.ended_ = !1) })), r.fetchAtBuffer_ = !1, r.logger_ = c("SegmentLoader[" + r.loaderType_ + "]"), Object.defineProperty(a(r), "state", { get: function () { return this.state_ }, set: function (e) { e !== this.state_ && (this.logger_(this.state_ + " -> " + e), this.state_ = e, this.trigger("statechange")) } }), r.sourceUpdater_.on("ready", (function () { r.hasEnoughInfoToAppend_() && r.processCallQueue_() })), "main" === r.loaderType_ && r.timelineChangeController_.on("pendingtimelinechange", (function () { r.hasEnoughInfoToAppend_() && r.processCallQueue_() })), "audio" === r.loaderType_ && r.timelineChangeController_.on("timelinechange", (function () { r.hasEnoughInfoToLoad_() && r.processLoadQueue_(), r.hasEnoughInfoToAppend_() && r.processCallQueue_() })), r } o(t, e); var i = t.prototype; return i.createTransmuxer_ = function () { return function (e) { var t = new Ke; t.currentTransmux = null, t.transmuxQueue = []; var i = t.terminate; return t.terminate = function () { return t.currentTransmux = null, t.transmuxQueue.length = 0, i.call(t) }, t.postMessage({ action: "init", options: e }), t }({ remux: !1, alignGopsAtEnd: this.safeAppend_, keepOriginalTimestamps: !0 }) }, i.resetStats_ = function () { this.mediaBytesTransferred = 0, this.mediaRequests = 0, this.mediaRequestsAborted = 0, this.mediaRequestsTimedout = 0, this.mediaRequestsErrored = 0, this.mediaTransferDuration = 0, this.mediaSecondsLoaded = 0, this.mediaAppends = 0 }, i.dispose = function () { this.trigger("dispose"), this.state = "DISPOSED", this.pause(), this.abort_(), this.transmuxer_ && this.transmuxer_.terminate(), this.resetStats_(), this.checkBufferTimeout_ && window.clearTimeout(this.checkBufferTimeout_), this.syncController_ && this.triggerSyncInfoUpdate_ && this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_), this.off() }, i.setAudio = function (e) { this.audioDisabled_ = !e, e ? this.appendInitSegment_.audio = !0 : this.sourceUpdater_.removeAudio(0, this.duration_()) }, i.abort = function () { "WAITING" === this.state ? (this.abort_(), this.state = "READY", this.paused() || this.monitorBuffer_()) : this.pendingSegment_ && (this.pendingSegment_ = null) }, i.abort_ = function () { this.pendingSegment_ && this.pendingSegment_.abortRequests && this.pendingSegment_.abortRequests(), this.pendingSegment_ = null, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_), this.waitingOnRemove_ = !1, window.clearTimeout(this.quotaExceededErrorRetryTimeout_), this.quotaExceededErrorRetryTimeout_ = null }, i.checkForAbort_ = function (e) { return "APPENDING" !== this.state || this.pendingSegment_ ? !this.pendingSegment_ || this.pendingSegment_.requestId !== e : (this.state = "READY", !0) }, i.error = function (e) { return void 0 !== e && (this.logger_("error occurred:", e), this.error_ = e), this.pendingSegment_ = null, this.error_ }, i.endOfStream = function () { this.ended_ = !0, this.transmuxer_ && et(this.transmuxer_), this.gopBuffer_.length = 0, this.pause(), this.trigger("ended") }, i.buffered_ = function () { var e = this.getMediaInfo_(); if (!this.sourceUpdater_ || !e) return n.default.createTimeRanges(); if ("main" === this.loaderType_) { var t = e.hasAudio, i = e.hasVideo, r = e.isMuxed; if (i && t && !this.audioDisabled_ && !r) return this.sourceUpdater_.buffered(); if (i) return this.sourceUpdater_.videoBuffered() } return this.sourceUpdater_.audioBuffered() }, i.initSegmentForMap = function (e, t) { if (void 0 === t && (t = !1), !e) return null; var i = Ne(e), n = this.initSegments_[i]; return t && !n && e.bytes && (this.initSegments_[i] = n = { resolvedUri: e.resolvedUri, byterange: e.byterange, bytes: e.bytes, tracks: e.tracks, timescales: e.timescales }), n || e }, i.segmentKey = function (e, t) { if (void 0 === t && (t = !1), !e) return null; var i = qe(e), n = this.keyCache_[i]; this.cacheEncryptionKeys_ && t && !n && e.bytes && (this.keyCache_[i] = n = { resolvedUri: e.resolvedUri, bytes: e.bytes }); var r = { resolvedUri: (n || e).resolvedUri }; return n && (r.bytes = n.bytes), r }, i.couldBeginLoading_ = function () { return this.playlist_ && !this.paused() }, i.load = function () { if (this.monitorBuffer_(), this.playlist_) return "INIT" === this.state && this.couldBeginLoading_() ? this.init_() : void (!this.couldBeginLoading_() || "READY" !== this.state && "INIT" !== this.state || (this.state = "READY")) }, i.init_ = function () { return this.state = "READY", this.resetEverything(), this.monitorBuffer_() }, i.playlist = function (e, t) { if (void 0 === t && (t = {}), e) { var i = this.playlist_, n = this.pendingSegment_; this.playlist_ = e, this.xhrOptions_ = t, "INIT" === this.state && (e.syncInfo = { mediaSequence: e.mediaSequence, time: 0 }, "main" === this.loaderType_ && this.syncController_.setDateTimeMappingForStart(e)); var r = null; if (i && (i.id ? r = i.id : i.uri && (r = i.uri)), this.logger_("playlist update [" + r + " => " + (e.id || e.uri) + "]"), this.trigger("syncinfoupdate"), "INIT" === this.state && this.couldBeginLoading_()) return this.init_(); if (!i || i.uri !== e.uri) return null !== this.mediaIndex && (e.endList ? this.resyncLoader() : this.resetLoader()), this.currentMediaInfo_ = void 0, void this.trigger("playlistupdate"); var a = e.mediaSequence - i.mediaSequence; if (this.logger_("live window shift [" + a + "]"), null !== this.mediaIndex) if (this.mediaIndex -= a, this.mediaIndex < 0) this.mediaIndex = null, this.partIndex = null; else { var s = this.playlist_.segments[this.mediaIndex]; if (this.partIndex && (!s.parts || !s.parts.length || !s.parts[this.partIndex])) { var o = this.mediaIndex; this.logger_("currently processing part (index " + this.partIndex + ") no longer exists."), this.resetLoader(), this.mediaIndex = o } } n && (n.mediaIndex -= a, n.mediaIndex < 0 ? (n.mediaIndex = null, n.partIndex = null) : (n.mediaIndex >= 0 && (n.segment = e.segments[n.mediaIndex]), n.partIndex >= 0 && n.segment.parts && (n.part = n.segment.parts[n.partIndex]))), this.syncController_.saveExpiredSegmentInfo(i, e) } }, i.pause = function () { this.checkBufferTimeout_ && (window.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = null) }, i.paused = function () { return null === this.checkBufferTimeout_ }, i.resetEverything = function (e) { this.ended_ = !1, this.appendInitSegment_ = { audio: !0, video: !0 }, this.resetLoader(), this.remove(0, 1 / 0, e), this.transmuxer_ && this.transmuxer_.postMessage({ action: "reset" }) }, i.resetLoader = function () { this.fetchAtBuffer_ = !1, this.resyncLoader() }, i.resyncLoader = function () { this.transmuxer_ && et(this.transmuxer_), this.mediaIndex = null, this.partIndex = null, this.syncPoint_ = null, this.isPendingTimestampOffset_ = !1, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.abort() }, i.remove = function (e, t, i, n) { if (void 0 === i && (i = function () { }), void 0 === n && (n = !1), t === 1 / 0 && (t = this.duration_()), t <= e) this.logger_("skipping remove because end ${end} is <= start ${start}"); else if (this.sourceUpdater_ && this.getMediaInfo_()) { var r = 1, a = function () { 0 == --r && i() }; !n && this.audioDisabled_ || (r++, this.sourceUpdater_.removeAudio(e, t, a)), (n || "main" === this.loaderType_) && (this.gopBuffer_ = function (e, t, i, n) { for (var r = Math.ceil((t - n) * Gt), a = Math.ceil((i - n) * Gt), s = e.slice(), o = e.length; o-- && !(e[o].pts <= a);); if (-1 === o) return s; for (var u = o + 1; u-- && !(e[u].pts <= r);); return u = Math.max(u, 0), s.splice(u, o - u + 1), s }(this.gopBuffer_, e, t, this.timeMapping_), r++, this.sourceUpdater_.removeVideo(e, t, a)), a() } else this.logger_("skipping remove because no source updater or starting media info") }, i.monitorBuffer_ = function () { this.checkBufferTimeout_ && window.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), 1) }, i.monitorBufferTick_ = function () { "READY" === this.state && this.fillBuffer_(), this.checkBufferTimeout_ && window.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), 500) }, i.fillBuffer_ = function () { if (!this.sourceUpdater_.updating()) { var e = this.chooseNextRequest_(); e && ("number" == typeof e.timestampOffset && (this.isPendingTimestampOffset_ = !1, this.timelineChangeController_.pendingTimelineChange({ type: this.loaderType_, from: this.currentTimeline_, to: e.timeline })), this.loadSegment_(e)) } }, i.isEndOfStream_ = function (e, t, i) { if (void 0 === e && (e = this.mediaIndex), void 0 === t && (t = this.playlist_), void 0 === i && (i = this.partIndex), !t || !this.mediaSource_) return !1; var n = "number" == typeof e && t.segments[e], r = e + 1 === t.segments.length, a = !n || !n.parts || i + 1 === n.parts.length; return t.endList && "open" === this.mediaSource_.readyState && r && a }, i.chooseNextRequest_ = function () { var e = this.buffered_(), t = G(e) || 0, i = V(e, this.currentTime_()), n = !this.hasPlayed_() && i >= 1, r = i >= this.goalBufferLength_(), a = this.playlist_.segments; if (!a.length || n || r) return null; this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_()); var s = { partIndex: null, mediaIndex: null, startOfSegment: null, playlist: this.playlist_, isSyncRequest: Boolean(!this.syncPoint_) }; if (s.isSyncRequest) s.mediaIndex = function (e, t, i) { t = t || []; for (var n = [], r = 0, a = 0; a < t.length; a++) { var s = t[a]; if (e === s.timeline && (n.push(a), (r += s.duration) > i)) return a } return 0 === n.length ? 0 : n[n.length - 1] }(this.currentTimeline_, a, t); else if (null !== this.mediaIndex) { var o = a[this.mediaIndex], u = "number" == typeof this.partIndex ? this.partIndex : -1; s.startOfSegment = o.end ? o.end : t, o.parts && o.parts[u + 1] ? (s.mediaIndex = this.mediaIndex, s.partIndex = u + 1) : s.mediaIndex = this.mediaIndex + 1 } else { var d = de.getMediaInfoForTime({ experimentalExactManifestTimings: this.experimentalExactManifestTimings, playlist: this.playlist_, currentTime: this.fetchAtBuffer_ ? t : this.currentTime_(), startingPartIndex: this.syncPoint_.partIndex, startingSegmentIndex: this.syncPoint_.segmentIndex, startTime: this.syncPoint_.time }), l = d.segmentIndex, h = d.startTime, c = d.partIndex; s.getMediaInfoForTime = this.fetchAtBuffer_ ? "bufferedEnd " + t : "currentTime " + this.currentTime_(), s.mediaIndex = l, s.startOfSegment = h, s.partIndex = c } var f = a[s.mediaIndex], p = f && "number" == typeof s.partIndex && f.parts && f.parts[s.partIndex]; if (!f || "number" == typeof s.partIndex && !p) return null; if ("number" != typeof s.partIndex && f.parts && (s.partIndex = 0, p = f.parts[0]), !i && p && !p.independent) if (0 === s.partIndex) { var m = a[s.mediaIndex - 1], g = m.parts && m.parts.length && m.parts[m.parts.length - 1]; g && g.independent && (s.mediaIndex -= 1, s.partIndex = m.parts.length - 1, s.independent = "previous segment") } else f.parts[s.partIndex - 1].independent && (s.partIndex -= 1, s.independent = "previous part"); var y = this.mediaSource_ && "ended" === this.mediaSource_.readyState; return s.mediaIndex >= a.length - 1 && y && !this.seeking_() ? null : this.generateSegmentInfo_(s) }, i.generateSegmentInfo_ = function (e) { var t = e.independent, i = e.playlist, n = e.mediaIndex, r = e.startOfSegment, a = e.isSyncRequest, s = e.partIndex, o = e.forceTimestampOffset, u = e.getMediaInfoForTime, d = i.segments[n], l = "number" == typeof s && d.parts[s], h = { requestId: "segment-loader-" + Math.random(), uri: l && l.resolvedUri || d.resolvedUri, mediaIndex: n, partIndex: l ? s : null, isSyncRequest: a, startOfSegment: r, playlist: i, bytes: null, encryptedBytes: null, timestampOffset: null, timeline: d.timeline, duration: l && l.duration || d.duration, segment: d, part: l, byteLength: 0, transmuxer: this.transmuxer_, getMediaInfoForTime: u, independent: t }, c = void 0 !== o ? o : this.isPendingTimestampOffset_; h.timestampOffset = this.timestampOffsetForSegment_({ segmentTimeline: d.timeline, currentTimeline: this.currentTimeline_, startOfSegment: r, buffered: this.buffered_(), overrideCheck: c }); var f = G(this.sourceUpdater_.audioBuffered()); return "number" == typeof f && (h.audioAppendStart = f - this.sourceUpdater_.audioTimestampOffset()), this.sourceUpdater_.videoBuffered().length && (h.gopsToAlignWith = function (e, t, i) { if (null == t || !e.length) return []; var n, r = Math.ceil((t - i + 3) * Gt); for (n = 0; n < e.length && !(e[n].pts > r); n++); return e.slice(n) }(this.gopBuffer_, this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(), this.timeMapping_)), h }, i.timestampOffsetForSegment_ = function (e) { return i = (t = e).segmentTimeline, n = t.currentTimeline, r = t.startOfSegment, a = t.buffered, t.overrideCheck || i !== n ? i < n ? r : a.length ? a.end(a.length - 1) : r : null; var t, i, n, r, a }, i.earlyAbortWhenNeeded_ = function (e) { if (!this.vhs_.tech_.paused() && this.xhrOptions_.timeout && this.playlist_.attributes.BANDWIDTH && !(Date.now() - (e.firstBytesReceivedAt || Date.now()) < 1e3)) { var t = this.currentTime_(), i = e.bandwidth, n = this.pendingSegment_.duration, r = de.estimateSegmentRequestTime(n, i, this.playlist_, e.bytesReceived), a = function (e, t) { return (e.length ? e.end(e.length - 1) : 0) - t }(this.buffered_(), t) - 1; if (!(r <= a)) { var s = function (e) { var t = e.currentTime, i = e.bandwidth, n = e.duration, r = e.segmentDuration, a = e.timeUntilRebuffer, s = e.currentTimeline, o = e.syncController, u = e.master.playlists.filter((function (e) { return !de.isIncompatible(e) })), d = u.filter(de.isEnabled); d.length || (d = u.filter((function (e) { return !de.isDisabled(e) }))); var l = d.filter(de.hasAttribute.bind(null, "BANDWIDTH")).map((function (e) { var u = o.getSyncPoint(e, n, s, t) ? 1 : 2; return { playlist: e, rebufferingImpact: de.estimateSegmentRequestTime(r, i, e) * u - a } })), h = l.filter((function (e) { return e.rebufferingImpact <= 0 })); return Ft(h, (function (e, t) { return Nt(t.playlist, e.playlist) })), h.length ? h[0] : (Ft(l, (function (e, t) { return e.rebufferingImpact - t.rebufferingImpact })), l[0] || null) }({ master: this.vhs_.playlists.master, currentTime: t, bandwidth: i, duration: this.duration_(), segmentDuration: n, timeUntilRebuffer: a, currentTimeline: this.currentTimeline_, syncController: this.syncController_ }); if (s) { var o = r - a - s.rebufferingImpact, u = .5; a <= M && (u = 1), !s.playlist || s.playlist.uri === this.playlist_.uri || o < u || (this.bandwidth = s.playlist.attributes.BANDWIDTH * Ve.BANDWIDTH_VARIANCE + 1, this.trigger("earlyabort")) } } } }, i.handleAbort_ = function (e) { this.logger_("Aborting " + jt(e)), this.mediaRequestsAborted += 1 }, i.handleProgress_ = function (e, t) { this.earlyAbortWhenNeeded_(t.stats), this.checkForAbort_(t.requestId) || this.trigger("progress") }, i.handleTrackInfo_ = function (e, t) { this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId) || this.checkForIllegalMediaSwitch(t) || (t = t || {}, function (e, t) { if (!e && !t || !e && t || e && !t) return !1; if (e === t) return !0; var i = Object.keys(e).sort(), n = Object.keys(t).sort(); if (i.length !== n.length) return !1; for (var r = 0; r < i.length; r++) { var a = i[r]; if (a !== n[r]) return !1; if (e[a] !== t[a]) return !1 } return !0 }(this.currentMediaInfo_, t) || (this.appendInitSegment_ = { audio: !0, video: !0 }, this.startingMediaInfo_ = t, this.currentMediaInfo_ = t, this.logger_("trackinfo update", t), this.trigger("trackinfo")), this.checkForAbort_(e.requestId) || (this.pendingSegment_.trackInfo = t, this.hasEnoughInfoToAppend_() && this.processCallQueue_())) }, i.handleTimingInfo_ = function (e, t, i, n) { if (this.earlyAbortWhenNeeded_(e.stats), !this.checkForAbort_(e.requestId)) { var r = this.pendingSegment_, a = Xt(t); r[a] = r[a] || {}, r[a][i] = n, this.logger_("timinginfo: " + t + " - " + i + " - " + n), this.hasEnoughInfoToAppend_() && this.processCallQueue_() } }, i.handleId3_ = function (e, t, i) { this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId) || (this.pendingSegment_.hasAppendedData_ ? null === this.sourceUpdater_.videoTimestampOffset() ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset() : this.metadataQueue_.id3.push(this.handleId3_.bind(this, e, t, i))) }, i.processMetadataQueue_ = function () { this.metadataQueue_.id3.forEach((function (e) { return e() })), this.metadataQueue_.id3 = [] }, i.processCallQueue_ = function () { var e = this.callQueue_; this.callQueue_ = [], e.forEach((function (e) { return e() })) }, i.processLoadQueue_ = function () { var e = this.loadQueue_; this.loadQueue_ = [], e.forEach((function (e) { return e() })) }, i.hasEnoughInfoToLoad_ = function () { if ("audio" !== this.loaderType_) return !0; var e = this.pendingSegment_; return !(!e || this.getCurrentMediaInfo_() && Qt({ timelineChangeController: this.timelineChangeController_, currentTimeline: this.currentTimeline_, segmentTimeline: e.timeline, loaderType: this.loaderType_, audioDisabled: this.audioDisabled_ })) }, i.getCurrentMediaInfo_ = function (e) { return void 0 === e && (e = this.pendingSegment_), e && e.trackInfo || this.currentMediaInfo_ }, i.getMediaInfo_ = function (e) { return void 0 === e && (e = this.pendingSegment_), this.getCurrentMediaInfo_(e) || this.startingMediaInfo_ }, i.hasEnoughInfoToAppend_ = function () { if (!this.sourceUpdater_.ready()) return !1; if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) return !1; var e = this.pendingSegment_, t = this.getCurrentMediaInfo_(); if (!e || !t) return !1; var i = t.hasAudio, n = t.hasVideo, r = t.isMuxed; return !(n && !e.videoTimingInfo || i && !this.audioDisabled_ && !r && !e.audioTimingInfo || Qt({ timelineChangeController: this.timelineChangeController_, currentTimeline: this.currentTimeline_, segmentTimeline: e.timeline, loaderType: this.loaderType_, audioDisabled: this.audioDisabled_ })) }, i.handleData_ = function (e, t) { if (this.earlyAbortWhenNeeded_(e.stats), !this.checkForAbort_(e.requestId)) if (!this.callQueue_.length && this.hasEnoughInfoToAppend_()) { var i = this.pendingSegment_; if (this.setTimeMapping_(i.timeline), this.updateMediaSecondsLoaded_(i.part || i.segment), "closed" !== this.mediaSource_.readyState) { if (e.map && (e.map = this.initSegmentForMap(e.map, !0), i.segment.map = e.map), e.key && this.segmentKey(e.key, !0), i.isFmp4 = e.isFmp4, i.timingInfo = i.timingInfo || {}, i.isFmp4) this.trigger("fmp4"), i.timingInfo.start = i[Xt(t.type)].start; else { var n, r = this.getCurrentMediaInfo_(), a = "main" === this.loaderType_ && r && r.hasVideo; a && (n = i.videoTimingInfo.start), i.timingInfo.start = this.trueSegmentStart_({ currentStart: i.timingInfo.start, playlist: i.playlist, mediaIndex: i.mediaIndex, currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(), useVideoTimingInfo: a, firstVideoFrameTimeForData: n, videoTimingInfo: i.videoTimingInfo, audioTimingInfo: i.audioTimingInfo }) } if (this.updateAppendInitSegmentStatus(i, t.type), this.updateSourceBufferTimestampOffset_(i), i.isSyncRequest) { this.updateTimingInfoEnd_(i), this.syncController_.saveSegmentTimingInfo({ segmentInfo: i, shouldSaveTimelineMapping: "main" === this.loaderType_ }); var s = this.chooseNextRequest_(); if (s.mediaIndex !== i.mediaIndex || s.partIndex !== i.partIndex) return void this.logger_("sync segment was incorrect, not appending"); this.logger_("sync segment was correct, appending") } i.hasAppendedData_ = !0, this.processMetadataQueue_(), this.appendData_(i, t) } } else this.callQueue_.push(this.handleData_.bind(this, e, t)) }, i.updateAppendInitSegmentStatus = function (e, t) { "main" !== this.loaderType_ || "number" != typeof e.timestampOffset || e.changedTimestampOffset || (this.appendInitSegment_ = { audio: !0, video: !0 }), this.playlistOfLastInitSegment_[t] !== e.playlist && (this.appendInitSegment_[t] = !0) }, i.getInitSegmentAndUpdateState_ = function (e) { var t = e.type, i = e.initSegment, n = e.map, r = e.playlist; if (n) { var a = Ne(n); if (this.activeInitSegmentId_ === a) return null; i = this.initSegmentForMap(n, !0).bytes, this.activeInitSegmentId_ = a } return i && this.appendInitSegment_[t] ? (this.playlistOfLastInitSegment_[t] = r, this.appendInitSegment_[t] = !1, this.activeInitSegmentId_ = null, i) : null }, i.handleQuotaExceededError_ = function (e, t) { var i = this, n = e.segmentInfo, r = e.type, a = e.bytes, s = this.sourceUpdater_.audioBuffered(), o = this.sourceUpdater_.videoBuffered(); s.length > 1 && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + H(s).join(", ")), o.length > 1 && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + H(o).join(", ")); var u = s.length ? s.start(0) : 0, d = s.length ? s.end(s.length - 1) : 0, l = o.length ? o.start(0) : 0, h = o.length ? o.end(o.length - 1) : 0; if (d - u <= 1 && h - l <= 1) return this.logger_("On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. Appended byte length: " + a.byteLength + ", audio buffer: " + H(s).join(", ") + ", video buffer: " + H(o).join(", ") + ", "), this.error({ message: "Quota exceeded error with append of a single segment of content", excludeUntil: 1 / 0 }), void this.trigger("error"); this.waitingOnRemove_ = !0, this.callQueue_.push(this.appendToSourceBuffer_.bind(this, { segmentInfo: n, type: r, bytes: a })); var c = this.currentTime_() - 1; this.logger_("On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to " + c), this.remove(0, c, (function () { i.logger_("On QUOTA_EXCEEDED_ERR, retrying append in 1s"), i.waitingOnRemove_ = !1, i.quotaExceededErrorRetryTimeout_ = window.setTimeout((function () { i.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue"), i.quotaExceededErrorRetryTimeout_ = null, i.processCallQueue_() }), 1e3) }), !0) }, i.handleAppendError_ = function (e, t) { var i = e.segmentInfo, n = e.type, r = e.bytes; t && (22 !== t.code ? (this.logger_("Received non QUOTA_EXCEEDED_ERR on append", t), this.error(n + " append of " + r.length + "b failed for segment #" + i.mediaIndex + " in playlist " + i.playlist.id), this.trigger("appenderror")) : this.handleQuotaExceededError_({ segmentInfo: i, type: n, bytes: r })) }, i.appendToSourceBuffer_ = function (e) { var t, i, n, r = e.segmentInfo, a = e.type, s = e.initSegment, o = e.data, u = e.bytes; if (!u) { var d = [o], l = o.byteLength; s && (d.unshift(s), l += s.byteLength), n = 0, (t = { bytes: l, segments: d }).bytes && (i = new Uint8Array(t.bytes), t.segments.forEach((function (e) { i.set(e, n), n += e.byteLength }))), u = i } this.sourceUpdater_.appendBuffer({ segmentInfo: r, type: a, bytes: u }, this.handleAppendError_.bind(this, { segmentInfo: r, type: a, bytes: u })) }, i.handleSegmentTimingInfo_ = function (e, t, i) { if (this.pendingSegment_ && t === this.pendingSegment_.requestId) { var n = this.pendingSegment_.segment, r = e + "TimingInfo"; n[r] || (n[r] = {}), n[r].transmuxerPrependedSeconds = i.prependedContentDuration || 0, n[r].transmuxedPresentationStart = i.start.presentation, n[r].transmuxedDecodeStart = i.start.decode, n[r].transmuxedPresentationEnd = i.end.presentation, n[r].transmuxedDecodeEnd = i.end.decode, n[r].baseMediaDecodeTime = i.baseMediaDecodeTime } }, i.appendData_ = function (e, t) { var i = t.type, n = t.data; if (n && n.byteLength && ("audio" !== i || !this.audioDisabled_)) { var r = this.getInitSegmentAndUpdateState_({ type: i, initSegment: t.initSegment, playlist: e.playlist, map: e.isFmp4 ? e.segment.map : null }); this.appendToSourceBuffer_({ segmentInfo: e, type: i, initSegment: r, data: n }) } }, i.loadSegment_ = function (e) { var t = this; this.state = "WAITING", this.pendingSegment_ = e, this.trimBackBuffer_(e), this.hasEnoughInfoToLoad_() ? this.updateTransmuxerAndRequestSegment_(e) : this.loadQueue_.push((function () { var i = f({}, e, { forceTimestampOffset: !0 }); f(e, t.generateSegmentInfo_(i)), t.isPendingTimestampOffset_ = !1, t.updateTransmuxerAndRequestSegment_(e) })) }, i.updateTransmuxerAndRequestSegment_ = function (e) { var t = this; this.shouldUpdateTransmuxerTimestampOffset_(e.timestampOffset) && (this.gopBuffer_.length = 0, e.gopsToAlignWith = [], this.timeMapping_ = 0, this.transmuxer_.postMessage({ action: "reset" }), this.transmuxer_.postMessage({ action: "setTimestampOffset", timestampOffset: e.timestampOffset })); var i = this.createSimplifiedSegmentObj_(e), n = this.isEndOfStream_(e.mediaIndex, e.playlist, e.partIndex), r = null !== this.mediaIndex, a = e.timeline !== this.currentTimeline_ && e.timeline > 0, s = n || r && a; this.logger_("Requesting " + jt(e)), i.map && !i.map.bytes && (this.logger_("going to request init segment."), this.appendInitSegment_ = { video: !0, audio: !0 }), e.abortRequests = xt({ xhr: this.vhs_.xhr, xhrOptions: this.xhrOptions_, decryptionWorker: this.decrypter_, segment: i, abortFn: this.handleAbort_.bind(this, e), progressFn: this.handleProgress_.bind(this), trackInfoFn: this.handleTrackInfo_.bind(this), timingInfoFn: this.handleTimingInfo_.bind(this), videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", e.requestId), audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", e.requestId), isEndOfTimeline: s, endedTimelineFn: function () { t.logger_("received endedtimeline callback") }, id3Fn: this.handleId3_.bind(this), dataFn: this.handleData_.bind(this), doneFn: this.segmentRequestFinished_.bind(this), onTransmuxerLog: function (i) { var n = i.message, r = i.level, a = i.stream; t.logger_(jt(e) + " logged from transmuxer stream " + a + " as a " + r + ": " + n) } }) }, i.trimBackBuffer_ = function (e) { var t = function (e, t, i) { var n = t - Ve.BACK_BUFFER_LENGTH; e.length && (n = Math.max(n, e.start(0))); var r = t - i; return Math.min(r, n) }(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10); t > 0 && this.remove(0, t) }, i.createSimplifiedSegmentObj_ = function (e) { var t = e.segment, i = e.part, n = { resolvedUri: i ? i.resolvedUri : t.resolvedUri, byterange: i ? i.byterange : t.byterange, requestId: e.requestId, transmuxer: e.transmuxer, audioAppendStart: e.audioAppendStart, gopsToAlignWith: e.gopsToAlignWith, part: e.part }, r = e.playlist.segments[e.mediaIndex - 1]; if (r && r.timeline === t.timeline && (r.videoTimingInfo ? n.baseStartTime = r.videoTimingInfo.transmuxedDecodeEnd : r.audioTimingInfo && (n.baseStartTime = r.audioTimingInfo.transmuxedDecodeEnd)), t.key) { var a = t.key.iv || new Uint32Array([0, 0, 0, e.mediaIndex + e.playlist.mediaSequence]); n.key = this.segmentKey(t.key), n.key.iv = a } return t.map && (n.map = this.initSegmentForMap(t.map)), n }, i.saveTransferStats_ = function (e) { this.mediaRequests += 1, e && (this.mediaBytesTransferred += e.bytesReceived, this.mediaTransferDuration += e.roundTripTime) }, i.saveBandwidthRelatedStats_ = function (e, t) { this.pendingSegment_.byteLength = t.bytesReceived, e < Vt ? this.logger_("Ignoring segment's bandwidth because its duration of " + e + " is less than the min to record 0.016666666666666666") : (this.bandwidth = t.bandwidth, this.roundTrip = t.roundTripTime) }, i.handleTimeout_ = function () { this.mediaRequestsTimedout += 1, this.bandwidth = 1, this.roundTrip = NaN, this.trigger("bandwidthupdate") }, i.segmentRequestFinished_ = function (e, t, i) { if (this.callQueue_.length) this.callQueue_.push(this.segmentRequestFinished_.bind(this, e, t, i)); else if (this.saveTransferStats_(t.stats), this.pendingSegment_ && t.requestId === this.pendingSegment_.requestId) { if (e) { if (this.pendingSegment_ = null, this.state = "READY", -102 === e.code) return; return this.pause(), -101 === e.code ? void this.handleTimeout_() : (this.mediaRequestsErrored += 1, this.error(e), void this.trigger("error")) } var n = this.pendingSegment_; this.saveBandwidthRelatedStats_(n.duration, t.stats), n.endOfAllRequests = t.endOfAllRequests, i.gopInfo && (this.gopBuffer_ = function (e, t, i) { if (!t.length) return e; if (i) return t.slice(); for (var n = t[0].pts, r = 0; r < e.length && !(e[r].pts >= n); r++); return e.slice(0, r).concat(t) }(this.gopBuffer_, i.gopInfo, this.safeAppend_)), this.state = "APPENDING", this.trigger("appending"), this.waitForAppendsToComplete_(n) } }, i.setTimeMapping_ = function (e) { var t = this.syncController_.mappingForTimeline(e); null !== t && (this.timeMapping_ = t) }, i.updateMediaSecondsLoaded_ = function (e) { "number" == typeof e.start && "number" == typeof e.end ? this.mediaSecondsLoaded += e.end - e.start : this.mediaSecondsLoaded += e.duration }, i.shouldUpdateTransmuxerTimestampOffset_ = function (e) { return null !== e && ("main" === this.loaderType_ && e !== this.sourceUpdater_.videoTimestampOffset() || !this.audioDisabled_ && e !== this.sourceUpdater_.audioTimestampOffset()) }, i.trueSegmentStart_ = function (e) { var t = e.currentStart, i = e.playlist, n = e.mediaIndex, r = e.firstVideoFrameTimeForData, a = e.currentVideoTimestampOffset, s = e.useVideoTimingInfo, o = e.videoTimingInfo, u = e.audioTimingInfo; if (void 0 !== t) return t; if (!s) return u.start; var d = i.segments[n - 1]; return 0 !== n && d && void 0 !== d.start && d.end === r + a ? o.start : r }, i.waitForAppendsToComplete_ = function (e) { var t = this.getCurrentMediaInfo_(e); if (!t) return this.error({ message: "No starting media returned, likely due to an unsupported media format.", blacklistDuration: 1 / 0 }), void this.trigger("error"); var i = t.hasAudio, n = t.hasVideo, r = t.isMuxed, a = "main" === this.loaderType_ && n, s = !this.audioDisabled_ && i && !r; if (e.waitingOnAppends = 0, !e.hasAppendedData_) return e.timingInfo || "number" != typeof e.timestampOffset || (this.isPendingTimestampOffset_ = !0), e.timingInfo = { start: 0 }, e.waitingOnAppends++, this.isPendingTimestampOffset_ || (this.updateSourceBufferTimestampOffset_(e), this.processMetadataQueue_()), void this.checkAppendsDone_(e); a && e.waitingOnAppends++, s && e.waitingOnAppends++, a && this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, e)), s && this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, e)) }, i.checkAppendsDone_ = function (e) { this.checkForAbort_(e.requestId) || (e.waitingOnAppends--, 0 === e.waitingOnAppends && this.handleAppendsDone_()) }, i.checkForIllegalMediaSwitch = function (e) { var t = function (e, t, i) { return "main" === e && t && i ? i.hasAudio || i.hasVideo ? t.hasVideo && !i.hasVideo ? "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest." : !t.hasVideo && i.hasVideo ? "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest." : null : "Neither audio nor video found in segment." : null }(this.loaderType_, this.getCurrentMediaInfo_(), e); return !!t && (this.error({ message: t, blacklistDuration: 1 / 0 }), this.trigger("error"), !0) }, i.updateSourceBufferTimestampOffset_ = function (e) { if (null !== e.timestampOffset && "number" == typeof e.timingInfo.start && !e.changedTimestampOffset && "main" === this.loaderType_) { var t = !1; e.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({ videoTimingInfo: e.segment.videoTimingInfo, audioTimingInfo: e.segment.audioTimingInfo, timingInfo: e.timingInfo }), e.changedTimestampOffset = !0, e.timestampOffset !== this.sourceUpdater_.videoTimestampOffset() && (this.sourceUpdater_.videoTimestampOffset(e.timestampOffset), t = !0), e.timestampOffset !== this.sourceUpdater_.audioTimestampOffset() && (this.sourceUpdater_.audioTimestampOffset(e.timestampOffset), t = !0), t && this.trigger("timestampoffset") } }, i.getSegmentStartTimeForTimestampOffsetCalculation_ = function (e) { var t = e.videoTimingInfo, i = e.audioTimingInfo, n = e.timingInfo; return this.useDtsForTimestampOffset_ ? t && "number" == typeof t.transmuxedDecodeStart ? t.transmuxedDecodeStart : i && "number" == typeof i.transmuxedDecodeStart ? i.transmuxedDecodeStart : n.start : n.start }, i.updateTimingInfoEnd_ = function (e) { e.timingInfo = e.timingInfo || {}; var t = this.getMediaInfo_(), i = "main" === this.loaderType_ && t && t.hasVideo && e.videoTimingInfo ? e.videoTimingInfo : e.audioTimingInfo; i && (e.timingInfo.end = "number" == typeof i.end ? i.end : i.start + e.duration) }, i.handleAppendsDone_ = function () { if (this.pendingSegment_ && this.trigger("appendsdone"), !this.pendingSegment_) return this.state = "READY", void (this.paused() || this.monitorBuffer_()); var e = this.pendingSegment_; this.updateTimingInfoEnd_(e), this.shouldSaveSegmentTimingInfo_ && this.syncController_.saveSegmentTimingInfo({ segmentInfo: e, shouldSaveTimelineMapping: "main" === this.loaderType_ }); var t = function (e, t) { if ("hls" !== t) return null; var i, n, r = (i = { audioTimingInfo: e.audioTimingInfo, videoTimingInfo: e.videoTimingInfo }, n = 0, ["video", "audio"].forEach((function (e) { var t = i[e + "TimingInfo"]; if (t) { var r, a = t.start, s = t.end; "bigint" == typeof a || "bigint" == typeof s ? r = window.BigInt(s) - window.BigInt(a) : "number" == typeof a && "number" == typeof s && (r = s - a), void 0 !== r && r > n && (n = r) } })), "bigint" == typeof n && n < Number.MAX_SAFE_INTEGER && (n = Number(n)), n); if (!r) return null; var a = e.playlist.targetDuration, s = zt({ segmentDuration: r, maxDuration: 2 * a }), o = zt({ segmentDuration: r, maxDuration: a }), u = "Segment with index " + e.mediaIndex + " from playlist " + e.playlist.id + " has a duration of " + r + " when the reported duration is " + e.duration + " and the target duration is " + a + ". For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1"; return s || o ? { severity: s ? "warn" : "info", message: u } : null }(e, this.sourceType_); if (t && ("warn" === t.severity ? n.default.log.warn(t.message) : this.logger_(t.message)), this.recordThroughput_(e), this.pendingSegment_ = null, this.state = "READY", !e.isSyncRequest || (this.trigger("syncinfoupdate"), e.hasAppendedData_)) { this.logger_("Appended " + jt(e)), this.fetchAtBuffer_ = !0, this.currentTimeline_ !== e.timeline && (this.timelineChangeController_.lastTimelineChange({ type: this.loaderType_, from: this.currentTimeline_, to: e.timeline }), "main" !== this.loaderType_ || this.audioDisabled_ || this.timelineChangeController_.lastTimelineChange({ type: "audio", from: this.currentTimeline_, to: e.timeline })), this.currentTimeline_ = e.timeline, this.trigger("syncinfoupdate"); var i = e.segment, r = e.part, a = i.end && this.currentTime_() - i.end > 3 * e.playlist.targetDuration, s = r && r.end && this.currentTime_() - r.end > 3 * e.playlist.partTargetDuration; if (a || s) return this.logger_("bad " + (a ? "segment" : "part") + " " + jt(e)), void this.resetEverything(); null !== this.mediaIndex && this.trigger("bandwidthupdate"), this.trigger("progress"), this.mediaIndex = e.mediaIndex, this.partIndex = e.partIndex, this.isEndOfStream_(e.mediaIndex, e.playlist, e.partIndex) && this.endOfStream(), this.trigger("appended"), e.hasAppendedData_ && this.mediaAppends++, this.paused() || this.monitorBuffer_() } else this.logger_("Throwing away un-appended sync request " + jt(e)) }, i.recordThroughput_ = function (e) { if (e.duration < Vt) this.logger_("Ignoring segment's throughput because its duration of " + e.duration + " is less than the min to record 0.016666666666666666"); else { var t = this.throughput.rate, i = Date.now() - e.endOfAllRequests + 1, n = Math.floor(e.byteLength / i * 8 * 1e3); this.throughput.rate += (n - t) / ++this.throughput.count } }, t }(n.default.EventTarget); function Kt() { } var $t, Jt = function (e) { return "string" != typeof e ? e : e.replace(/./, (function (e) { return e.toUpperCase() })) }, Zt = ["video", "audio"], ei = function (e, t) { var i = t[e + "Buffer"]; return i && i.updating || t.queuePending[e] }, ti = function e(t, i) { if (0 !== i.queue.length) { var n = 0, r = i.queue[n]; if ("mediaSource" !== r.type) { if ("mediaSource" !== t && i.ready() && "closed" !== i.mediaSource.readyState && !ei(t, i)) { if (r.type !== t) { if (n = function (e, t) { for (var i = 0; i < t.length; i++) { var n = t[i]; if ("mediaSource" === n.type) return null; if (n.type === e) return i } return null }(t, i.queue), null === n) return; r = i.queue[n] } return i.queue.splice(n, 1), i.queuePending[t] = r, r.action(t, i), r.doneFn ? void 0 : (i.queuePending[t] = null, void e(t, i)) } } else i.updating() || "closed" === i.mediaSource.readyState || (i.queue.shift(), r.action(i), r.doneFn && r.doneFn(), e("audio", i), e("video", i)) } }, ii = function (e, t) { var i = t[e + "Buffer"], n = Jt(e); i && (i.removeEventListener("updateend", t["on" + n + "UpdateEnd_"]), i.removeEventListener("error", t["on" + n + "Error_"]), t.codecs[e] = null, t[e + "Buffer"] = null) }, ni = function (e, t) { return e && t && -1 !== Array.prototype.indexOf.call(e.sourceBuffers, t) }, ri = function (e, t, i) { return function (n, r) { var a = r[n + "Buffer"]; if (ni(r.mediaSource, a)) { r.logger_("Appending segment " + t.mediaIndex + "'s " + e.length + " bytes to " + n + "Buffer"); try { a.appendBuffer(e) } catch (e) { r.logger_("Error with code " + e.code + " " + (22 === e.code ? "(QUOTA_EXCEEDED_ERR) " : "") + "when appending segment " + t.mediaIndex + " to " + n + "Buffer"), r.queuePending[n] = null, i(e) } } } }, ai = function (e, t) { return function (i, n) { var r = n[i + "Buffer"]; if (ni(n.mediaSource, r)) { n.logger_("Removing " + e + " to " + t + " from " + i + "Buffer"); try { r.remove(e, t) } catch (r) { n.logger_("Remove " + e + " to " + t + " from " + i + "Buffer failed") } } } }, si = function (e) { return function (t, i) { var n = i[t + "Buffer"]; ni(i.mediaSource, n) && (i.logger_("Setting " + t + "timestampOffset to " + e), n.timestampOffset = e) } }, oi = function (e) { return function (t, i) { e() } }, ui = function (e) { return function (t) { if ("open" === t.mediaSource.readyState) { t.logger_("Calling mediaSource endOfStream(" + (e || "") + ")"); try { t.mediaSource.endOfStream(e) } catch (e) { n.default.log.warn("Failed to call media source endOfStream", e) } } } }, di = function (e, t) { return function (i) { var n = Jt(e), r = D(t); i.logger_("Adding " + e + "Buffer with codec " + t + " to mediaSource"); var a = i.mediaSource.addSourceBuffer(r); a.addEventListener("updateend", i["on" + n + "UpdateEnd_"]), a.addEventListener("error", i["on" + n + "Error_"]), i.codecs[e] = t, i[e + "Buffer"] = a } }, li = function (e) { return function (t) { var i = t[e + "Buffer"]; if (ii(e, t), ni(t.mediaSource, i)) { t.logger_("Removing " + e + "Buffer with codec " + t.codecs[e] + " from mediaSource"); try { t.mediaSource.removeSourceBuffer(i) } catch (t) { n.default.log.warn("Failed to removeSourceBuffer " + e + "Buffer", t) } } } }, hi = function (e) { return function (t, i) { var n = i[t + "Buffer"], r = D(e); ni(i.mediaSource, n) && i.codecs[t] !== e && (i.logger_("changing " + t + "Buffer codec from " + i.codecs[t] + " to " + e), n.changeType(r), i.codecs[t] = e) } }, ci = function (e) { var t = e.type, i = e.sourceUpdater, n = e.action, r = e.doneFn, a = e.name; i.queue.push({ type: t, action: n, doneFn: r, name: a }), ti(t, i) }, fi = function (e, t) { return function (i) { if (t.queuePending[e]) { var n = t.queuePending[e].doneFn; t.queuePending[e] = null, n && n(t[e + "Error_"]) } ti(e, t) } }, pi = function (e) { function t(t) { var i; return (i = e.call(this) || this).mediaSource = t, i.sourceopenListener_ = function () { return ti("mediaSource", a(i)) }, i.mediaSource.addEventListener("sourceopen", i.sourceopenListener_), i.logger_ = c("SourceUpdater"), i.audioTimestampOffset_ = 0, i.videoTimestampOffset_ = 0, i.queue = [], i.queuePending = { audio: null, video: null }, i.delayedAudioAppendQueue_ = [], i.videoAppendQueued_ = !1, i.codecs = {}, i.onVideoUpdateEnd_ = fi("video", a(i)), i.onAudioUpdateEnd_ = fi("audio", a(i)), i.onVideoError_ = function (e) { i.videoError_ = e }, i.onAudioError_ = function (e) { i.audioError_ = e }, i.createdSourceBuffers_ = !1, i.initializedEme_ = !1, i.triggeredReady_ = !1, i } o(t, e); var i = t.prototype; return i.initializedEme = function () { this.initializedEme_ = !0, this.triggerReady() }, i.hasCreatedSourceBuffers = function () { return this.createdSourceBuffers_ }, i.hasInitializedAnyEme = function () { return this.initializedEme_ }, i.ready = function () { return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme() }, i.createSourceBuffers = function (e) { this.hasCreatedSourceBuffers() || (this.addOrChangeSourceBuffers(e), this.createdSourceBuffers_ = !0, this.trigger("createdsourcebuffers"), this.triggerReady()) }, i.triggerReady = function () { this.ready() && !this.triggeredReady_ && (this.triggeredReady_ = !0, this.trigger("ready")) }, i.addSourceBuffer = function (e, t) { ci({ type: "mediaSource", sourceUpdater: this, action: di(e, t), name: "addSourceBuffer" }) }, i.abort = function (e) { ci({ type: e, sourceUpdater: this, action: function (e, t) { if ("open" === t.mediaSource.readyState) { var i = t[e + "Buffer"]; if (ni(t.mediaSource, i)) { t.logger_("calling abort on " + e + "Buffer"); try { i.abort() } catch (t) { n.default.log.warn("Failed to abort on " + e + "Buffer", t) } } } }, name: "abort" }) }, i.removeSourceBuffer = function (e) { this.canRemoveSourceBuffer() ? ci({ type: "mediaSource", sourceUpdater: this, action: li(e), name: "removeSourceBuffer" }) : n.default.log.error("removeSourceBuffer is not supported!") }, i.canRemoveSourceBuffer = function () { return !n.default.browser.IE_VERSION && !n.default.browser.IS_FIREFOX && window.MediaSource && window.MediaSource.prototype && "function" == typeof window.MediaSource.prototype.removeSourceBuffer }, t.canChangeType = function () { return window.SourceBuffer && window.SourceBuffer.prototype && "function" == typeof window.SourceBuffer.prototype.changeType }, i.canChangeType = function () { return this.constructor.canChangeType() }, i.changeType = function (e, t) { this.canChangeType() ? ci({ type: e, sourceUpdater: this, action: hi(t), name: "changeType" }) : n.default.log.error("changeType is not supported!") }, i.addOrChangeSourceBuffers = function (e) { var t = this; if (!e || "object" != typeof e || 0 === Object.keys(e).length) throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs"); Object.keys(e).forEach((function (i) { var n = e[i]; if (!t.hasCreatedSourceBuffers()) return t.addSourceBuffer(i, n); t.canChangeType() && t.changeType(i, n) })) }, i.appendBuffer = function (e, t) { var i = this, n = e.segmentInfo, r = e.type, a = e.bytes; if (this.processedAppend_ = !0, "audio" === r && this.videoBuffer && !this.videoAppendQueued_) return this.delayedAudioAppendQueue_.push([e, t]), void this.logger_("delayed audio append of " + a.length + " until video append"); if (ci({ type: r, sourceUpdater: this, action: ri(a, n || { mediaIndex: -1 }, t), doneFn: t, name: "appendBuffer" }), "video" === r) { if (this.videoAppendQueued_ = !0, !this.delayedAudioAppendQueue_.length) return; var s = this.delayedAudioAppendQueue_.slice(); this.logger_("queuing delayed audio " + s.length + " appendBuffers"), this.delayedAudioAppendQueue_.length = 0, s.forEach((function (e) { i.appendBuffer.apply(i, e) })) } }, i.audioBuffered = function () { return ni(this.mediaSource, this.audioBuffer) && this.audioBuffer.buffered ? this.audioBuffer.buffered : n.default.createTimeRange() }, i.videoBuffered = function () { return ni(this.mediaSource, this.videoBuffer) && this.videoBuffer.buffered ? this.videoBuffer.buffered : n.default.createTimeRange() }, i.buffered = function () { var e = ni(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null, t = ni(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null; return t && !e ? this.audioBuffered() : e && !t ? this.videoBuffered() : function (e, t) { var i = null, r = null, a = 0, s = [], o = []; if (!(e && e.length && t && t.length)) return n.default.createTimeRange(); for (var u = e.length; u--;)s.push({ time: e.start(u), type: "start" }), s.push({ time: e.end(u), type: "end" }); for (u = t.length; u--;)s.push({ time: t.start(u), type: "start" }), s.push({ time: t.end(u), type: "end" }); for (s.sort((function (e, t) { return e.time - t.time })), u = 0; u < s.length; u++)"start" === s[u].type ? 2 == ++a && (i = s[u].time) : "end" === s[u].type && 1 == --a && (r = s[u].time), null !== i && null !== r && (o.push([i, r]), i = null, r = null); return n.default.createTimeRanges(o) }(this.audioBuffered(), this.videoBuffered()) }, i.setDuration = function (e, t) { var i; void 0 === t && (t = Kt), ci({ type: "mediaSource", sourceUpdater: this, action: (i = e, function (e) { e.logger_("Setting mediaSource duration to " + i); try { e.mediaSource.duration = i } catch (e) { n.default.log.warn("Failed to set media source duration", e) } }), name: "duration", doneFn: t }) }, i.endOfStream = function (e, t) { void 0 === e && (e = null), void 0 === t && (t = Kt), "string" != typeof e && (e = void 0), ci({ type: "mediaSource", sourceUpdater: this, action: ui(e), name: "endOfStream", doneFn: t }) }, i.removeAudio = function (e, t, i) { void 0 === i && (i = Kt), this.audioBuffered().length && 0 !== this.audioBuffered().end(0) ? ci({ type: "audio", sourceUpdater: this, action: ai(e, t), doneFn: i, name: "remove" }) : i() }, i.removeVideo = function (e, t, i) { void 0 === i && (i = Kt), this.videoBuffered().length && 0 !== this.videoBuffered().end(0) ? ci({ type: "video", sourceUpdater: this, action: ai(e, t), doneFn: i, name: "remove" }) : i() }, i.updating = function () { return !(!ei("audio", this) && !ei("video", this)) }, i.audioTimestampOffset = function (e) { return void 0 !== e && this.audioBuffer && this.audioTimestampOffset_ !== e && (ci({ type: "audio", sourceUpdater: this, action: si(e), name: "timestampOffset" }), this.audioTimestampOffset_ = e), this.audioTimestampOffset_ }, i.videoTimestampOffset = function (e) { return void 0 !== e && this.videoBuffer && this.videoTimestampOffset !== e && (ci({ type: "video", sourceUpdater: this, action: si(e), name: "timestampOffset" }), this.videoTimestampOffset_ = e), this.videoTimestampOffset_ }, i.audioQueueCallback = function (e) { this.audioBuffer && ci({ type: "audio", sourceUpdater: this, action: oi(e), name: "callback" }) }, i.videoQueueCallback = function (e) { this.videoBuffer && ci({ type: "video", sourceUpdater: this, action: oi(e), name: "callback" }) }, i.dispose = function () { var e = this; this.trigger("dispose"), Zt.forEach((function (t) { e.abort(t), e.canRemoveSourceBuffer() ? e.removeSourceBuffer(t) : e[t + "QueueCallback"]((function () { return ii(t, e) })) })), this.videoAppendQueued_ = !1, this.delayedAudioAppendQueue_.length = 0, this.sourceopenListener_ && this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_), this.off() }, t }(n.default.EventTarget), mi = [{ name: "VOD", run: function (e, t, i, n, r) { return i !== 1 / 0 ? { time: 0, segmentIndex: 0, partIndex: null } : null } }, { name: "ProgramDateTime", run: function (e, t, i, n, r) { if (!Object.keys(e.timelineToDatetimeMappings).length) return null; var a = null, s = null, o = Q(t); r = r || 0; for (var u = 0; u < o.length; u++) { var d = o[t.endList || 0 === r ? u : o.length - (u + 1)], l = d.segment, h = e.timelineToDatetimeMappings[l.timeline]; if (h && l.dateTimeObject) { var c = l.dateTimeObject.getTime() / 1e3 + h; if (l.parts && "number" == typeof d.partIndex) for (var f = 0; f < d.partIndex; f++)c += l.parts[f].duration; var p = Math.abs(r - c); if (null !== s && (0 === p || s < p)) break; s = p, a = { time: c, segmentIndex: d.segmentIndex, partIndex: d.partIndex } } } return a } }, { name: "Segment", run: function (e, t, i, n, r) { var a = null, s = null; r = r || 0; for (var o = Q(t), u = 0; u < o.length; u++) { var d = o[t.endList || 0 === r ? u : o.length - (u + 1)], l = d.segment, h = d.part && d.part.start || l && l.start; if (l.timeline === n && void 0 !== h) { var c = Math.abs(r - h); if (null !== s && s < c) break; (!a || null === s || s >= c) && (s = c, a = { time: h, segmentIndex: d.segmentIndex, partIndex: d.partIndex }) } } return a } }, { name: "Discontinuity", run: function (e, t, i, n, r) { var a = null; if (r = r || 0, t.discontinuityStarts && t.discontinuityStarts.length) for (var s = null, o = 0; o < t.discontinuityStarts.length; o++) { var u = t.discontinuityStarts[o], d = t.discontinuitySequence + o + 1, l = e.discontinuities[d]; if (l) { var h = Math.abs(r - l.time); if (null !== s && s < h) break; (!a || null === s || s >= h) && (s = h, a = { time: l.time, segmentIndex: u, partIndex: null }) } } return a } }, { name: "Playlist", run: function (e, t, i, n, r) { return t.syncInfo ? { time: t.syncInfo.time, segmentIndex: t.syncInfo.mediaSequence - t.mediaSequence, partIndex: null } : null } }], gi = function (e) { function t(t) { var i; return (i = e.call(this) || this).timelines = [], i.discontinuities = [], i.timelineToDatetimeMappings = {}, i.logger_ = c("SyncController"), i } o(t, e); var i = t.prototype; return i.getSyncPoint = function (e, t, i, n) { var r = this.runStrategies_(e, t, i, n); return r.length ? this.selectSyncPoint_(r, { key: "time", value: n }) : null }, i.getExpiredTime = function (e, t) { if (!e || !e.segments) return null; var i = this.runStrategies_(e, t, e.discontinuitySequence, 0); if (!i.length) return null; var n = this.selectSyncPoint_(i, { key: "segmentIndex", value: 0 }); return n.segmentIndex > 0 && (n.time *= -1), Math.abs(n.time + Z({ defaultDuration: e.targetDuration, durationList: e.segments, startIndex: n.segmentIndex, endIndex: 0 })) }, i.runStrategies_ = function (e, t, i, n) { for (var r = [], a = 0; a < mi.length; a++) { var s = mi[a], o = s.run(this, e, t, i, n); o && (o.strategy = s.name, r.push({ strategy: s.name, syncPoint: o })) } return r }, i.selectSyncPoint_ = function (e, t) { for (var i = e[0].syncPoint, n = Math.abs(e[0].syncPoint[t.key] - t.value), r = e[0].strategy, a = 1; a < e.length; a++) { var s = Math.abs(e[a].syncPoint[t.key] - t.value); s < n && (n = s, i = e[a].syncPoint, r = e[a].strategy) } return this.logger_("syncPoint for [" + t.key + ": " + t.value + "] chosen with strategy [" + r + "]: [time:" + i.time + ", segmentIndex:" + i.segmentIndex + ("number" == typeof i.partIndex ? ",partIndex:" + i.partIndex : "") + "]"), i }, i.saveExpiredSegmentInfo = function (e, t) { var i = t.mediaSequence - e.mediaSequence; if (i > 86400) n.default.log.warn("Not saving expired segment info. Media sequence gap " + i + " is too large."); else for (var r = i - 1; r >= 0; r--) { var a = e.segments[r]; if (a && void 0 !== a.start) { t.syncInfo = { mediaSequence: e.mediaSequence + r, time: a.start }, this.logger_("playlist refresh sync: [time:" + t.syncInfo.time + ", mediaSequence: " + t.syncInfo.mediaSequence + "]"), this.trigger("syncinfoupdate"); break } } }, i.setDateTimeMappingForStart = function (e) { if (this.timelineToDatetimeMappings = {}, e.segments && e.segments.length && e.segments[0].dateTimeObject) { var t = e.segments[0], i = t.dateTimeObject.getTime() / 1e3; this.timelineToDatetimeMappings[t.timeline] = -i } }, i.saveSegmentTimingInfo = function (e) { var t = e.segmentInfo, i = e.shouldSaveTimelineMapping, n = this.calculateSegmentTimeMapping_(t, t.timingInfo, i), r = t.segment; n && (this.saveDiscontinuitySyncInfo_(t), t.playlist.syncInfo || (t.playlist.syncInfo = { mediaSequence: t.playlist.mediaSequence + t.mediaIndex, time: r.start })); var a = r.dateTimeObject; r.discontinuity && i && a && (this.timelineToDatetimeMappings[r.timeline] = -a.getTime() / 1e3) }, i.timestampOffsetForTimeline = function (e) { return void 0 === this.timelines[e] ? null : this.timelines[e].time }, i.mappingForTimeline = function (e) { return void 0 === this.timelines[e] ? null : this.timelines[e].mapping }, i.calculateSegmentTimeMapping_ = function (e, t, i) { var n, r, a = e.segment, s = e.part, o = this.timelines[e.timeline]; if ("number" == typeof e.timestampOffset) o = { time: e.startOfSegment, mapping: e.startOfSegment - t.start }, i && (this.timelines[e.timeline] = o, this.trigger("timestampoffset"), this.logger_("time mapping for timeline " + e.timeline + ": [time: " + o.time + "] [mapping: " + o.mapping + "]")), n = e.startOfSegment, r = t.end + o.mapping; else { if (!o) return !1; n = t.start + o.mapping, r = t.end + o.mapping } return s && (s.start = n, s.end = r), (!a.start || n < a.start) && (a.start = n), a.end = r, !0 }, i.saveDiscontinuitySyncInfo_ = function (e) { var t = e.playlist, i = e.segment; if (i.discontinuity) this.discontinuities[i.timeline] = { time: i.start, accuracy: 0 }; else if (t.discontinuityStarts && t.discontinuityStarts.length) for (var n = 0; n < t.discontinuityStarts.length; n++) { var r = t.discontinuityStarts[n], a = t.discontinuitySequence + n + 1, s = r - e.mediaIndex, o = Math.abs(s); if (!this.discontinuities[a] || this.discontinuities[a].accuracy > o) { var u; u = s < 0 ? i.start - Z({ defaultDuration: t.targetDuration, durationList: t.segments, startIndex: e.mediaIndex, endIndex: r }) : i.end + Z({ defaultDuration: t.targetDuration, durationList: t.segments, startIndex: e.mediaIndex + 1, endIndex: r }), this.discontinuities[a] = { time: u, accuracy: o } } } }, i.dispose = function () { this.trigger("dispose"), this.off() }, t }(n.default.EventTarget), yi = function (e) { function t() { var t; return (t = e.call(this) || this).pendingTimelineChanges_ = {}, t.lastTimelineChanges_ = {}, t } o(t, e); var i = t.prototype; return i.clearPendingTimelineChange = function (e) { this.pendingTimelineChanges_[e] = null, this.trigger("pendingtimelinechange") }, i.pendingTimelineChange = function (e) { var t = e.type, i = e.from, n = e.to; return "number" == typeof i && "number" == typeof n && (this.pendingTimelineChanges_[t] = { type: t, from: i, to: n }, this.trigger("pendingtimelinechange")), this.pendingTimelineChanges_[t] }, i.lastTimelineChange = function (e) { var t = e.type, i = e.from, n = e.to; return "number" == typeof i && "number" == typeof n && (this.lastTimelineChanges_[t] = { type: t, from: i, to: n }, delete this.pendingTimelineChanges_[t], this.trigger("timelinechange")), this.lastTimelineChanges_[t] }, i.dispose = function () { this.trigger("dispose"), this.pendingTimelineChanges_ = {}, this.lastTimelineChanges_ = {}, this.off() }, t }(n.default.EventTarget), _i = Qe(ze((function () {
		var e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function t(e, t, i) { return e(i = { path: t, exports: {}, require: function (e, t) { return function () { throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs") }(null == t && i.path) } }, i.exports), i.exports } var i = t((function (e) { function t(e, t) { for (var i = 0; i < t.length; i++) { var n = t[i]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } e.exports = function (e, i, n) { return i && t(e.prototype, i), n && t(e, n), e }, e.exports.default = e.exports, e.exports.__esModule = !0 })), n = t((function (e) { function t(i, n) { return e.exports = t = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e }, e.exports.default = e.exports, e.exports.__esModule = !0, t(i, n) } e.exports = t, e.exports.default = e.exports, e.exports.__esModule = !0 })), r = t((function (e) { e.exports = function (e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, n(e, t) }, e.exports.default = e.exports, e.exports.__esModule = !0 })), a = function () { function e() { this.listeners = {} } var t = e.prototype; return t.on = function (e, t) { this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t) }, t.off = function (e, t) { if (!this.listeners[e]) return !1; var i = this.listeners[e].indexOf(t); return this.listeners[e] = this.listeners[e].slice(0), this.listeners[e].splice(i, 1), i > -1 }, t.trigger = function (e) { var t = this.listeners[e]; if (t) if (2 === arguments.length) for (var i = t.length, n = 0; n < i; ++n)t[n].call(this, arguments[1]); else for (var r = Array.prototype.slice.call(arguments, 1), a = t.length, s = 0; s < a; ++s)t[s].apply(this, r) }, t.dispose = function () { this.listeners = {} }, t.pipe = function (e) { this.on("data", (function (t) { e.push(t) })) }, e }(), s = null, o = function () { function e(e) { var t, i, n; s || (s = function () { var e, t, i, n, r, a, s, o, u = [[[], [], [], [], []], [[], [], [], [], []]], d = u[0], l = u[1], h = d[4], c = l[4], f = [], p = []; for (e = 0; e < 256; e++)p[(f[e] = e << 1 ^ 283 * (e >> 7)) ^ e] = e; for (t = i = 0; !h[t]; t ^= n || 1, i = p[i] || 1)for (a = (a = i ^ i << 1 ^ i << 2 ^ i << 3 ^ i << 4) >> 8 ^ 255 & a ^ 99, h[t] = a, c[a] = t, o = 16843009 * f[r = f[n = f[t]]] ^ 65537 * r ^ 257 * n ^ 16843008 * t, s = 257 * f[a] ^ 16843008 * a, e = 0; e < 4; e++)d[e][t] = s = s << 24 ^ s >>> 8, l[e][a] = o = o << 24 ^ o >>> 8; for (e = 0; e < 5; e++)d[e] = d[e].slice(0), l[e] = l[e].slice(0); return u }()), this._tables = [[s[0][0].slice(), s[0][1].slice(), s[0][2].slice(), s[0][3].slice(), s[0][4].slice()], [s[1][0].slice(), s[1][1].slice(), s[1][2].slice(), s[1][3].slice(), s[1][4].slice()]]; var r = this._tables[0][4], a = this._tables[1], o = e.length, u = 1; if (4 !== o && 6 !== o && 8 !== o) throw new Error("Invalid aes key size"); var d = e.slice(0), l = []; for (this._key = [d, l], t = o; t < 4 * o + 28; t++)n = d[t - 1], (t % o == 0 || 8 === o && t % o == 4) && (n = r[n >>> 24] << 24 ^ r[n >> 16 & 255] << 16 ^ r[n >> 8 & 255] << 8 ^ r[255 & n], t % o == 0 && (n = n << 8 ^ n >>> 24 ^ u << 24, u = u << 1 ^ 283 * (u >> 7))), d[t] = d[t - o] ^ n; for (i = 0; t; i++, t--)n = d[3 & i ? t : t - 4], l[i] = t <= 4 || i < 4 ? n : a[0][r[n >>> 24]] ^ a[1][r[n >> 16 & 255]] ^ a[2][r[n >> 8 & 255]] ^ a[3][r[255 & n]] } return e.prototype.decrypt = function (e, t, i, n, r, a) { var s, o, u, d, l = this._key[1], h = e ^ l[0], c = n ^ l[1], f = i ^ l[2], p = t ^ l[3], m = l.length / 4 - 2, g = 4, y = this._tables[1], _ = y[0], v = y[1], b = y[2], T = y[3], S = y[4]; for (d = 0; d < m; d++)s = _[h >>> 24] ^ v[c >> 16 & 255] ^ b[f >> 8 & 255] ^ T[255 & p] ^ l[g], o = _[c >>> 24] ^ v[f >> 16 & 255] ^ b[p >> 8 & 255] ^ T[255 & h] ^ l[g + 1], u = _[f >>> 24] ^ v[p >> 16 & 255] ^ b[h >> 8 & 255] ^ T[255 & c] ^ l[g + 2], p = _[p >>> 24] ^ v[h >> 16 & 255] ^ b[c >> 8 & 255] ^ T[255 & f] ^ l[g + 3], g += 4, h = s, c = o, f = u; for (d = 0; d < 4; d++)r[(3 & -d) + a] = S[h >>> 24] << 24 ^ S[c >> 16 & 255] << 16 ^ S[f >> 8 & 255] << 8 ^ S[255 & p] ^ l[g++], s = h, h = c, c = f, f = p, p = s }, e }(), u = function (e) { function t() { var t; return (t = e.call(this, a) || this).jobs = [], t.delay = 1, t.timeout_ = null, t } r(t, e); var i = t.prototype; return i.processJob_ = function () { this.jobs.shift()(), this.jobs.length ? this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay) : this.timeout_ = null }, i.push = function (e) { this.jobs.push(e), this.timeout_ || (this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay)) }, t }(a), d = function (e) { return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24 }, l = function () {
			function e(t, i, n, r) {
				var a = e.STEP, s = new Int32Array(t.buffer), o = new Uint8Array(t.byteLength), l = 0; for (this.asyncStream_ = new u, this.asyncStream_.push(this.decryptChunk_(s.subarray(l, l + a), i, n, o)), l = a; l < s.length; l += a)n = new Uint32Array([d(s[l - 4]), d(s[l - 3]), d(s[l - 2]), d(s[l - 1])]), this.asyncStream_.push(this.decryptChunk_(s.subarray(l, l + a), i, n, o)); this.asyncStream_.push((function () {
					/*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */
					var e;
/*! @name aes-decrypter @version 3.1.3 @license Apache-2.0 */r(null, (e = o).subarray(0, e.byteLength - e[e.byteLength - 1]))
				}))
			} return e.prototype.decryptChunk_ = function (e, t, i, n) { return function () { var r = function (e, t, i) { var n, r, a, s, u, l, h, c, f, p = new Int32Array(e.buffer, e.byteOffset, e.byteLength >> 2), m = new o(Array.prototype.slice.call(t)), g = new Uint8Array(e.byteLength), y = new Int32Array(g.buffer); for (n = i[0], r = i[1], a = i[2], s = i[3], f = 0; f < p.length; f += 4)u = d(p[f]), l = d(p[f + 1]), h = d(p[f + 2]), c = d(p[f + 3]), m.decrypt(u, l, h, c, y, f), y[f] = d(y[f] ^ n), y[f + 1] = d(y[f + 1] ^ r), y[f + 2] = d(y[f + 2] ^ a), y[f + 3] = d(y[f + 3] ^ s), n = u, r = l, a = h, s = c; return g }(e, t, i); n.set(r, e.byteOffset) } }, i(e, null, [{ key: "STEP", get: function () { return 32e3 } }]), e
		}(), h = ("undefined" != typeof window ? window : void 0 !== e ? e : "undefined" != typeof self ? self : {}).BigInt || Number; h("0x1"), h("0x100"), h("0x10000"), h("0x1000000"), h("0x100000000"), h("0x10000000000"), h("0x1000000000000"), h("0x100000000000000"), h("0x10000000000000000"), function () { var e = new Uint16Array([65484]), t = new Uint8Array(e.buffer, e.byteOffset, e.byteLength); 255 === t[0] || t[0] }(); self.onmessage = function (e) { var t = e.data, i = new Uint8Array(t.encrypted.bytes, t.encrypted.byteOffset, t.encrypted.byteLength), n = new Uint32Array(t.key.bytes, t.key.byteOffset, t.key.byteLength / 4), r = new Uint32Array(t.iv.bytes, t.iv.byteOffset, t.iv.byteLength / 4); new l(i, n, r, (function (e, i) { var n, r; self.postMessage((n = { source: t.source, decrypted: i }, r = {}, Object.keys(n).forEach((function (e) { var t, i = n[e]; t = i, ("function" === ArrayBuffer.isView ? ArrayBuffer.isView(t) : t && t.buffer instanceof ArrayBuffer) ? r[e] = { bytes: i.buffer, byteOffset: i.byteOffset, byteLength: i.byteLength } : r[e] = i })), r), [i.buffer]) })) }
	}))), vi = Xe(_i), bi = function (e) { var t = e.default ? "main" : "alternative"; return e.characteristics && e.characteristics.indexOf("public.accessibility.describes-video") >= 0 && (t = "main-desc"), t }, Ti = function (e, t) { e.abort(), e.pause(), t && t.activePlaylistLoader && (t.activePlaylistLoader.pause(), t.activePlaylistLoader = null) }, Si = function (e, t) { t.activePlaylistLoader = e, e.load() }, wi = { AUDIO: function (e, t) { return function () { var i = t.segmentLoaders[e], r = t.mediaTypes[e], a = t.blacklistCurrentPlaylist; Ti(i, r); var s = r.activeTrack(), o = r.activeGroup(), u = (o.filter((function (e) { return e.default }))[0] || o[0]).id, d = r.tracks[u]; if (s !== d) { for (var l in n.default.log.warn("Problem encountered loading the alternate audio track.Switching back to default."), r.tracks) r.tracks[l].enabled = r.tracks[l] === d; r.onTrackChanged() } else a({ message: "Problem encountered loading the default audio track." }) } } }, Ii = { AUDIO: function (e, t, i) { if (t) { var n = i.tech, r = i.requestOptions, a = i.segmentLoaders[e]; t.on("loadedmetadata", (function () { var e = t.media(); a.playlist(e, r), (!n.paused() || e.endList && "none" !== n.preload()) && a.load() })), t.on("loadedplaylist", (function () { a.playlist(t.media(), r), n.paused() || a.load() })), t.on("error", wi[e](e, i)) } } }, Ei = { AUDIO: function (e, t) { var i = t.vhs, r = t.sourceType, a = t.segmentLoaders[e], s = t.requestOptions, o = t.master.mediaGroups, u = t.mediaTypes[e], d = u.groups, l = u.tracks, h = u.logger_, c = t.masterPlaylistLoader, f = ue(c.master); for (var p in o[e] && 0 !== Object.keys(o[e]).length || (o[e] = { main: { default: { default: !0 } } }, f && (o[e].main.default.playlists = c.master.playlists)), o[e]) for (var m in d[p] || (d[p] = []), o[e][p]) { var g = o[e][p][m], y = void 0; if (f ? (h("AUDIO group '" + p + "' label '" + m + "' is a master playlist"), g.isMasterPlaylist = !0, y = null) : y = "vhs-json" === r && g.playlists ? new Te(g.playlists[0], i, s) : g.resolvedUri ? new Te(g.resolvedUri, i, s) : null, g = n.default.mergeOptions({ id: m, playlistLoader: y }, g), Ii[e](e, g.playlistLoader, t), d[p].push(g), void 0 === l[m]) { var _ = new n.default.AudioTrack({ id: m, kind: bi(g), enabled: !1, language: g.language, default: g.default, label: m }); l[m] = _ } } a.on("error", wi[e](e, t)) } }, Ai = function e(t, i) { for (var n = 0; n < t.length; n++) { if (se(i, t[n])) return !0; if (t[n].playlists && e(t[n].playlists, i)) return !0 } return !1 }, Li = { AUDIO: function (e, t) { return function () { var i = t.mediaTypes[e].tracks; for (var n in i) if (i[n].enabled) return i[n]; return null } } }, ki = ["mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred", "mediaAppends"], xi = function (e) { return this.audioSegmentLoader_[e] + this.mainSegmentLoader_[e] }, Pi = function (e) { function t(t) { var i; i = e.call(this) || this; var r = t.src, s = t.handleManifestRedirects, o = t.withCredentials, u = t.tech, d = t.bandwidth, l = t.externVhs, h = t.blacklistDuration, f = t.enableLowInitialPlaylist, p = t.sourceType, m = t.cacheEncryptionKeys, g = t.experimentalBufferBasedABR, y = t.experimentalLeastPixelDiffSelector; if (!r) throw new Error("A non-empty playlist URL or JSON manifest string is required"); var _ = t.maxPlaylistRetries; null == _ && (_ = 1 / 0), $t = l, i.experimentalBufferBasedABR = Boolean(g), i.experimentalLeastPixelDiffSelector = Boolean(y), i.withCredentials = o, i.tech_ = u, i.vhs_ = u.vhs, i.sourceType_ = p, i.blacklistDuration = h, i.maxPlaylistRetries = _, i.enableLowInitialPlaylist = f, i.requestOptions_ = { withCredentials: o, handleManifestRedirects: s, maxPlaylistRetries: _, timeout: null }, i.on("error", i.pauseLoading), i.mediaTypes_ = function () { var e = {}; return ["AUDIO"].forEach((function (t) { e[t] = { groups: {}, tracks: {}, activePlaylistLoader: null, activeGroup: Kt, activeTrack: Kt, getActiveGroup: Kt, onGroupChanged: Kt, onTrackChanged: Kt, lastTrack_: null, logger_: c("MediaGroups[" + t + "]") } })), e }(), i.mediaSource = new window.MediaSource, i.handleDurationChange_ = i.handleDurationChange_.bind(a(i)), i.handleSourceOpen_ = i.handleSourceOpen_.bind(a(i)), i.handleSourceEnded_ = i.handleSourceEnded_.bind(a(i)), i.mediaSource.addEventListener("durationchange", i.handleDurationChange_), i.mediaSource.addEventListener("sourceopen", i.handleSourceOpen_), i.mediaSource.addEventListener("sourceended", i.handleSourceEnded_), i.seekable_ = n.default.createTimeRanges(), i.hasPlayed_ = !1, i.syncController_ = new gi(t), i.segmentMetadataTrack_ = u.addRemoteTextTrack({ kind: "metadata", label: "segment-metadata" }, !1).track, i.decrypter_ = new vi, i.sourceUpdater_ = new pi(i.mediaSource), i.inbandTextTracks_ = {}, i.timelineChangeController_ = new yi; var v = { vhs: i.vhs_, useDtsForTimestampOffset: t.useDtsForTimestampOffset, mediaSource: i.mediaSource, currentTime: i.tech_.currentTime.bind(i.tech_), seekable: function () { return i.seekable() }, seeking: function () { return i.tech_.seeking() }, duration: function () { return i.duration() }, hasPlayed: function () { return i.hasPlayed_ }, goalBufferLength: function () { return i.goalBufferLength() }, bandwidth: d, syncController: i.syncController_, decrypter: i.decrypter_, sourceType: i.sourceType_, inbandTextTracks: i.inbandTextTracks_, cacheEncryptionKeys: m, sourceUpdater: i.sourceUpdater_, timelineChangeController: i.timelineChangeController_, experimentalExactManifestTimings: t.experimentalExactManifestTimings }; i.masterPlaylistLoader_ = new Te(r, i.vhs_, i.requestOptions_), i.setupMasterPlaylistLoaderListeners_(), i.mainSegmentLoader_ = new Yt(n.default.mergeOptions(v, { segmentMetadataTrack: i.segmentMetadataTrack_, loaderType: "main" }), t), i.audioSegmentLoader_ = new Yt(n.default.mergeOptions(v, { loaderType: "audio" }), t), i.setupSegmentLoaderListeners_(), i.experimentalBufferBasedABR && (i.masterPlaylistLoader_.one("loadedplaylist", (function () { return i.startABRTimer_() })), i.tech_.on("pause", (function () { return i.stopABRTimer_() })), i.tech_.on("play", (function () { return i.startABRTimer_() }))), ki.forEach((function (e) { i[e + "_"] = xi.bind(a(i), e) })), i.logger_ = c("MPC"), i.triggeredFmp4Usage = !1, "none" === i.tech_.preload() ? (i.loadOnPlay_ = function () { i.loadOnPlay_ = null, i.masterPlaylistLoader_.load() }, i.tech_.one("play", i.loadOnPlay_)) : i.masterPlaylistLoader_.load(), i.timeToLoadedData__ = -1, i.mainAppendsToLoadedData__ = -1, i.audioAppendsToLoadedData__ = -1; var b = "none" === i.tech_.preload() ? "play" : "loadstart"; return i.tech_.one(b, (function () { var e = Date.now(); i.tech_.one("loadeddata", (function () { i.timeToLoadedData__ = Date.now() - e, i.mainAppendsToLoadedData__ = i.mainSegmentLoader_.mediaAppends, i.audioAppendsToLoadedData__ = i.audioSegmentLoader_.mediaAppends })) })), i } o(t, e); var i = t.prototype; return i.mainAppendsToLoadedData_ = function () { return this.mainAppendsToLoadedData__ }, i.audioAppendsToLoadedData_ = function () { return this.audioAppendsToLoadedData__ }, i.appendsToLoadedData_ = function () { var e = this.mainAppendsToLoadedData_(), t = this.audioAppendsToLoadedData_(); return -1 === e || -1 === t ? -1 : e + t }, i.timeToLoadedData_ = function () { return this.timeToLoadedData__ }, i.checkABR_ = function () { var e = this.selectPlaylist(); e && this.shouldSwitchToMedia_(e) && this.switchMedia_(e, "abr") }, i.switchMedia_ = function (e, t, i) { var n = this.media(), r = n && (n.id || n.uri), a = e.id || e.uri; r && r !== a && (this.logger_("switch media " + r + " -> " + a + " from " + t), this.tech_.trigger({ type: "usage", name: "vhs-rendition-change-" + t })), this.masterPlaylistLoader_.media(e, i) }, i.startABRTimer_ = function () { var e = this; this.stopABRTimer_(), this.abrTimer_ = window.setInterval((function () { return e.checkABR_() }), 250) }, i.stopABRTimer_ = function () { this.tech_.scrubbing && this.tech_.scrubbing() || (window.clearInterval(this.abrTimer_), this.abrTimer_ = null) }, i.getAudioTrackPlaylists_ = function () { var e = this.master(), t = e && e.playlists || []; if (!e || !e.mediaGroups || !e.mediaGroups.AUDIO) return t; var i, n = e.mediaGroups.AUDIO, r = Object.keys(n); if (Object.keys(this.mediaTypes_.AUDIO.groups).length) i = this.mediaTypes_.AUDIO.activeTrack(); else { var a = n.main || r.length && n[r[0]]; for (var s in a) if (a[s].default) { i = { label: s }; break } } if (!i) return t; var o = []; for (var u in n) if (n[u][i.label]) { var d = n[u][i.label]; if (d.playlists && d.playlists.length) o.push.apply(o, d.playlists); else if (d.uri) o.push(d); else if (e.playlists.length) for (var l = 0; l < e.playlists.length; l++) { var h = e.playlists[l]; h.attributes && h.attributes.AUDIO && h.attributes.AUDIO === u && o.push(h) } } return o.length ? o : t }, i.setupMasterPlaylistLoaderListeners_ = function () { var e = this; this.masterPlaylistLoader_.on("loadedmetadata", (function () { var t = e.masterPlaylistLoader_.media(), i = 1.5 * t.targetDuration * 1e3; ae(e.masterPlaylistLoader_.master, e.masterPlaylistLoader_.media()) ? e.requestOptions_.timeout = 0 : e.requestOptions_.timeout = i, t.endList && "none" !== e.tech_.preload() && (e.mainSegmentLoader_.playlist(t, e.requestOptions_), e.mainSegmentLoader_.load()), function (e) { ["AUDIO"].forEach((function (t) { Ei[t](t, e) })); var t = e.mediaTypes, i = e.masterPlaylistLoader, n = e.tech, r = e.vhs, a = e.segmentLoaders, s = a.AUDIO, o = a.main;["AUDIO"].forEach((function (i) { t[i].activeGroup = function (e, t) { return function (i) { var n = t.masterPlaylistLoader, r = t.mediaTypes[e].groups, a = n.media(); if (!a) return null; var s = null; a.attributes[e] && (s = r[a.attributes[e]]); var o = Object.keys(r); if (!s) if ("AUDIO" === e && o.length > 1 && ue(t.master)) for (var u = 0; u < o.length; u++) { var d = r[o[u]]; if (Ai(d, a)) { s = d; break } } else r.main ? s = r.main : 1 === o.length && (s = r[o[0]]); return void 0 === i ? s : null !== i && s && s.filter((function (e) { return e.id === i.id }))[0] || null } }(i, e), t[i].activeTrack = Li[i](i, e), t[i].onGroupChanged = function (e, t) { return function () { var i = t.segmentLoaders, n = i[e], r = i.main, a = t.mediaTypes[e], s = a.activeTrack(), o = a.getActiveGroup(), u = a.activePlaylistLoader, d = a.lastGroup_; o && d && o.id === d.id || (a.lastGroup_ = o, a.lastTrack_ = s, Ti(n, a), o && !o.isMasterPlaylist && (o.playlistLoader ? (n.resyncLoader(), Si(o.playlistLoader, a)) : u && r.resetEverything())) } }(i, e), t[i].onGroupChanging = function (e, t) { return function () { var i = t.segmentLoaders[e]; t.mediaTypes[e].lastGroup_ = null, i.abort(), i.pause() } }(i, e), t[i].onTrackChanged = function (e, t) { return function () { var i = t.masterPlaylistLoader, n = t.segmentLoaders, r = n[e], a = n.main, s = t.mediaTypes[e], o = s.activeTrack(), u = s.getActiveGroup(), d = s.activePlaylistLoader, l = s.lastTrack_; if ((!l || !o || l.id !== o.id) && (s.lastGroup_ = u, s.lastTrack_ = o, Ti(r, s), u)) { if (u.isMasterPlaylist) { if (!o || !l || o.id === l.id) return; var h = t.vhs.masterPlaylistController_, c = h.selectPlaylist(); if (h.media() === c) return; return s.logger_("track change. Switching master audio from " + l.id + " to " + o.id), i.pause(), a.resetEverything(), void h.fastQualityChange_(c) } if ("AUDIO" === e) { if (!u.playlistLoader) return a.setAudio(!0), void a.resetEverything(); r.setAudio(!0), a.setAudio(!1) } d !== u.playlistLoader ? (r.track && r.track(o), r.resetEverything(), Si(u.playlistLoader, s)) : Si(u.playlistLoader, s) } } }(i, e), t[i].getActiveGroup = function (e, t) { var i = t.mediaTypes; return function () { var t = i[e].activeTrack(); return t ? i[e].activeGroup(t) : null } }(i, e) })); var u = t.AUDIO.activeGroup(); if (u) { var d = (u.filter((function (e) { return e.default }))[0] || u[0]).id; t.AUDIO.tracks[d].enabled = !0, t.AUDIO.onGroupChanged(), t.AUDIO.onTrackChanged(), t.AUDIO.getActiveGroup().playlistLoader ? (o.setAudio(!1), s.setAudio(!0)) : o.setAudio(!0) } i.on("mediachange", (function () { ["AUDIO"].forEach((function (e) { return t[e].onGroupChanged() })) })), i.on("mediachanging", (function () { ["AUDIO"].forEach((function (e) { return t[e].onGroupChanging() })) })); var l = function () { t.AUDIO.onTrackChanged(), n.trigger({ type: "usage", name: "vhs-audio-change" }), n.trigger({ type: "usage", name: "hls-audio-change" }) }; for (var h in n.audioTracks().addEventListener("change", l), r.on("dispose", (function () { n.audioTracks().removeEventListener("change", l) })), n.clearTracks("audio"), t.AUDIO.tracks) n.audioTracks().addTrack(t.AUDIO.tracks[h]) }({ sourceType: e.sourceType_, segmentLoaders: { AUDIO: e.audioSegmentLoader_, main: e.mainSegmentLoader_ }, tech: e.tech_, requestOptions: e.requestOptions_, masterPlaylistLoader: e.masterPlaylistLoader_, vhs: e.vhs_, master: e.master(), mediaTypes: e.mediaTypes_, blacklistCurrentPlaylist: e.blacklistCurrentPlaylist.bind(e) }), e.triggerPresenceUsage_(e.master(), t), e.setupFirstPlay(), !e.mediaTypes_.AUDIO.activePlaylistLoader || e.mediaTypes_.AUDIO.activePlaylistLoader.media() ? e.trigger("selectedinitialmedia") : e.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", (function () { e.trigger("selectedinitialmedia") })) })), this.masterPlaylistLoader_.on("loadedplaylist", (function () { e.loadOnPlay_ && e.tech_.off("play", e.loadOnPlay_); var t = e.masterPlaylistLoader_.media(); if (!t) { var i; if (e.excludeUnsupportedVariants_(), e.enableLowInitialPlaylist && (i = e.selectInitialPlaylist()), i || (i = e.selectPlaylist()), !i || !e.shouldSwitchToMedia_(i)) return; if (e.initialMedia_ = i, e.switchMedia_(e.initialMedia_, "initial"), "vhs-json" !== e.sourceType_ || !e.initialMedia_.segments) return; t = e.initialMedia_ } e.handleUpdatedMediaPlaylist(t) })), this.masterPlaylistLoader_.on("error", (function () { e.blacklistCurrentPlaylist(e.masterPlaylistLoader_.error) })), this.masterPlaylistLoader_.on("mediachanging", (function () { e.mainSegmentLoader_.abort(), e.mainSegmentLoader_.pause() })), this.masterPlaylistLoader_.on("mediachange", (function () { var t = e.masterPlaylistLoader_.media(), i = 1.5 * t.targetDuration * 1e3; ae(e.masterPlaylistLoader_.master, e.masterPlaylistLoader_.media()) ? e.requestOptions_.timeout = 0 : e.requestOptions_.timeout = i, e.mainSegmentLoader_.playlist(t, e.requestOptions_), e.mainSegmentLoader_.load(), e.tech_.trigger({ type: "mediachange", bubbles: !0 }) })), this.masterPlaylistLoader_.on("playlistunchanged", (function () { var t = e.masterPlaylistLoader_.media(); "playlist-unchanged" !== t.lastExcludeReason_ && e.stuckAtPlaylistEnd_(t) && (e.blacklistCurrentPlaylist({ message: "Playlist no longer updating.", reason: "playlist-unchanged" }), e.tech_.trigger("playliststuck")) })), this.masterPlaylistLoader_.on("renditiondisabled", (function () { e.tech_.trigger({ type: "usage", name: "vhs-rendition-disabled" }), e.tech_.trigger({ type: "usage", name: "hls-rendition-disabled" }) })), this.masterPlaylistLoader_.on("renditionenabled", (function () { e.tech_.trigger({ type: "usage", name: "vhs-rendition-enabled" }), e.tech_.trigger({ type: "usage", name: "hls-rendition-enabled" }) })) }, i.handleUpdatedMediaPlaylist = function (e) { this.mainSegmentLoader_.playlist(e, this.requestOptions_), this.updateDuration(!e.endList), this.tech_.paused() || (this.mainSegmentLoader_.load(), this.audioSegmentLoader_ && this.audioSegmentLoader_.load()) }, i.triggerPresenceUsage_ = function (e, t) { var i = e.mediaGroups || {}, n = !0, r = Object.keys(i.AUDIO); for (var a in i.AUDIO) for (var s in i.AUDIO[a]) i.AUDIO[a][s].uri || (n = !1); n && (this.tech_.trigger({ type: "usage", name: "vhs-demuxed" }), this.tech_.trigger({ type: "usage", name: "hls-demuxed" })), $t.Playlist.isAes(t) && (this.tech_.trigger({ type: "usage", name: "vhs-aes" }), this.tech_.trigger({ type: "usage", name: "hls-aes" })), r.length && Object.keys(i.AUDIO[r[0]]).length > 1 && (this.tech_.trigger({ type: "usage", name: "vhs-alternate-audio" }), this.tech_.trigger({ type: "usage", name: "hls-alternate-audio" })) }, i.shouldSwitchToMedia_ = function (e) { var t = this.masterPlaylistLoader_.media() || this.masterPlaylistLoader_.pendingMedia_, i = this.tech_.currentTime(), r = this.bufferLowWaterLine(), a = this.bufferHighWaterLine(); return function (e) { var t = e.currentPlaylist, i = e.buffered, r = e.currentTime, a = e.nextPlaylist, s = e.bufferLowWaterLine, o = e.bufferHighWaterLine, u = e.duration, d = e.experimentalBufferBasedABR, l = e.log; if (!a) return n.default.log.warn("We received no playlist to switch to. Please check your stream."), !1; var h = "allowing switch " + (t && t.id || "null") + " -> " + a.id; if (!t) return l(h + " as current playlist is not set"), !0; if (a.id === t.id) return !1; var c = Boolean(N(i, r).length); if (!t.endList) return c || "number" != typeof t.partTargetDuration ? (l(h + " as current playlist is live"), !0) : (l("not " + h + " as current playlist is live llhls, but currentTime isn't in buffered."), !1); var f = V(i, r), p = d ? Ve.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Ve.MAX_BUFFER_LOW_WATER_LINE; if (u < p) return l(h + " as duration < max low water line (" + u + " < " + p + ")"), !0; var m = a.attributes.BANDWIDTH, g = t.attributes.BANDWIDTH; if (m < g && (!d || f < o)) { var y = h + " as next bandwidth < current bandwidth (" + m + " < " + g + ")"; return d && (y += " and forwardBuffer < bufferHighWaterLine (" + f + " < " + o + ")"), l(y), !0 } if ((!d || m > g) && f >= s) { var _ = h + " as forwardBuffer >= bufferLowWaterLine (" + f + " >= " + s + ")"; return d && (_ += " and next bandwidth > current bandwidth (" + m + " > " + g + ")"), l(_), !0 } return l("not " + h + " as no switching criteria met"), !1 }({ buffered: this.tech_.buffered(), currentTime: i, currentPlaylist: t, nextPlaylist: e, bufferLowWaterLine: r, bufferHighWaterLine: a, duration: this.duration(), experimentalBufferBasedABR: this.experimentalBufferBasedABR, log: this.logger_ }) }, i.setupSegmentLoaderListeners_ = function () { var e = this; this.experimentalBufferBasedABR || (this.mainSegmentLoader_.on("bandwidthupdate", (function () { var t = e.selectPlaylist(); e.shouldSwitchToMedia_(t) && e.switchMedia_(t, "bandwidthupdate"), e.tech_.trigger("bandwidthupdate") })), this.mainSegmentLoader_.on("progress", (function () { e.trigger("progress") }))), this.mainSegmentLoader_.on("error", (function () { e.blacklistCurrentPlaylist(e.mainSegmentLoader_.error()) })), this.mainSegmentLoader_.on("appenderror", (function () { e.error = e.mainSegmentLoader_.error_, e.trigger("error") })), this.mainSegmentLoader_.on("syncinfoupdate", (function () { e.onSyncInfoUpdate_() })), this.mainSegmentLoader_.on("timestampoffset", (function () { e.tech_.trigger({ type: "usage", name: "vhs-timestamp-offset" }), e.tech_.trigger({ type: "usage", name: "hls-timestamp-offset" }) })), this.audioSegmentLoader_.on("syncinfoupdate", (function () { e.onSyncInfoUpdate_() })), this.audioSegmentLoader_.on("appenderror", (function () { e.error = e.audioSegmentLoader_.error_, e.trigger("error") })), this.mainSegmentLoader_.on("ended", (function () { e.logger_("main segment loader ended"), e.onEndOfStream() })), this.mainSegmentLoader_.on("earlyabort", (function (t) { e.experimentalBufferBasedABR || (e.delegateLoaders_("all", ["abort"]), e.blacklistCurrentPlaylist({ message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering." }, 120)) })); var t = function () { if (!e.sourceUpdater_.hasCreatedSourceBuffers()) return e.tryToCreateSourceBuffers_(); var t = e.getCodecsOrExclude_(); t && e.sourceUpdater_.addOrChangeSourceBuffers(t) }; this.mainSegmentLoader_.on("trackinfo", t), this.audioSegmentLoader_.on("trackinfo", t), this.mainSegmentLoader_.on("fmp4", (function () { e.triggeredFmp4Usage || (e.tech_.trigger({ type: "usage", name: "vhs-fmp4" }), e.tech_.trigger({ type: "usage", name: "hls-fmp4" }), e.triggeredFmp4Usage = !0) })), this.audioSegmentLoader_.on("fmp4", (function () { e.triggeredFmp4Usage || (e.tech_.trigger({ type: "usage", name: "vhs-fmp4" }), e.tech_.trigger({ type: "usage", name: "hls-fmp4" }), e.triggeredFmp4Usage = !0) })), this.audioSegmentLoader_.on("ended", (function () { e.logger_("audioSegmentLoader ended"), e.onEndOfStream() })) }, i.mediaSecondsLoaded_ = function () { return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded) }, i.load = function () { this.mainSegmentLoader_.load(), this.mediaTypes_.AUDIO.activePlaylistLoader && this.audioSegmentLoader_.load() }, i.smoothQualityChange_ = function (e) { void 0 === e && (e = this.selectPlaylist()), this.fastQualityChange_(e) }, i.fastQualityChange_ = function (e) { var t = this; void 0 === e && (e = this.selectPlaylist()), e !== this.masterPlaylistLoader_.media() ? (this.switchMedia_(e, "fast-quality"), this.mainSegmentLoader_.resetEverything((function () { n.default.browser.IE_VERSION || n.default.browser.IS_EDGE ? t.tech_.setCurrentTime(t.tech_.currentTime() + .04) : t.tech_.setCurrentTime(t.tech_.currentTime()) }))) : this.logger_("skipping fastQualityChange because new media is same as old") }, i.play = function () { if (!this.setupFirstPlay()) { this.tech_.ended() && this.tech_.setCurrentTime(0), this.hasPlayed_ && this.load(); var e = this.tech_.seekable(); return this.tech_.duration() === 1 / 0 && this.tech_.currentTime() < e.start(0) ? this.tech_.setCurrentTime(e.end(e.length - 1)) : void 0 } }, i.setupFirstPlay = function () { var e = this, t = this.masterPlaylistLoader_.media(); if (!t || this.tech_.paused() || this.hasPlayed_) return !1; if (!t.endList) { var i = this.seekable(); if (!i.length) return !1; if (n.default.browser.IE_VERSION && 0 === this.tech_.readyState()) return this.tech_.one("loadedmetadata", (function () { e.trigger("firstplay"), e.tech_.setCurrentTime(i.end(0)), e.hasPlayed_ = !0 })), !1; this.trigger("firstplay"), this.tech_.setCurrentTime(i.end(0)) } return this.hasPlayed_ = !0, this.load(), !0 }, i.handleSourceOpen_ = function () { if (this.tryToCreateSourceBuffers_(), this.tech_.autoplay()) { var e = this.tech_.play(); void 0 !== e && "function" == typeof e.then && e.then(null, (function (e) { })) } this.trigger("sourceopen") }, i.handleSourceEnded_ = function () { this.inbandTextTracks_.metadataTrack_ }, i.handleDurationChange_ = function () { this.tech_.trigger("durationchange") }, i.onEndOfStream = function () { var e = this.mainSegmentLoader_.ended_; if (this.mediaTypes_.AUDIO.activePlaylistLoader) { var t = this.mainSegmentLoader_.getCurrentMediaInfo_(); e = !t || t.hasVideo ? e && this.audioSegmentLoader_.ended_ : this.audioSegmentLoader_.ended_ } e && (this.stopABRTimer_(), this.sourceUpdater_.endOfStream()) }, i.stuckAtPlaylistEnd_ = function (e) { if (!this.seekable().length) return !1; var t = this.syncController_.getExpiredTime(e, this.duration()); if (null === t) return !1; var i = $t.Playlist.playlistEnd(e, t), n = this.tech_.currentTime(), r = this.tech_.buffered(); if (!r.length) return i - n <= B; var a = r.end(r.length - 1); return a - n <= B && i - a <= B }, i.blacklistCurrentPlaylist = function (e, t) { void 0 === e && (e = {}); var i = e.playlist || this.masterPlaylistLoader_.media(); if (t = t || e.blacklistDuration || this.blacklistDuration, !i) return this.error = e, void ("open" !== this.mediaSource.readyState ? this.trigger("error") : this.sourceUpdater_.endOfStream("network")); i.playlistErrors_++; var r, a = this.masterPlaylistLoader_.master.playlists, s = a.filter(ne), o = 1 === s.length && s[0] === i; if (1 === a.length && t !== 1 / 0) return n.default.log.warn("Problem encountered with playlist " + i.id + ". Trying again since it is the only playlist."), this.tech_.trigger("retryplaylist"), this.masterPlaylistLoader_.load(o); if (o) { var u = !1; a.forEach((function (e) { if (e !== i) { var t = e.excludeUntil; void 0 !== t && t !== 1 / 0 && (u = !0, delete e.excludeUntil) } })), u && (n.default.log.warn("Removing other playlists from the exclusion list because the last rendition is about to be excluded."), this.tech_.trigger("retryplaylist")) } r = i.playlistErrors_ > this.maxPlaylistRetries ? 1 / 0 : Date.now() + 1e3 * t, i.excludeUntil = r, e.reason && (i.lastExcludeReason_ = e.reason), this.tech_.trigger("blacklistplaylist"), this.tech_.trigger({ type: "usage", name: "vhs-rendition-blacklisted" }), this.tech_.trigger({ type: "usage", name: "hls-rendition-blacklisted" }); var d = this.selectPlaylist(); if (!d) return this.error = "Playback cannot continue. No available working or supported playlists.", void this.trigger("error"); var l = e.internal ? this.logger_ : n.default.log.warn, h = e.message ? " " + e.message : ""; l((e.internal ? "Internal problem" : "Problem") + " encountered with playlist " + i.id + "." + h + " Switching to playlist " + d.id + "."), d.attributes.AUDIO !== i.attributes.AUDIO && this.delegateLoaders_("audio", ["abort", "pause"]), this.delegateLoaders_("main", ["abort", "pause"]); var c = d.targetDuration / 2 * 1e3 || 5e3, f = "number" == typeof d.lastRequest && Date.now() - d.lastRequest <= c; return this.switchMedia_(d, "exclude", o || f) }, i.pauseLoading = function () { this.delegateLoaders_("all", ["abort", "pause"]), this.stopABRTimer_() }, i.delegateLoaders_ = function (e, t) { var i = this, n = [], r = "all" === e; (r || "main" === e) && n.push(this.masterPlaylistLoader_); var a = []; (r || "audio" === e) && a.push("AUDIO"), a.forEach((function (e) { var t = i.mediaTypes_[e] && i.mediaTypes_[e].activePlaylistLoader; t && n.push(t) })), ["main", "audio"].forEach((function (t) { var r = i[t + "SegmentLoader_"]; !r || e !== t && "all" !== e || n.push(r) })), n.forEach((function (e) { return t.forEach((function (t) { "function" == typeof e[t] && e[t]() })) })) }, i.setCurrentTime = function (e) { var t = N(this.tech_.buffered(), e); return this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media() && this.masterPlaylistLoader_.media().segments ? t && t.length ? e : (this.mainSegmentLoader_.resetEverything(), this.mainSegmentLoader_.abort(), this.mediaTypes_.AUDIO.activePlaylistLoader && (this.audioSegmentLoader_.resetEverything(), this.audioSegmentLoader_.abort()), void this.load()) : 0 }, i.duration = function () { if (!this.masterPlaylistLoader_) return 0; var e = this.masterPlaylistLoader_.media(); return e ? e.endList ? this.mediaSource ? this.mediaSource.duration : $t.Playlist.duration(e) : 1 / 0 : 0 }, i.seekable = function () { return this.seekable_ }, i.onSyncInfoUpdate_ = function () { var e; if (this.masterPlaylistLoader_) { var t = this.masterPlaylistLoader_.media(); if (t) { var i = this.syncController_.getExpiredTime(t, this.duration()); if (null !== i) { var r = this.masterPlaylistLoader_.master, a = $t.Playlist.seekable(t, i, $t.Playlist.liveEdgeDelay(r, t)); if (0 !== a.length) { if (this.mediaTypes_.AUDIO.activePlaylistLoader) { if (t = this.mediaTypes_.AUDIO.activePlaylistLoader.media(), null === (i = this.syncController_.getExpiredTime(t, this.duration()))) return; if (0 === (e = $t.Playlist.seekable(t, i, $t.Playlist.liveEdgeDelay(r, t))).length) return } var s, o; this.seekable_ && this.seekable_.length && (s = this.seekable_.end(0), o = this.seekable_.start(0)), e ? e.start(0) > a.end(0) || a.start(0) > e.end(0) ? this.seekable_ = a : this.seekable_ = n.default.createTimeRanges([[e.start(0) > a.start(0) ? e.start(0) : a.start(0), e.end(0) < a.end(0) ? e.end(0) : a.end(0)]]) : this.seekable_ = a, this.seekable_ && this.seekable_.length && this.seekable_.end(0) === s && this.seekable_.start(0) === o || (this.logger_("seekable updated [" + W(this.seekable_) + "]"), this.tech_.trigger("seekablechanged")) } } } } }, i.updateDuration = function (e) { if (this.updateDuration_ && (this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.updateDuration_ = null), "open" !== this.mediaSource.readyState) return this.updateDuration_ = this.updateDuration.bind(this, e), void this.mediaSource.addEventListener("sourceopen", this.updateDuration_); if (e) { var t = this.seekable(); if (!t.length) return; (isNaN(this.mediaSource.duration) || this.mediaSource.duration < t.end(t.length - 1)) && this.sourceUpdater_.setDuration(t.end(t.length - 1)) } else { var i = this.tech_.buffered(), n = $t.Playlist.duration(this.masterPlaylistLoader_.media()); i.length > 0 && (n = Math.max(n, i.end(i.length - 1))), this.mediaSource.duration !== n && this.sourceUpdater_.setDuration(n) } }, i.dispose = function () { var e = this; this.trigger("dispose"), this.decrypter_.terminate(), this.masterPlaylistLoader_.dispose(), this.mainSegmentLoader_.dispose(), this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_), ["AUDIO"].forEach((function (t) { var i = e.mediaTypes_[t].groups; for (var n in i) i[n].forEach((function (e) { e.playlistLoader && e.playlistLoader.dispose() })) })), this.audioSegmentLoader_.dispose(), this.sourceUpdater_.dispose(), this.timelineChangeController_.dispose(), this.stopABRTimer_(), this.updateDuration_ && this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_), this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_), this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_), this.off() }, i.master = function () { return this.masterPlaylistLoader_.master }, i.media = function () { return this.masterPlaylistLoader_.media() || this.initialMedia_ }, i.areMediaTypesKnown_ = function () { var e = !!this.mediaTypes_.AUDIO.activePlaylistLoader, t = !!this.mainSegmentLoader_.getCurrentMediaInfo_(), i = !e || !!this.audioSegmentLoader_.getCurrentMediaInfo_(); return !(!t || !i) }, i.getCodecsOrExclude_ = function () { var e = this, t = { main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {}, audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {} }; t.video = t.main; var i = Rt(this.master(), this.media()), n = {}, r = !!this.mediaTypes_.AUDIO.activePlaylistLoader; if (t.main.hasVideo && (n.video = i.video || t.main.videoCodec || "avc1.4d400d"), t.main.isMuxed && (n.video += "," + (i.audio || t.main.audioCodec || U)), (t.main.hasAudio && !t.main.isMuxed || t.audio.hasAudio || r) && (n.audio = i.audio || t.main.audioCodec || t.audio.audioCodec || U, t.audio.isFmp4 = t.main.hasAudio && !t.main.isMuxed ? t.main.isFmp4 : t.audio.isFmp4), n.audio || n.video) { var a, s = {}; if (["video", "audio"].forEach((function (e) { if (n.hasOwnProperty(e) && (r = t[e].isFmp4, o = n[e], !(r ? C(o) : R(o)))) { var i = t[e].isFmp4 ? "browser" : "muxer"; s[i] = s[i] || [], s[i].push(n[e]), "audio" === e && (a = i) } var r, o })), r && a && this.media().attributes.AUDIO) { var o = this.media().attributes.AUDIO; this.master().playlists.forEach((function (t) { (t.attributes && t.attributes.AUDIO) === o && t !== e.media() && (t.excludeUntil = 1 / 0) })), this.logger_("excluding audio group " + o + " as " + a + ' does not support codec(s): "' + n.audio + '"') } if (!Object.keys(s).length) { if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) { var u = []; if (["video", "audio"].forEach((function (t) { var i = (P(e.sourceUpdater_.codecs[t] || "")[0] || {}).type, r = (P(n[t] || "")[0] || {}).type; i && r && i.toLowerCase() !== r.toLowerCase() && u.push('"' + e.sourceUpdater_.codecs[t] + '" -> "' + n[t] + '"') })), u.length) return void this.blacklistCurrentPlaylist({ playlist: this.media(), message: "Codec switching not supported: " + u.join(", ") + ".", blacklistDuration: 1 / 0, internal: !0 }) } return n } var d = Object.keys(s).reduce((function (e, t) { return e && (e += ", "), e + (t + ' does not support codec(s): "') + s[t].join(",") + '"' }), "") + "."; this.blacklistCurrentPlaylist({ playlist: this.media(), internal: !0, message: d, blacklistDuration: 1 / 0 }) } else this.blacklistCurrentPlaylist({ playlist: this.media(), message: "Could not determine codecs for playlist.", blacklistDuration: 1 / 0 }) }, i.tryToCreateSourceBuffers_ = function () { if ("open" === this.mediaSource.readyState && !this.sourceUpdater_.hasCreatedSourceBuffers() && this.areMediaTypesKnown_()) { var e = this.getCodecsOrExclude_(); if (e) { this.sourceUpdater_.createSourceBuffers(e); var t = [e.video, e.audio].filter(Boolean).join(","); this.excludeIncompatibleVariants_(t) } } }, i.excludeUnsupportedVariants_ = function () { var e = this, t = this.master().playlists, i = []; Object.keys(t).forEach((function (n) { var r = t[n]; if (-1 === i.indexOf(r.id)) { i.push(r.id); var a = Rt(e.master, r), s = []; !a.audio || R(a.audio) || C(a.audio) || s.push("audio codec " + a.audio), !a.video || R(a.video) || C(a.video) || s.push("video codec " + a.video), a.text && "stpp.ttml.im1t" === a.text && s.push("text codec " + a.text), s.length && (r.excludeUntil = 1 / 0, e.logger_("excluding " + r.id + " for unsupported: " + s.join(", "))) } })) }, i.excludeIncompatibleVariants_ = function (e) { var t = this, i = [], n = this.master().playlists, r = Dt(P(e)), a = Ct(r), s = r.video && P(r.video)[0] || null, o = r.audio && P(r.audio)[0] || null; Object.keys(n).forEach((function (e) { var r = n[e]; if (-1 === i.indexOf(r.id) && r.excludeUntil !== 1 / 0) { i.push(r.id); var u = [], d = Rt(t.masterPlaylistLoader_.master, r), l = Ct(d); if (d.audio || d.video) { if (l !== a && u.push('codec count "' + l + '" !== "' + a + '"'), !t.sourceUpdater_.canChangeType()) { var h = d.video && P(d.video)[0] || null, c = d.audio && P(d.audio)[0] || null; h && s && h.type.toLowerCase() !== s.type.toLowerCase() && u.push('video codec "' + h.type + '" !== "' + s.type + '"'), c && o && c.type.toLowerCase() !== o.type.toLowerCase() && u.push('audio codec "' + c.type + '" !== "' + o.type + '"') } u.length && (r.excludeUntil = 1 / 0, t.logger_("blacklisting " + r.id + ": " + u.join(" && "))) } } })) }, i.goalBufferLength = function () { var e = this.tech_.currentTime(), t = Ve.GOAL_BUFFER_LENGTH, i = Ve.GOAL_BUFFER_LENGTH_RATE, n = Math.max(t, Ve.MAX_GOAL_BUFFER_LENGTH); return Math.min(t + e * i, n) }, i.bufferLowWaterLine = function () { var e = this.tech_.currentTime(), t = Ve.BUFFER_LOW_WATER_LINE, i = Ve.BUFFER_LOW_WATER_LINE_RATE, n = Math.max(t, Ve.MAX_BUFFER_LOW_WATER_LINE), r = Math.max(t, Ve.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE); return Math.min(t + e * i, this.experimentalBufferBasedABR ? r : n) }, i.bufferHighWaterLine = function () { return Ve.BUFFER_HIGH_WATER_LINE }, t }(n.default.EventTarget), Oi = function (e, t, i) { var n, r, a, s = e.masterPlaylistController_, o = s[(e.options_.smoothQualityChange ? "smooth" : "fast") + "QualityChange_"].bind(s); if (t.attributes) { var u = t.attributes.RESOLUTION; this.width = u && u.width, this.height = u && u.height, this.bandwidth = t.attributes.BANDWIDTH, this.frameRate = t.attributes["FRAME-RATE"] } this.codecs = Rt(s.master(), t), this.playlist = t, this.id = i, this.enabled = (n = e.playlists, r = t.id, a = o, function (e) { var t = n.master.playlists[r], i = ie(t), s = ne(t); return void 0 === e ? s : (e ? delete t.disabled : t.disabled = !0, e === s || i || (a(), e ? n.trigger("renditionenabled") : n.trigger("renditiondisabled")), e) }) }, Di = ["seeking", "seeked", "pause", "playing", "error"], Ci = function () { function e(e) { var t = this; this.masterPlaylistController_ = e.masterPlaylistController, this.tech_ = e.tech, this.seekable = e.seekable, this.allowSeeksWithinUnsafeLiveWindow = e.allowSeeksWithinUnsafeLiveWindow, this.liveRangeSafeTimeDelta = e.liveRangeSafeTimeDelta, this.media = e.media, this.consecutiveUpdates = 0, this.lastRecordedTime = null, this.timer_ = null, this.checkCurrentTimeTimeout_ = null, this.logger_ = c("PlaybackWatcher"), this.logger_("initialize"); var i = function () { return t.monitorCurrentTime_() }, n = function () { return t.monitorCurrentTime_() }, r = function () { return t.techWaiting_() }, a = function () { return t.cancelTimer_() }, s = this.masterPlaylistController_, o = ["main", "audio"], u = {}; o.forEach((function (e) { u[e] = { reset: function () { return t.resetSegmentDownloads_(e) }, updateend: function () { return t.checkSegmentDownloads_(e) } }, s[e + "SegmentLoader_"].on("appendsdone", u[e].updateend), s[e + "SegmentLoader_"].on("playlistupdate", u[e].reset), t.tech_.on(["seeked", "seeking"], u[e].reset) })); var d = function (e) { ["main", "audio"].forEach((function (i) { s[i + "SegmentLoader_"][e]("appended", t.seekingAppendCheck_) })) }; this.seekingAppendCheck_ = function () { t.fixesBadSeeks_() && (t.consecutiveUpdates = 0, t.lastRecordedTime = t.tech_.currentTime(), d("off")) }, this.clearSeekingAppendCheck_ = function () { return d("off") }, this.watchForBadSeeking_ = function () { t.clearSeekingAppendCheck_(), d("on") }, this.tech_.on("seeked", this.clearSeekingAppendCheck_), this.tech_.on("seeking", this.watchForBadSeeking_), this.tech_.on("waiting", r), this.tech_.on(Di, a), this.tech_.on("canplay", n), this.tech_.one("play", i), this.dispose = function () { t.clearSeekingAppendCheck_(), t.logger_("dispose"), t.tech_.off("waiting", r), t.tech_.off(Di, a), t.tech_.off("canplay", n), t.tech_.off("play", i), t.tech_.off("seeking", t.watchForBadSeeking_), t.tech_.off("seeked", t.clearSeekingAppendCheck_), o.forEach((function (e) { s[e + "SegmentLoader_"].off("appendsdone", u[e].updateend), s[e + "SegmentLoader_"].off("playlistupdate", u[e].reset), t.tech_.off(["seeked", "seeking"], u[e].reset) })), t.checkCurrentTimeTimeout_ && window.clearTimeout(t.checkCurrentTimeTimeout_), t.cancelTimer_() } } var t = e.prototype; return t.monitorCurrentTime_ = function () { this.checkCurrentTime_(), this.checkCurrentTimeTimeout_ && window.clearTimeout(this.checkCurrentTimeTimeout_), this.checkCurrentTimeTimeout_ = window.setTimeout(this.monitorCurrentTime_.bind(this), 250) }, t.resetSegmentDownloads_ = function (e) { var t = this.masterPlaylistController_[e + "SegmentLoader_"]; this[e + "StalledDownloads_"] > 0 && this.logger_("resetting possible stalled download count for " + e + " loader"), this[e + "StalledDownloads_"] = 0, this[e + "Buffered_"] = t.buffered_() }, t.checkSegmentDownloads_ = function (e) { var t = this.masterPlaylistController_, i = t[e + "SegmentLoader_"], n = i.buffered_(), r = function (e, t) { if (e === t) return !1; if (!e && t || !t && e) return !0; if (e.length !== t.length) return !0; for (var i = 0; i < e.length; i++)if (e.start(i) !== t.start(i) || e.end(i) !== t.end(i)) return !0; return !1 }(this[e + "Buffered_"], n); this[e + "Buffered_"] = n, r ? this.resetSegmentDownloads_(e) : (this[e + "StalledDownloads_"]++, this.logger_("found #" + this[e + "StalledDownloads_"] + " " + e + " appends that did not increase buffer (possible stalled download)", { playlistId: i.playlist_ && i.playlist_.id, buffered: H(n) }), this[e + "StalledDownloads_"] < 10 || (this.logger_(e + " loader stalled download exclusion"), this.resetSegmentDownloads_(e), this.tech_.trigger({ type: "usage", name: "vhs-" + e + "-download-exclusion" }), t.blacklistCurrentPlaylist({ message: "Excessive " + e + " segment downloading detected." }, 1 / 0))) }, t.checkCurrentTime_ = function () { if (!this.tech_.paused() && !this.tech_.seeking()) { var e = this.tech_.currentTime(), t = this.tech_.buffered(); if (this.lastRecordedTime === e && (!t.length || e + B >= t.end(t.length - 1))) return this.techWaiting_(); this.consecutiveUpdates >= 5 && e === this.lastRecordedTime ? (this.consecutiveUpdates++, this.waiting_()) : e === this.lastRecordedTime ? this.consecutiveUpdates++ : (this.consecutiveUpdates = 0, this.lastRecordedTime = e) } }, t.cancelTimer_ = function () { this.consecutiveUpdates = 0, this.timer_ && (this.logger_("cancelTimer_"), clearTimeout(this.timer_)), this.timer_ = null }, t.fixesBadSeeks_ = function () { if (!this.tech_.seeking()) return !1; var e, t = this.seekable(), i = this.tech_.currentTime(); if (this.afterSeekableWindow_(t, i, this.media(), this.allowSeeksWithinUnsafeLiveWindow) && (e = t.end(t.length - 1)), this.beforeSeekableWindow_(t, i)) { var n = t.start(0); e = n + (n === t.end(0) ? 0 : B) } if (void 0 !== e) return this.logger_("Trying to seek outside of seekable at time " + i + " with seekable range " + W(t) + ". Seeking to " + e + "."), this.tech_.setCurrentTime(e), !0; for (var r = this.masterPlaylistController_.sourceUpdater_, a = this.tech_.buffered(), s = r.audioBuffer ? r.audioBuffered() : null, o = r.videoBuffer ? r.videoBuffered() : null, u = this.media(), d = u.partTargetDuration ? u.partTargetDuration : 2 * (u.targetDuration - M), l = [s, o], h = 0; h < l.length; h++)if (l[h] && V(l[h], i) < d) return !1; var c = q(a, i); return 0 !== c.length && (e = c.start(0) + B, this.logger_("Buffered region starts (" + c.start(0) + ")  just beyond seek point (" + i + "). Seeking to " + e + "."), this.tech_.setCurrentTime(e), !0) }, t.waiting_ = function () { if (!this.techWaiting_()) { var e = this.tech_.currentTime(), t = this.tech_.buffered(), i = N(t, e); return i.length && e + 3 <= i.end(0) ? (this.cancelTimer_(), this.tech_.setCurrentTime(e), this.logger_("Stopped at " + e + " while inside a buffered region [" + i.start(0) + " -> " + i.end(0) + "]. Attempting to resume playback by seeking to the current time."), this.tech_.trigger({ type: "usage", name: "vhs-unknown-waiting" }), void this.tech_.trigger({ type: "usage", name: "hls-unknown-waiting" })) : void 0 } }, t.techWaiting_ = function () { var e = this.seekable(), t = this.tech_.currentTime(); if (this.tech_.seeking() || null !== this.timer_) return !0; if (this.beforeSeekableWindow_(e, t)) { var i = e.end(e.length - 1); return this.logger_("Fell out of live window at time " + t + ". Seeking to live point (seekable end) " + i), this.cancelTimer_(), this.tech_.setCurrentTime(i), this.tech_.trigger({ type: "usage", name: "vhs-live-resync" }), this.tech_.trigger({ type: "usage", name: "hls-live-resync" }), !0 } var n = this.tech_.vhs.masterPlaylistController_.sourceUpdater_, r = this.tech_.buffered(); if (this.videoUnderflow_({ audioBuffered: n.audioBuffered(), videoBuffered: n.videoBuffered(), currentTime: t })) return this.cancelTimer_(), this.tech_.setCurrentTime(t), this.tech_.trigger({ type: "usage", name: "vhs-video-underflow" }), this.tech_.trigger({ type: "usage", name: "hls-video-underflow" }), !0; var a = q(r, t); if (a.length > 0) { var s = a.start(0) - t; return this.logger_("Stopped at " + t + ", setting timer for " + s + ", seeking to " + a.start(0)), this.cancelTimer_(), this.timer_ = setTimeout(this.skipTheGap_.bind(this), 1e3 * s, t), !0 } return !1 }, t.afterSeekableWindow_ = function (e, t, i, n) { return e.length, !1 }, t.beforeSeekableWindow_ = function (e, t) { return !!(e.length && e.start(0) > 0 && t < e.start(0) - this.liveRangeSafeTimeDelta) }, t.videoUnderflow_ = function (e) { var t = e.videoBuffered, i = e.audioBuffered, n = e.currentTime; if (t) { var r; if (t.length && i.length) { var a = N(t, n - 3), s = N(t, n), o = N(i, n); o.length && !s.length && a.length && (r = { start: a.end(0), end: o.end(0) }) } else q(t, n).length || (r = this.gapFromVideoUnderflow_(t, n)); return !!r && (this.logger_("Encountered a gap in video from " + r.start + " to " + r.end + ". Seeking to current time " + n), !0) } }, t.skipTheGap_ = function (e) { var t = this.tech_.buffered(), i = this.tech_.currentTime(), n = q(t, i); this.cancelTimer_(), 0 !== n.length && i === e && (this.logger_("skipTheGap_:", "currentTime:", i, "scheduled currentTime:", e, "nextRange start:", n.start(0)), this.tech_.setCurrentTime(n.start(0) + M), this.tech_.trigger({ type: "usage", name: "vhs-gap-skip" }), this.tech_.trigger({ type: "usage", name: "hls-gap-skip" })) }, t.gapFromVideoUnderflow_ = function (e, t) { for (var i = function (e) { if (e.length < 2) return n.default.createTimeRanges(); for (var t = [], i = 1; i < e.length; i++) { var r = e.end(i - 1), a = e.start(i); t.push([r, a]) } return n.default.createTimeRanges(t) }(e), r = 0; r < i.length; r++) { var a = i.start(r), s = i.end(r); if (t - a < 4 && t - a > 2) return { start: a, end: s } } return null }, e }(), Ri = { errorInterval: 30, getSource: function (e) { return e(this.tech({ IWillNotUseThisInPlugins: !0 }).currentSource_ || this.currentSource()) } }, Ui = function e(t, i) { var r = 0, a = 0, s = n.default.mergeOptions(Ri, i); t.ready((function () { t.trigger({ type: "usage", name: "vhs-error-reload-initialized" }), t.trigger({ type: "usage", name: "hls-error-reload-initialized" }) })); var o = function () { a && t.currentTime(a) }, u = function (e) { null != e && (a = t.duration() !== 1 / 0 && t.currentTime() || 0, t.one("loadedmetadata", o), t.src(e), t.trigger({ type: "usage", name: "vhs-error-reload" }), t.trigger({ type: "usage", name: "hls-error-reload" }), t.play()) }, d = function () { return Date.now() - r < 1e3 * s.errorInterval ? (t.trigger({ type: "usage", name: "vhs-error-reload-canceled" }), void t.trigger({ type: "usage", name: "hls-error-reload-canceled" })) : s.getSource && "function" == typeof s.getSource ? (r = Date.now(), s.getSource.call(t, u)) : void n.default.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!") }, l = function e() { t.off("loadedmetadata", o), t.off("error", d), t.off("dispose", e) }; t.on("error", d), t.on("dispose", l), t.reloadSourceOnError = function (i) { l(), e(t, i) } }, Mi = "2.15.0", Bi = { PlaylistLoader: Te, Playlist: de, utils: He, STANDARD_PLAYLIST_SELECTOR: Wt, INITIAL_PLAYLIST_SELECTOR: function () { var e = this, t = this.playlists.master.playlists.filter(de.isEnabled); return Ft(t, (function (e, t) { return Nt(e, t) })), t.filter((function (t) { return !!Rt(e.playlists.master, t).video }))[0] || null }, lastBandwidthSelector: Wt, movingAverageBandwidthSelector: function (e) { var t = -1, i = -1; if (e < 0 || e > 1) throw new Error("Moving average bandwidth decay must be between 0 and 1."); return function () { var n = this.useDevicePixelRatio && window.devicePixelRatio || 1; return t < 0 && (t = this.systemBandwidth, i = this.systemBandwidth), this.systemBandwidth > 0 && this.systemBandwidth !== i && (t = e * this.systemBandwidth + (1 - e) * t, i = this.systemBandwidth), qt(this.playlists.master, t, parseInt(Bt(this.tech_.el(), "width"), 10) * n, parseInt(Bt(this.tech_.el(), "height"), 10) * n, this.limitRenditionByPlayerDimensions, this.masterPlaylistController_) } }, comparePlaylistBandwidth: Nt, comparePlaylistResolution: function (e, t) { var i, n; return e.attributes.RESOLUTION && e.attributes.RESOLUTION.width && (i = e.attributes.RESOLUTION.width), i = i || window.Number.MAX_VALUE, t.attributes.RESOLUTION && t.attributes.RESOLUTION.width && (n = t.attributes.RESOLUTION.width), i === (n = n || window.Number.MAX_VALUE) && e.attributes.BANDWIDTH && t.attributes.BANDWIDTH ? e.attributes.BANDWIDTH - t.attributes.BANDWIDTH : i - n }, xhr: Ie() }; Object.keys(Ve).forEach((function (e) { Object.defineProperty(Bi, e, { get: function () { return n.default.log.warn("using Vhs." + e + " is UNSAFE be sure you know what you are doing"), Ve[e] }, set: function (t) { n.default.log.warn("using Vhs." + e + " is UNSAFE be sure you know what you are doing"), "number" != typeof t || t < 0 ? n.default.log.warn("value of Vhs." + e + " must be greater than or equal to 0") : Ve[e] = t } }) })); var Fi = "videojs-vhs", Ni = function (e, t) { for (var i = t.media(), n = -1, r = 0; r < e.length; r++)if (e[r].id === i.id) { n = r; break } e.selectedIndex_ = n, e.trigger({ selectedIndex: n, type: "change" }) }; Bi.canPlaySource = function () { return n.default.log.warn("HLS is no longer a tech. Please remove it from your player's techOrder.") }; var qi = function (e, t, i) { if (!e) return e; var r = {}; t && t.attributes && t.attributes.CODECS && (r = Dt(P(t.attributes.CODECS))), i && i.attributes && i.attributes.CODECS && (r.audio = i.attributes.CODECS); var a = D(r.video), s = D(r.audio), o = {}; for (var u in e) o[u] = {}, s && (o[u].audioContentType = s), a && (o[u].videoContentType = a), t.contentProtection && t.contentProtection[u] && t.contentProtection[u].pssh && (o[u].pssh = t.contentProtection[u].pssh), "string" == typeof e[u] && (o[u].url = e[u]); return n.default.mergeOptions(e, o) }, Wi = function (e, t) { return e.reduce((function (e, i) { if (!i.contentProtection) return e; var n = t.reduce((function (e, t) { var n = i.contentProtection[t]; return n && n.pssh && (e[t] = { pssh: n.pssh }), e }), {}); return Object.keys(n).length && e.push(n), e }), []) }, Hi = function (e) { var t = e.player, i = e.sourceKeySystems, n = e.audioMedia, r = e.mainPlaylists; if (!t.eme.initializeMediaKeys) return Promise.resolve(); var a = n ? r.concat([n]) : r, s = Wi(a, Object.keys(i)), o = [], u = []; return s.forEach((function (e) { u.push(new Promise((function (e, i) { t.tech_.one("keysessioncreated", e) }))), o.push(new Promise((function (i, n) { t.eme.initializeMediaKeys({ keySystems: e }, (function (e) { e ? n(e) : i() })) }))) })), Promise.race([Promise.all(o), Promise.race(u)]) }, Gi = function (e) { var t = e.player, i = e.sourceKeySystems, r = e.media, a = e.audioMedia, s = qi(i, r, a); return !(!s || (t.currentSource().keySystems = s, s && !t.eme && (n.default.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin"), 1))) }, Vi = function () { if (!window.localStorage) return null; var e = window.localStorage.getItem(Fi); if (!e) return null; try { return JSON.parse(e) } catch (e) { return null } }, ji = function (e) { return 0 === e.toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") ? JSON.parse(e.substring(e.indexOf(",") + 1)) : e }; Bi.supportsNativeHls = function () { if (!document || !document.createElement) return !1; var e = document.createElement("video"); return !!n.default.getTech("Html5").isSupported() && ["application/vnd.apple.mpegurl", "audio/mpegurl", "audio/x-mpegurl", "application/x-mpegurl", "video/x-mpegurl", "video/mpegurl", "application/mpegurl"].some((function (t) { return /maybe|probably/i.test(e.canPlayType(t)) })) }(), Bi.supportsNativeDash = !!(document && document.createElement && n.default.getTech("Html5").isSupported()) && /maybe|probably/i.test(document.createElement("video").canPlayType("application/dash+xml")), Bi.supportsTypeNatively = function (e) { return "hls" === e ? Bi.supportsNativeHls : "dash" === e && Bi.supportsNativeDash }, Bi.isSupported = function () { return n.default.log.warn("HLS is no longer a tech. Please remove it from your player's techOrder.") }; var Xi = function (e) { function t(t, i, r) { var s; if (s = e.call(this, i, n.default.mergeOptions(r.hls, r.vhs)) || this, r.hls && Object.keys(r.hls).length && n.default.log.warn("Using hls options is deprecated. Please rename `hls` to `vhs` in your options object."), "number" == typeof r.initialBandwidth && (s.options_.bandwidth = r.initialBandwidth), s.logger_ = c("VhsHandler"), i.options_ && i.options_.playerId) { var o = n.default(i.options_.playerId); o.hasOwnProperty("hls") || Object.defineProperty(o, "hls", { get: function () { return n.default.log.warn("player.hls is deprecated. Use player.tech().vhs instead."), i.trigger({ type: "usage", name: "hls-player-access" }), a(s) }, configurable: !0 }), o.hasOwnProperty("vhs") || Object.defineProperty(o, "vhs", { get: function () { return n.default.log.warn("player.vhs is deprecated. Use player.tech().vhs instead."), i.trigger({ type: "usage", name: "vhs-player-access" }), a(s) }, configurable: !0 }), o.hasOwnProperty("dash") || Object.defineProperty(o, "dash", { get: function () { return n.default.log.warn("player.dash is deprecated. Use player.tech().vhs instead."), a(s) }, configurable: !0 }), s.player_ = o } if (s.tech_ = i, s.source_ = t, s.stats = {}, s.ignoreNextSeekingEvent_ = !1, s.setOptions_(), s.options_.overrideNative && i.overrideNativeAudioTracks && i.overrideNativeVideoTracks) i.overrideNativeAudioTracks(!0), i.overrideNativeVideoTracks(!0); else if (s.options_.overrideNative && (i.featuresNativeVideoTracks || i.featuresNativeAudioTracks)) throw new Error("Overriding native HLS requires emulated tracks. See https://git.io/vMpjB"); return s.on(document, ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"], (function (e) { var t = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement; t && t.contains(s.tech_.el()) ? s.masterPlaylistController_.fastQualityChange_() : s.masterPlaylistController_.checkABR_() })), s.on(s.tech_, "seeking", (function () { this.ignoreNextSeekingEvent_ ? this.ignoreNextSeekingEvent_ = !1 : this.setCurrentTime(this.tech_.currentTime()) })), s.on(s.tech_, "error", (function () { this.tech_.error() && this.masterPlaylistController_ && this.masterPlaylistController_.pauseLoading() })), s.on(s.tech_, "play", s.play), s } o(t, e); var i = t.prototype; return i.setOptions_ = function () { var e = this; if (this.options_.withCredentials = this.options_.withCredentials || !1, this.options_.handleManifestRedirects = !1 !== this.options_.handleManifestRedirects, this.options_.limitRenditionByPlayerDimensions = !1 !== this.options_.limitRenditionByPlayerDimensions, this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || !1, this.options_.smoothQualityChange = this.options_.smoothQualityChange || !1, this.options_.useBandwidthFromLocalStorage = void 0 !== this.source_.useBandwidthFromLocalStorage ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || !1, this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || !1, this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || !1, this.options_.customTagParsers = this.options_.customTagParsers || [], this.options_.customTagMappers = this.options_.customTagMappers || [], this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || !1, "number" != typeof this.options_.blacklistDuration && (this.options_.blacklistDuration = 300), "number" != typeof this.options_.bandwidth && this.options_.useBandwidthFromLocalStorage) { var t = Vi(); t && t.bandwidth && (this.options_.bandwidth = t.bandwidth, this.tech_.trigger({ type: "usage", name: "vhs-bandwidth-from-local-storage" }), this.tech_.trigger({ type: "usage", name: "hls-bandwidth-from-local-storage" })), t && t.throughput && (this.options_.throughput = t.throughput, this.tech_.trigger({ type: "usage", name: "vhs-throughput-from-local-storage" }), this.tech_.trigger({ type: "usage", name: "hls-throughput-from-local-storage" })) } "number" != typeof this.options_.bandwidth && (this.options_.bandwidth = Ve.INITIAL_BANDWIDTH), this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Ve.INITIAL_BANDWIDTH, ["withCredentials", "useDevicePixelRatio", "limitRenditionByPlayerDimensions", "bandwidth", "smoothQualityChange", "customTagParsers", "customTagMappers", "handleManifestRedirects", "cacheEncryptionKeys", "playlistSelector", "initialPlaylistSelector", "experimentalBufferBasedABR", "liveRangeSafeTimeDelta", "experimentalLLHLS", "useNetworkInformationApi", "useDtsForTimestampOffset", "experimentalExactManifestTimings", "experimentalLeastPixelDiffSelector"].forEach((function (t) { void 0 !== e.source_[t] && (e.options_[t] = e.source_[t]) })), this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions, this.useDevicePixelRatio = this.options_.useDevicePixelRatio }, i.src = function (e, t) { var i = this; if (e) { this.setOptions_(), this.options_.src = ji(this.source_.src), this.options_.tech = this.tech_, this.options_.externVhs = Bi, this.options_.sourceType = ke(t), this.options_.seekTo = function (e) { i.tech_.setCurrentTime(e) }, this.options_.smoothQualityChange && n.default.log.warn("smoothQualityChange is deprecated and will be removed in the next major version"), this.masterPlaylistController_ = new Pi(this.options_); var r = n.default.mergeOptions({ liveRangeSafeTimeDelta: B }, this.options_, { seekable: function () { return i.seekable() }, media: function () { return i.masterPlaylistController_.media() }, masterPlaylistController: this.masterPlaylistController_ }); this.playbackWatcher_ = new Ci(r), this.masterPlaylistController_.on("error", (function () { var e = n.default.players[i.tech_.options_.playerId], t = i.masterPlaylistController_.error; "object" != typeof t || t.code ? "string" == typeof t && (t = { message: t, code: 3 }) : t.code = 3, e.error(t) })); var a = this.options_.experimentalBufferBasedABR ? Bi.movingAverageBandwidthSelector(.55) : Bi.STANDARD_PLAYLIST_SELECTOR; this.masterPlaylistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : a.bind(this), this.masterPlaylistController_.selectInitialPlaylist = Bi.INITIAL_PLAYLIST_SELECTOR.bind(this), this.playlists = this.masterPlaylistController_.masterPlaylistLoader_, this.mediaSource = this.masterPlaylistController_.mediaSource, Object.defineProperties(this, { selectPlaylist: { get: function () { return this.masterPlaylistController_.selectPlaylist }, set: function (e) { this.masterPlaylistController_.selectPlaylist = e.bind(this) } }, throughput: { get: function () { return this.masterPlaylistController_.mainSegmentLoader_.throughput.rate }, set: function (e) { this.masterPlaylistController_.mainSegmentLoader_.throughput.rate = e, this.masterPlaylistController_.mainSegmentLoader_.throughput.count = 1 } }, bandwidth: { get: function () { var e = this.masterPlaylistController_.mainSegmentLoader_.bandwidth, t = window.navigator.connection || window.navigator.mozConnection || window.navigator.webkitConnection, i = 1e7; if (this.options_.useNetworkInformationApi && t) { var n = 1e3 * t.downlink * 1e3; e = n >= i && e >= i ? Math.max(e, n) : n } return e }, set: function (e) { this.masterPlaylistController_.mainSegmentLoader_.bandwidth = e, this.masterPlaylistController_.mainSegmentLoader_.throughput = { rate: 0, count: 0 } } }, systemBandwidth: { get: function () { var e, t = 1 / (this.bandwidth || 1); return e = this.throughput > 0 ? 1 / this.throughput : 0, Math.floor(1 / (t + e)) }, set: function () { n.default.log.error('The "systemBandwidth" property is read-only') } } }), this.options_.bandwidth && (this.bandwidth = this.options_.bandwidth), this.options_.throughput && (this.throughput = this.options_.throughput), Object.defineProperties(this.stats, { bandwidth: { get: function () { return i.bandwidth || 0 }, enumerable: !0 }, mediaRequests: { get: function () { return i.masterPlaylistController_.mediaRequests_() || 0 }, enumerable: !0 }, mediaRequestsAborted: { get: function () { return i.masterPlaylistController_.mediaRequestsAborted_() || 0 }, enumerable: !0 }, mediaRequestsTimedout: { get: function () { return i.masterPlaylistController_.mediaRequestsTimedout_() || 0 }, enumerable: !0 }, mediaRequestsErrored: { get: function () { return i.masterPlaylistController_.mediaRequestsErrored_() || 0 }, enumerable: !0 }, mediaTransferDuration: { get: function () { return i.masterPlaylistController_.mediaTransferDuration_() || 0 }, enumerable: !0 }, mediaBytesTransferred: { get: function () { return i.masterPlaylistController_.mediaBytesTransferred_() || 0 }, enumerable: !0 }, mediaSecondsLoaded: { get: function () { return i.masterPlaylistController_.mediaSecondsLoaded_() || 0 }, enumerable: !0 }, mediaAppends: { get: function () { return i.masterPlaylistController_.mediaAppends_() || 0 }, enumerable: !0 }, mainAppendsToLoadedData: { get: function () { return i.masterPlaylistController_.mainAppendsToLoadedData_() || 0 }, enumerable: !0 }, audioAppendsToLoadedData: { get: function () { return i.masterPlaylistController_.audioAppendsToLoadedData_() || 0 }, enumerable: !0 }, appendsToLoadedData: { get: function () { return i.masterPlaylistController_.appendsToLoadedData_() || 0 }, enumerable: !0 }, timeToLoadedData: { get: function () { return i.masterPlaylistController_.timeToLoadedData_() || 0 }, enumerable: !0 }, buffered: { get: function () { return H(i.tech_.buffered()) }, enumerable: !0 }, currentTime: { get: function () { return i.tech_.currentTime() }, enumerable: !0 }, currentSource: { get: function () { return i.tech_.currentSource_ }, enumerable: !0 }, currentTech: { get: function () { return i.tech_.name_ }, enumerable: !0 }, duration: { get: function () { return i.tech_.duration() }, enumerable: !0 }, master: { get: function () { return i.playlists.master }, enumerable: !0 }, playerDimensions: { get: function () { return i.tech_.currentDimensions() }, enumerable: !0 }, seekable: { get: function () { return H(i.tech_.seekable()) }, enumerable: !0 }, timestamp: { get: function () { return Date.now() }, enumerable: !0 }, videoPlaybackQuality: { get: function () { return i.tech_.getVideoPlaybackQuality() }, enumerable: !0 } }), this.tech_.one("canplay", this.masterPlaylistController_.setupFirstPlay.bind(this.masterPlaylistController_)), this.tech_.on("bandwidthupdate", (function () { i.options_.useBandwidthFromLocalStorage && function (e) { if (!window.localStorage) return !1; var t = Vi(); t = t ? n.default.mergeOptions(t, e) : e; try { window.localStorage.setItem(Fi, JSON.stringify(t)) } catch (e) { return !1 } }({ bandwidth: i.bandwidth, throughput: Math.round(i.throughput) }) })), this.masterPlaylistController_.on("selectedinitialmedia", (function () { var e; (e = i).representations = function () { var t = e.masterPlaylistController_.master(), i = ue(t) ? e.masterPlaylistController_.getAudioTrackPlaylists_() : t.playlists; return i ? i.filter((function (e) { return !ie(e) })).map((function (t, i) { return new Oi(e, t, t.id) })) : [] } })), this.masterPlaylistController_.sourceUpdater_.on("createdsourcebuffers", (function () { i.setupEme_() })), this.on(this.masterPlaylistController_, "progress", (function () { this.tech_.trigger("progress") })), this.on(this.masterPlaylistController_, "firstplay", (function () { this.ignoreNextSeekingEvent_ = !0 })), this.setupQualityLevels_(), this.tech_.el() && (this.mediaSourceUrl_ = window.URL.createObjectURL(this.masterPlaylistController_.mediaSource), this.tech_.src(this.mediaSourceUrl_)) } }, i.createKeySessions_ = function () { var e = this, t = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader; this.logger_("waiting for EME key session creation"), Hi({ player: this.player_, sourceKeySystems: this.source_.keySystems, audioMedia: t && t.media(), mainPlaylists: this.playlists.master.playlists }).then((function () { e.logger_("created EME key session"), e.masterPlaylistController_.sourceUpdater_.initializedEme() })).catch((function (t) { e.logger_("error while creating EME key session", t), e.player_.error({ message: "Failed to initialize media keys for EME", code: 3 }) })) }, i.handleWaitingForKey_ = function () { this.logger_("waitingforkey fired, attempting to create any new key sessions"), this.createKeySessions_() }, i.setupEme_ = function () { var e = this, t = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader, i = Gi({ player: this.player_, sourceKeySystems: this.source_.keySystems, media: this.playlists.media(), audioMedia: t && t.media() }); this.player_.tech_.on("keystatuschange", (function (t) { if ("output-restricted" === t.status) { var i = e.masterPlaylistController_.master(); if (i && i.playlists) { var r, a = []; i.playlists.forEach((function (e) { e && e.attributes && e.attributes.RESOLUTION && e.attributes.RESOLUTION.height >= 720 && (!e.excludeUntil || e.excludeUntil < 1 / 0) && (e.excludeUntil = 1 / 0, a.push(e)) })), a.length && ((r = n.default.log).warn.apply(r, ['DRM keystatus changed to "output-restricted." Removing the following HD playlists that will most likely fail to play and clearing the buffer. This may be due to HDCP restrictions on the stream and the capabilities of the current device.'].concat(a)), e.masterPlaylistController_.fastQualityChange_()) } } })), this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this), this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_), 11 !== n.default.browser.IE_VERSION && i ? this.createKeySessions_() : this.masterPlaylistController_.sourceUpdater_.initializedEme() }, i.setupQualityLevels_ = function () { var e = this, t = n.default.players[this.tech_.options_.playerId]; t && t.qualityLevels && !this.qualityLevels_ && (this.qualityLevels_ = t.qualityLevels(), this.masterPlaylistController_.on("selectedinitialmedia", (function () { var t, i; t = e.qualityLevels_, (i = e).representations().forEach((function (e) { t.addQualityLevel(e) })), Ni(t, i.playlists) })), this.playlists.on("mediachange", (function () { Ni(e.qualityLevels_, e.playlists) }))) }, t.version = function () { return { "@videojs/http-streaming": Mi, "mux.js": "6.0.1", "mpd-parser": "0.22.0", "m3u8-parser": "4.8.0", "aes-decrypter": "3.1.3" } }, i.version = function () { return this.constructor.version() }, i.canChangeType = function () { return pi.canChangeType() }, i.play = function () { this.masterPlaylistController_.play() }, i.setCurrentTime = function (e) { this.masterPlaylistController_.setCurrentTime(e) }, i.duration = function () { return this.masterPlaylistController_.duration() }, i.seekable = function () { return this.masterPlaylistController_.seekable() }, i.dispose = function () { this.playbackWatcher_ && this.playbackWatcher_.dispose(), this.masterPlaylistController_ && this.masterPlaylistController_.dispose(), this.qualityLevels_ && this.qualityLevels_.dispose(), this.player_ && (delete this.player_.vhs, delete this.player_.dash, delete this.player_.hls), this.tech_ && this.tech_.vhs && delete this.tech_.vhs, this.tech_ && delete this.tech_.hls, this.mediaSourceUrl_ && window.URL.revokeObjectURL && (window.URL.revokeObjectURL(this.mediaSourceUrl_), this.mediaSourceUrl_ = null), this.tech_ && this.tech_.off("waitingforkey", this.handleWaitingForKey_), e.prototype.dispose.call(this) }, i.convertToProgramTime = function (e, t) { return function (e) { var t = e.playlist, i = e.time, n = void 0 === i ? void 0 : i, r = e.callback; if (!r) throw new Error("getProgramTime: callback must be provided"); if (!t || void 0 === n) return r({ message: "getProgramTime: playlist and time must be provided" }); var a = function (e, t) { if (!t || !t.segments || 0 === t.segments.length) return null; for (var i, n = 0, r = 0; r < t.segments.length && !(e <= (n = (i = t.segments[r]).videoTimingInfo ? i.videoTimingInfo.transmuxedPresentationEnd : n + i.duration)); r++); var a = t.segments[t.segments.length - 1]; if (a.videoTimingInfo && a.videoTimingInfo.transmuxedPresentationEnd < e) return null; if (e > n) { if (e > n + .25 * a.duration) return null; i = a } return { segment: i, estimatedStart: i.videoTimingInfo ? i.videoTimingInfo.transmuxedPresentationStart : n - i.duration, type: i.videoTimingInfo ? "accurate" : "estimate" } }(n, t); if (!a) return r({ message: "valid programTime was not found" }); if ("estimate" === a.type) return r({ message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again", seekTime: a.estimatedStart }); var s = { mediaSeconds: n }, o = function (e, t) { if (!t.dateTimeObject) return null; var i = t.videoTimingInfo.transmuxerPrependedSeconds, n = e - (t.videoTimingInfo.transmuxedPresentationStart + i); return new Date(t.dateTimeObject.getTime() + 1e3 * n) }(n, a.segment); return o && (s.programDateTime = o.toISOString()), r(null, s) }({ playlist: this.masterPlaylistController_.media(), time: e, callback: t }) }, i.seekToProgramTime = function (e, t, i, n) { return void 0 === i && (i = !0), void 0 === n && (n = 2), Ge({ programTime: e, playlist: this.masterPlaylistController_.media(), retryCount: n, pauseAfterSeek: i, seekTo: this.options_.seekTo, tech: this.options_.tech, callback: t }) }, t }(n.default.getComponent("Component")), Qi = { name: "videojs-http-streaming", VERSION: Mi, canHandleSource: function (e, t) { void 0 === t && (t = {}); var i = n.default.mergeOptions(n.default.options, t); return Qi.canPlayType(e.type, i) }, handleSource: function (e, t, i) { void 0 === i && (i = {}); var r = n.default.mergeOptions(n.default.options, i); return t.vhs = new Xi(e, t, r), n.default.hasOwnProperty("hls") || Object.defineProperty(t, "hls", { get: function () { return n.default.log.warn("player.tech().hls is deprecated. Use player.tech().vhs instead."), t.vhs }, configurable: !0 }), t.vhs.xhr = Ie(), t.vhs.src(e.src, e.type), t.vhs }, canPlayType: function (e, t) { void 0 === t && (t = {}); var i = n.default.mergeOptions(n.default.options, t), r = i.vhs, a = (r = void 0 === r ? {} : r).overrideNative, s = void 0 === a ? !n.default.browser.IS_ANY_SAFARI : a, o = i.hls, u = (o = void 0 === o ? {} : o).overrideNative, d = void 0 !== u && u, l = ke(e); return l && (!Bi.supportsTypeNatively(l) || d || s) ? "maybe" : "" } }; C("avc1.4d400d,mp4a.40.2") && n.default.getTech("Html5").registerSourceHandler(Qi, 0), n.default.VhsHandler = Xi, Object.defineProperty(n.default, "HlsHandler", { get: function () { return n.default.log.warn("videojs.HlsHandler is deprecated. Use videojs.VhsHandler instead."), Xi }, configurable: !0 }), n.default.VhsSourceHandler = Qi, Object.defineProperty(n.default, "HlsSourceHandler", { get: function () { return n.default.log.warn("videojs.HlsSourceHandler is deprecated. Use videojs.VhsSourceHandler instead."), Qi }, configurable: !0 }), n.default.Vhs = Bi, Object.defineProperty(n.default, "Hls", { get: function () { return n.default.log.warn("videojs.Hls is deprecated. Use videojs.Vhs instead."), Bi }, configurable: !0 }), n.default.use || (n.default.registerComponent("Hls", Bi), n.default.registerComponent("Vhs", Bi)), n.default.options.vhs = n.default.options.vhs || {}, n.default.options.hls = n.default.options.hls || {}, n.default.getPlugin && n.default.getPlugin("reloadSourceOnError") || (n.default.registerPlugin || n.default.plugin)("reloadSourceOnError", (function (e) { Ui(this, e) })), e.LOCAL_STORAGE_KEY = Fi, e.Vhs = Bi, e.VhsHandler = Xi, e.VhsSourceHandler = Qi, e.emeKeySystems = qi, e.expandDataUri = ji, e.getAllPsshKeySystemsOptions = Wi, e.setupEmeOptions = Gi, e.simpleTypeFromSourceType = ke, e.waitForKeySessionCreation = Hi, Object.defineProperty(e, "__esModule", { value: !0 })
}));